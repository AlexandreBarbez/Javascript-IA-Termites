{
  "version": 3,
  "file": "app.js",
  "sources": [
    "vendor/js/matter.js",
    "vendor/js/pixi.dev.js",
    "vendor/js/underscore.js",
    "generated/template/underscore.js",
    "app/js/agent.js",
    "app/js/equipe1.js",
    "app/js/equipe2.js",
    "app/js/extend.js",
    "app/js/init.js",
    "app/js/physics.js",
    "app/js/ressource.js",
    "app/js/world.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC1uPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,c;AC54bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9zCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourcesContent": [
    "/**\n* matter.js 0.8.0-edge 2015-01-21\n* http://brm.io/matter-js/\n* License: MIT\n*/\n\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Liam Brummitt\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n(function() {\n\nvar Matter = {};\n\n// Begin Matter namespace closure\n\n// All Matter modules are included below during build\n// Outro.js then closes at the end of the file\n\n\n// Begin src/body/Body.js\n\n/**\n* The `Matter.Body` module contains methods for creating and manipulating body models.\n* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.\n* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.\n*\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n\n* @class Body\n*/\n\nvar Body = {};\n\n(function() {\n\n    Body._inertiaScale = 4;\n\n    var _nextCollidingGroupId = 1,\n        _nextNonCollidingGroupId = -1,\n        _nextCategory = 0x0001;\n\n    /**\n     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {body} body\n     */\n    Body.create = function(options) {\n        var defaults = {\n            id: Common.nextId(),\n            type: 'body',\n            label: 'Body',\n            angle: 0,\n            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),\n            position: { x: 0, y: 0 },\n            force: { x: 0, y: 0 },\n            torque: 0,\n            positionImpulse: { x: 0, y: 0 },\n            constraintImpulse: { x: 0, y: 0, angle: 0 },\n            speed: 0,\n            angularSpeed: 0,\n            velocity: { x: 0, y: 0 },\n            angularVelocity: 0,\n            isStatic: false,\n            isSleeping: false,\n            motion: 0,\n            sleepThreshold: 60,\n            density: 0.001,\n            restitution: 0,\n            friction: 0.1,\n            frictionAir: 0.01,\n            collisionFilter: {\n                category: 0x0001,\n                mask: 0xFFFFFFFF,\n                group: 0\n            },\n            slop: 0.05,\n            timeScale: 1,\n            render: {\n                visible: true,\n                sprite: {\n                    xScale: 1,\n                    yScale: 1\n                },\n                lineWidth: 1.5\n            }\n        };\n\n        var body = Common.extend(defaults, options);\n\n        _initProperties(body, options);\n\n        return body;\n    };\n\n    /**\n     * Returns the next unique group index for which bodies will collide.\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\n     * See `body.collisionFilter` for more information.\n     * @method nextGroup\n     * @param {bool} [isNonColliding=false]\n     * @return {Number} Unique group index\n     */\n    Body.nextGroup = function(isNonColliding) {\n        if (isNonColliding)\n            return _nextNonCollidingGroupId--;\n\n        return _nextCollidingGroupId++;\n    };\n\n    /**\n     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\n     * There are 32 available. See `body.collisionFilter` for more information.\n     * @method nextCategory\n     * @return {Number} Unique category bitfield\n     */\n    Body.nextCategory = function() {\n        _nextCategory = _nextCategory << 1;\n        return _nextCategory;\n    };\n\n    /**\n     * Initialises body properties.\n     * @method _initProperties\n     * @private\n     * @param {body} body\n     * @param {} options\n     */\n    var _initProperties = function(body, options) {\n        // init required properties\n        Body.set(body, {\n            bounds: body.bounds || Bounds.create(body.vertices),\n            positionPrev: body.positionPrev || Vector.clone(body.position),\n            anglePrev: body.anglePrev || body.angle,\n            vertices: body.vertices,\n            isStatic: body.isStatic,\n            isSleeping: body.isSleeping\n        });\n\n        Vertices.rotate(body.vertices, body.angle, body.position);\n        Axes.rotate(body.axes, body.angle);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n\n        // allow options to override the automatically calculated properties\n        Body.set(body, {\n            axes: options.axes || body.axes,\n            area: options.area || body.area,\n            mass: options.mass || body.mass,\n            inertia: options.inertia || body.inertia\n        });\n\n        // render properties\n        var defaultFillStyle = (body.isStatic ? '#eeeeee' : Common.choose(['#556270', '#4ECDC4', '#C7F464', '#FF6B6B', '#C44D58'])),\n            defaultStrokeStyle = Common.shadeColor(defaultFillStyle, -20);\n        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n    };\n\n    /**\n     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\n     * Prefer to use the actual setter functions in performance critical situations.\n     * @method set\n     * @param {body} body\n     * @param {} settings A property name (or map of properties and values) to set on the body.\n     * @param {} value The value to set if `settings` is a single property name.\n     */\n    Body.set = function(body, settings, value) {\n        var property;\n\n        if (typeof settings === 'string') {\n            property = settings;\n            settings = {};\n            settings[property] = value;\n        }\n\n        for (property in settings) {\n            value = settings[property];\n\n            if (!settings.hasOwnProperty(property))\n                continue;\n\n            switch (property) {\n\n            case 'isStatic':\n                Body.setStatic(body, value);\n                break;\n            case 'isSleeping':\n                Sleeping.set(body, value);\n                break;\n            case 'mass':\n                Body.setMass(body, value);\n                break;\n            case 'density':\n                Body.setDensity(body, value);\n                break;\n            case 'inertia':\n                Body.setInertia(body, value);\n                break;\n            case 'vertices':\n                Body.setVertices(body, value);\n                break;\n            case 'position':\n                Body.setPosition(body, value);\n                break;\n            case 'angle':\n                Body.setAngle(body, value);\n                break;\n            case 'velocity':\n                Body.setVelocity(body, value);\n                break;\n            case 'angularVelocity':\n                Body.setAngularVelocity(body, value);\n                break;\n            default:\n                body[property] = value;\n\n            }\n        }\n    };\n\n    /**\n     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\n     * @method setStatic\n     * @param {body} body\n     * @param {bool} isStatic\n     */\n    Body.setStatic = function(body, isStatic) {\n        body.isStatic = isStatic;\n\n        if (isStatic) {\n            body.restitution = 0;\n            body.friction = 1;\n            body.mass = body.inertia = body.density = Infinity;\n            body.inverseMass = body.inverseInertia = 0;\n\n            body.positionPrev.x = body.position.x;\n            body.positionPrev.y = body.position.y;\n            body.anglePrev = body.angle;\n            body.angularVelocity = 0;\n            body.speed = 0;\n            body.angularSpeed = 0;\n            body.motion = 0;\n        }\n    };\n\n    /**\n     * Sets the mass of the body. Inverse mass and density are automatically updated to reflect the change.\n     * @method setMass\n     * @param {body} body\n     * @param {number} mass\n     */\n    Body.setMass = function(body, mass) {\n        body.mass = mass;\n        body.inverseMass = 1 / body.mass;\n        body.density = body.mass / body.area;\n    };\n\n    /**\n     * Sets the density of the body. Mass is automatically updated to reflect the change.\n     * @method setDensity\n     * @param {body} body\n     * @param {number} density\n     */\n    Body.setDensity = function(body, density) {\n        Body.setMass(body, density * body.area);\n        body.density = density;\n    };\n\n    /**\n     * Sets the moment of inertia (i.e. second moment of area) of the body of the body.\n     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\n     * @method setInertia\n     * @param {body} body\n     * @param {number} inertia\n     */\n    Body.setInertia = function(body, inertia) {\n        body.inertia = inertia;\n        body.inverseInertia = 1 / body.inertia;\n    };\n\n    /**\n     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\n     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\n     * They are then automatically translated to world space based on `body.position`.\n     *\n     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\n     * Vertices must form a convex hull, concave hulls are not supported.\n     *\n     * @method setVertices\n     * @param {body} body\n     * @param {vector[]} vertices\n     */\n    Body.setVertices = function(body, vertices) {\n        // change vertices\n        if (vertices[0].body === body) {\n            body.vertices = vertices;\n        } else {\n            body.vertices = Vertices.create(vertices, body);\n        }\n\n        // update properties\n        body.axes = Axes.fromVertices(body.vertices);\n        body.area = Vertices.area(body.vertices);\n        Body.setMass(body, body.density * body.area);\n\n        // orient vertices around the centre of mass at origin (0, 0)\n        var centre = Vertices.centre(body.vertices);\n        Vertices.translate(body.vertices, centre, -1);\n\n        // update inertia while vertices are at origin (0, 0)\n        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));\n\n        // update geometry\n        Vertices.translate(body.vertices, body.position);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n    };\n\n    /**\n     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.\n     * @method setPosition\n     * @param {body} body\n     * @param {vector} position\n     */\n    Body.setPosition = function(body, position) {\n        var delta = Vector.sub(position, body.position);\n\n        body.position.x = position.x;\n        body.position.y = position.y;\n        body.positionPrev.x += delta.x;\n        body.positionPrev.y += delta.y;\n\n        Vertices.translate(body.vertices, delta);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n    };\n\n    /**\n     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.\n     * @method setAngle\n     * @param {body} body\n     * @param {number} angle\n     */\n    Body.setAngle = function(body, angle) {\n        var delta = angle - body.angle;\n\n        body.angle = angle;\n        body.anglePrev += delta;\n\n        Vertices.rotate(body.vertices, delta, body.position);\n        Axes.rotate(body.axes, delta);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n    };\n\n    /**\n     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\n     * @method setVelocity\n     * @param {body} body\n     * @param {vector} velocity\n     */\n    Body.setVelocity = function(body, velocity) {\n        body.positionPrev.x = body.position.x - velocity.x;\n        body.positionPrev.y = body.position.y - velocity.y;\n        body.velocity.x = velocity.x;\n        body.velocity.y = velocity.y;\n        body.speed = Vector.magnitude(body.velocity);\n    };\n\n    /**\n     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\n     * @method setAngularVelocity\n     * @param {body} body\n     * @param {number} velocity\n     */\n    Body.setAngularVelocity = function(body, velocity) {\n        body.anglePrev = body.angle - velocity;\n        body.angularVelocity = velocity;\n        body.angularSpeed = Math.abs(body.angularVelocity);\n    };\n\n    /**\n     * Moves a body by a given vector relative to its current position, without imparting any velocity.\n     * @method translate\n     * @param {body} body\n     * @param {vector} translation\n     */\n    Body.translate = function(body, translation) {\n        Body.setPosition(body, Vector.add(body.position, translation));\n    };\n\n    /**\n     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.\n     * @method rotate\n     * @param {body} body\n     * @param {number} rotation\n     */\n    Body.rotate = function(body, rotation) {\n        Body.setAngle(body, body.angle + rotation);\n    };\n\n    /**\n     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\n     * @method scale\n     * @param {body} body\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} [point]\n     */\n    Body.scale = function(body, scaleX, scaleY, point) {\n        // scale vertices\n        Vertices.scale(body.vertices, scaleX, scaleY, point);\n\n        // update properties\n        body.axes = Axes.fromVertices(body.vertices);\n        body.area = Vertices.area(body.vertices);\n        Body.setMass(body, body.density * body.area);\n\n        // update inertia (requires vertices to be at origin)\n        Vertices.translate(body.vertices, { x: -body.position.x, y: -body.position.y });\n        Body.setInertia(body, Vertices.inertia(body.vertices, body.mass));\n        Vertices.translate(body.vertices, { x: body.position.x, y: body.position.y });\n\n        // update bounds\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n    };\n\n    /**\n     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.\n     * @method update\n     * @param {body} body\n     * @param {number} deltaTime\n     * @param {number} timeScale\n     * @param {number} correction\n     */\n    Body.update = function(body, deltaTime, timeScale, correction) {\n        var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);\n\n        // from the previous step\n        var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,\n            velocityPrevX = body.position.x - body.positionPrev.x,\n            velocityPrevY = body.position.y - body.positionPrev.y;\n\n        // update velocity with verlet integration\n        body.velocity.x = (velocityPrevX * frictionAir * correction) + (body.force.x / body.mass) * deltaTimeSquared;\n        body.velocity.y = (velocityPrevY * frictionAir * correction) + (body.force.y / body.mass) * deltaTimeSquared;\n\n        body.positionPrev.x = body.position.x;\n        body.positionPrev.y = body.position.y;\n        body.position.x += body.velocity.x;\n        body.position.y += body.velocity.y;\n\n        // update angular velocity with verlet integration\n        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;\n        body.anglePrev = body.angle;\n        body.angle += body.angularVelocity;\n\n        // track speed and acceleration\n        body.speed = Vector.magnitude(body.velocity);\n        body.angularSpeed = Math.abs(body.angularVelocity);\n\n        // transform the body geometry\n        Vertices.translate(body.vertices, body.velocity);\n        if (body.angularVelocity !== 0) {\n            Vertices.rotate(body.vertices, body.angularVelocity, body.position);\n            Axes.rotate(body.axes, body.angularVelocity);\n        }\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n    };\n\n    /**\n     * Applies a force to a body from a given world-space position, including resulting torque.\n     * @method applyForce\n     * @param {body} body\n     * @param {vector} position\n     * @param {vector} force\n     */\n    Body.applyForce = function(body, position, force) {\n        body.force.x += force.x;\n        body.force.y += force.y;\n        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };\n        body.torque += (offset.x * force.y - offset.y * force.x) * body.inverseInertia;\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"body\"\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Body\"\n     */\n\n    /**\n     * A `Number` specifying the angle of the body, in radians.\n     *\n     * @property angle\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * An array of `Vector` objects that specify the convex hull of the rigid body.\n     * These should be provided about the origin `(0, 0)`. E.g.\n     *\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n     *\n     * When passed via `Body.create`, the verticies are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).\n     * The `Vector` objects are also augmented with additional properties required for efficient collision detection.\n     *\n     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).\n     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.\n     *\n     * @property vertices\n     * @type vector[]\n     */\n\n    /**\n     * A `Vector` that specifies the current world-space position of the body.\n     *\n     * @property position\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.\n     *\n     * @property force\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.\n     *\n     * @property torque\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).\n     *\n     * @readOnly\n     * @property speed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).\n     *\n     * @readOnly\n     * @property angularSpeed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only.\n     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).\n     *\n     * @readOnly\n     * @property velocity\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only.\n     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).\n     *\n     * @readOnly\n     * @property angularVelocity\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\n     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.\n     *\n     * @property isStatic\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\n     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.\n     *\n     * @property isSleeping\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.\n     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.\n     *\n     * @readOnly\n     * @property motion\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\n     *\n     * @property sleepThreshold\n     * @type number\n     * @default 60\n     */\n\n    /**\n     * A `Number` that defines the density of the body, that is its mass per unit area.\n     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.\n     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).\n     *\n     * @property density\n     * @type number\n     * @default 0.001\n     */\n\n    /**\n     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.\n     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).\n     *\n     * @property mass\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the inverse mass of the body (`1 / mass`).\n     * If you modify this value, you must also modify the `body.mass` property.\n     *\n     * @property inverseMass\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.\n     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.\n     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).\n     *\n     * @property inertia\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\n     * If you modify this value, you must also modify the `body.inertia` property.\n     *\n     * @property inverseInertia\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur.\n     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\n     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\n     *\n     *     Math.max(bodyA.restitution, bodyB.restitution)\n     *\n     * @property restitution\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means that the body may slide indefinitely.\n     * A value of `1` means the body may come to a stop almost instantly after a force is applied.\n     *\n     * The effects of the value may be non-linear.\n     * High values may be unstable depending on the body.\n     * The engine uses a Coulomb friction model including static and kinetic friction.\n     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\n     *\n     *     Math.min(bodyA.friction, bodyB.friction)\n     *\n     * @property friction\n     * @type number\n     * @default 0.1\n     */\n\n    /**\n     * A `Number` that defines the air friction of the body (air resistance).\n     * A value of `0` means the body will never slow as it moves through space.\n     * The higher the value, the faster a body slows when moving through space.\n     * The effects of the value are non-linear.\n     *\n     * @property frictionAir\n     * @type number\n     * @default 0.01\n     */\n\n    /**\n     * An `Object` that specifies the collision filtering properties of this body.\n     *\n     * Collisions between two bodies will obey the following rules:\n     * - If the two bodies have the same non-zero value of `collisionFilter.group`,\n     *   they will always collide if the value is positive, and they will never collide\n     *   if the value is negative.\n     * - If the two bodies have different values of `collisionFilter.group` or if one\n     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\n     *\n     * Each body belongs to a collision category, given by `collisionFilter.category`. This\n     * value is used as a bit field and the category should have only one bit set, meaning that\n     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\n     * different collision categories available.\n     *\n     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\n     * the categories it collides with (the value is the bitwise AND value of all these categories).\n     *\n     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\n     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\n     * are both true.\n     *\n     * @property collisionFilter\n     * @type object\n     */\n\n    /**\n     * An Integer `Number`, that specifies the collision group this body belongs to.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.group\n     * @type object\n     * @default 0\n     */\n\n    /**\n     * A bit field that specifies the collision category this body belongs to.\n     * The category value should have only one bit set, for example `0x0001`.\n     * This means there are up to 32 unique collision categories available.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.category\n     * @type object\n     * @default 1\n     */\n\n    /**\n     * A bit mask that specifies the collision categories this body may collide with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.mask\n     * @type object\n     * @default -1\n     */\n\n    /**\n     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.\n     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.\n     * The default should generally suffice, although very large bodies may require larger values for stable stacking.\n     *\n     * @property slop\n     * @type number\n     * @default 0.05\n     */\n\n    /**\n     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.\n     *\n     * @property timeScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */\n\n    /**\n     * A flag that indicates if the body should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * An `Object` that defines the sprite properties to use when rendering, if any.\n     *\n     * @property render.sprite\n     * @type object\n     */\n\n    /**\n     * An `String` that defines the path to the image to use as the sprite texture, if any.\n     *\n     * @property render.sprite.texture\n     * @type string\n     */\n\n    /**\n     * A `Number` that defines the scaling in the x-axis for the sprite, if any.\n     *\n     * @property render.sprite.xScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that defines the scaling in the y-axis for the sprite, if any.\n     *\n     * @property render.sprite.yScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 1.5\n     */\n\n    /**\n     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.fillStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * An array of unique axis vectors (edge normals) used for collision detection.\n     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.\n     * They are constantly updated by `Body.update` during the simulation.\n     *\n     * @property axes\n     * @type vector[]\n     */\n\n    /**\n     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.\n     *\n     * @property area\n     * @type string\n     * @default\n     */\n\n    /**\n     * A `Bounds` object that defines the AABB region for the body.\n     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.\n     *\n     * @property bounds\n     * @type bounds\n     */\n\n})();\n\n\n;   // End src/body/Body.js\n\n\n// Begin src/body/Composite.js\n\n/**\n* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.\n* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.\n* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.\n* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.\n*\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class Composite\n*/\n\nvar Composite = {};\n\n(function() {\n\n    /**\n     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} [options]\n     * @return {composite} A new composite\n     */\n    Composite.create = function(options) {\n        return Common.extend({\n            id: Common.nextId(),\n            type: 'composite',\n            parent: null,\n            isModified: false,\n            bodies: [],\n            constraints: [],\n            composites: [],\n            label: 'Composite'\n        }, options);\n    };\n\n    /**\n     * Sets the composite's `isModified` flag.\n     * If `updateParents` is true, all parents will be set (default: false).\n     * If `updateChildren` is true, all children will be set (default: false).\n     * @method setModified\n     * @param {composite} composite\n     * @param {boolean} isModified\n     * @param {boolean} [updateParents=false]\n     * @param {boolean} [updateChildren=false]\n     */\n    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {\n        composite.isModified = isModified;\n\n        if (updateParents && composite.parent) {\n            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\n        }\n\n        if (updateChildren) {\n            for(var i = 0; i < composite.composites.length; i++) {\n                var childComposite = composite.composites[i];\n                Composite.setModified(childComposite, isModified, updateParents, updateChildren);\n            }\n        }\n    };\n\n    /**\n     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.\n     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\n     * @method add\n     * @param {composite} composite\n     * @param {} object\n     * @return {composite} The original composite with the objects added\n     */\n    Composite.add = function(composite, object) {\n        var objects = [].concat(object);\n\n        Events.trigger(composite, 'beforeAdd', { object: object });\n\n        for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n\n            switch (obj.type) {\n\n            case 'body':\n                Composite.addBody(composite, obj);\n                break;\n            case 'constraint':\n                Composite.addConstraint(composite, obj);\n                break;\n            case 'composite':\n                Composite.addComposite(composite, obj);\n                break;\n            case 'mouseConstraint':\n                Composite.addConstraint(composite, obj.constraint);\n                break;\n\n            }\n        }\n\n        Events.trigger(composite, 'afterAdd', { object: object });\n\n        return composite;\n    };\n\n    /**\n     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\n     * Optionally searching its children recursively.\n     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\n     * @method remove\n     * @param {composite} composite\n     * @param {} object\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the objects removed\n     */\n    Composite.remove = function(composite, object, deep) {\n        var objects = [].concat(object);\n\n        Events.trigger(composite, 'beforeRemove', { object: object });\n\n        for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n\n            switch (obj.type) {\n\n            case 'body':\n                Composite.removeBody(composite, obj, deep);\n                break;\n            case 'constraint':\n                Composite.removeConstraint(composite, obj, deep);\n                break;\n            case 'composite':\n                Composite.removeComposite(composite, obj, deep);\n                break;\n            case 'mouseConstraint':\n                Composite.removeConstraint(composite, obj.constraint);\n                break;\n\n            }\n        }\n\n        Events.trigger(composite, 'afterRemove', { object: object });\n\n        return composite;\n    };\n\n    /**\n     * Adds a composite to the given composite\n     * @private\n     * @method addComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @return {composite} The original compositeA with the objects from compositeB added\n     */\n    Composite.addComposite = function(compositeA, compositeB) {\n        compositeA.composites.push(compositeB);\n        compositeB.parent = compositeA;\n        Composite.setModified(compositeA, true, true, false);\n        return compositeA;\n    };\n\n    /**\n     * Removes a composite from the given composite, and optionally searching its children recursively\n     * @private\n     * @method removeComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @param {boolean} [deep=false]\n     * @return {composite} The original compositeA with the composite removed\n     */\n    Composite.removeComposite = function(compositeA, compositeB, deep) {\n        var position = Common.indexOf(compositeA.composites, compositeB);\n        if (position !== -1) {\n            Composite.removeCompositeAt(compositeA, position);\n            Composite.setModified(compositeA, true, true, false);\n        }\n\n        if (deep) {\n            for (var i = 0; i < compositeA.composites.length; i++){\n                Composite.removeComposite(compositeA.composites[i], compositeB, true);\n            }\n        }\n\n        return compositeA;\n    };\n\n    /**\n     * Removes a composite from the given composite\n     * @private\n     * @method removeCompositeAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the composite removed\n     */\n    Composite.removeCompositeAt = function(composite, position) {\n        composite.composites.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Adds a body to the given composite\n     * @private\n     * @method addBody\n     * @param {composite} composite\n     * @param {body} body\n     * @return {composite} The original composite with the body added\n     */\n    Composite.addBody = function(composite, body) {\n        composite.bodies.push(body);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite, and optionally searching its children recursively\n     * @private\n     * @method removeBody\n     * @param {composite} composite\n     * @param {body} body\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the body removed\n     */\n    Composite.removeBody = function(composite, body, deep) {\n        var position = Common.indexOf(composite.bodies, body);\n        if (position !== -1) {\n            Composite.removeBodyAt(composite, position);\n            Composite.setModified(composite, true, true, false);\n        }\n\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.removeBody(composite.composites[i], body, true);\n            }\n        }\n\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite\n     * @private\n     * @method removeBodyAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the body removed\n     */\n    Composite.removeBodyAt = function(composite, position) {\n        composite.bodies.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Adds a constraint to the given composite\n     * @private\n     * @method addConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @return {composite} The original composite with the constraint added\n     */\n    Composite.addConstraint = function(composite, constraint) {\n        composite.constraints.push(constraint);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes a constraint from the given composite, and optionally searching its children recursively\n     * @private\n     * @method removeConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the constraint removed\n     */\n    Composite.removeConstraint = function(composite, constraint, deep) {\n        var position = Common.indexOf(composite.constraints, constraint);\n        if (position !== -1) {\n            Composite.removeConstraintAt(composite, position);\n        }\n\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.removeConstraint(composite.composites[i], constraint, true);\n            }\n        }\n\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite\n     * @private\n     * @method removeConstraintAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the constraint removed\n     */\n    Composite.removeConstraintAt = function(composite, position) {\n        composite.constraints.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes all bodies, constraints and composites from the given composite\n     * Optionally clearing its children recursively\n     * @method clear\n     * @param {world} world\n     * @param {boolean} keepStatic\n     * @param {boolean} [deep=false]\n     */\n    Composite.clear = function(composite, keepStatic, deep) {\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.clear(composite.composites[i], keepStatic, true);\n            }\n        }\n\n        if (keepStatic) {\n            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });\n        } else {\n            composite.bodies.length = 0;\n        }\n\n        composite.constraints.length = 0;\n        composite.composites.length = 0;\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Returns all bodies in the given composite, including all bodies in its children, recursively\n     * @method allBodies\n     * @param {composite} composite\n     * @return {body[]} All the bodies\n     */\n    Composite.allBodies = function(composite) {\n        var bodies = [].concat(composite.bodies);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\n\n        return bodies;\n    };\n\n    /**\n     * Returns all constraints in the given composite, including all constraints in its children, recursively\n     * @method allConstraints\n     * @param {composite} composite\n     * @return {constraint[]} All the constraints\n     */\n    Composite.allConstraints = function(composite) {\n        var constraints = [].concat(composite.constraints);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\n\n        return constraints;\n    };\n\n    /**\n     * Returns all composites in the given composite, including all composites in its children, recursively\n     * @method allComposites\n     * @param {composite} composite\n     * @return {composite[]} All the composites\n     */\n    Composite.allComposites = function(composite) {\n        var composites = [].concat(composite.composites);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            composites = composites.concat(Composite.allComposites(composite.composites[i]));\n\n        return composites;\n    };\n\n    /**\n     * Searches the composite recursively for an object matching the type and id supplied, null if not found\n     * @method get\n     * @param {composite} composite\n     * @param {number} id\n     * @param {string} type\n     * @return {object} The requested object, if found\n     */\n    Composite.get = function(composite, id, type) {\n        var objects,\n            object;\n\n        switch (type) {\n        case 'body':\n            objects = Composite.allBodies(composite);\n            break;\n        case 'constraint':\n            objects = Composite.allConstraints(composite);\n            break;\n        case 'composite':\n            objects = Composite.allComposites(composite).concat(composite);\n            break;\n        }\n\n        if (!objects)\n            return null;\n\n        object = objects.filter(function(object) {\n            return object.id.toString() === id.toString();\n        });\n\n        return object.length === 0 ? null : object[0];\n    };\n\n    /**\n     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add)\n     * @method move\n     * @param {compositeA} compositeA\n     * @param {object[]} objects\n     * @param {compositeB} compositeB\n     * @return {composite} Returns compositeA\n     */\n    Composite.move = function(compositeA, objects, compositeB) {\n        Composite.remove(compositeA, objects);\n        Composite.add(compositeB, objects);\n        return compositeA;\n    };\n\n    /**\n     * Assigns new ids for all objects in the composite, recursively\n     * @method rebase\n     * @param {composite} composite\n     * @return {composite} Returns composite\n     */\n    Composite.rebase = function(composite) {\n        var objects = Composite.allBodies(composite)\n                        .concat(Composite.allConstraints(composite))\n                        .concat(Composite.allComposites(composite));\n\n        for (var i = 0; i < objects.length; i++) {\n            objects[i].id = Common.nextId();\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Translates all children in the composite by a given vector relative to their current positions,\n     * without imparting any velocity.\n     * @method translate\n     * @param {composite} composite\n     * @param {vector} translation\n     * @param {bool} [recursive=true]\n     */\n    Composite.translate = function(composite, translation, recursive) {\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            Body.translate(bodies[i], translation);\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\n     * @method rotate\n     * @param {composite} composite\n     * @param {number} rotation\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */\n    Composite.rotate = function(composite, rotation, point, recursive) {\n        var cos = Math.cos(rotation),\n            sin = Math.sin(rotation),\n            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n\n            Body.setPosition(body, {\n                x: point.x + (dx * cos - dy * sin),\n                y: point.y + (dx * sin + dy * cos)\n            });\n\n            Body.rotate(body, rotation);\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\n     * @method scale\n     * @param {composite} composite\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */\n    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n\n            Body.setPosition(body, {\n                x: point.x + dx * scaleX,\n                y: point.y + dy * scaleY\n            });\n\n            Body.scale(body, scaleX, scaleY);\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when a call to `Composite.add` is made, before objects have been added.\n    *\n    * @event beforeAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.add` is made, after objects have been added.\n    *\n    * @event afterAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.remove` is made, before objects have been removed.\n    *\n    * @event beforeRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.remove` is made, after objects have been removed.\n    *\n    * @event afterRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"composite\"\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage composites.\n     *\n     * @property label\n     * @type string\n     * @default \"Composite\"\n     */\n\n    /**\n     * A flag that specifies whether the composite has been modified during the current step.\n     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.\n     * If you need to change it manually, you should use the `Composite.setModified` method.\n     *\n     * @property isModified\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\n     *\n     * @property parent\n     * @type composite\n     * @default null\n     */\n\n    /**\n     * An array of `Body` that are _direct_ children of this composite.\n     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\n     *\n     * @property bodies\n     * @type body[]\n     * @default []\n     */\n\n    /**\n     * An array of `Constraint` that are _direct_ children of this composite.\n     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\n     *\n     * @property constraints\n     * @type constraint[]\n     * @default []\n     */\n\n    /**\n     * An array of `Composite` that are _direct_ children of this composite.\n     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\n     *\n     * @property composites\n     * @type composite[]\n     * @default []\n     */\n\n})();\n\n;   // End src/body/Composite.js\n\n\n// Begin src/body/World.js\n\n/**\n* The `Matter.World` module contains methods for creating and manipulating the world composite.\n* A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.\n* A `Matter.World` has a few additional properties including `gravity` and `bounds`.\n* It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.\n* There are also a few methods here that alias those in `Matter.Composite` for easier readability.\n*\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class World\n*/\n\nvar World = {};\n\n(function() {\n\n    /**\n     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @constructor\n     * @param {} options\n     * @return {world} A new world\n     */\n    World.create = function(options) {\n        var composite = Composite.create();\n\n        var defaults = {\n            label: 'World',\n            gravity: { x: 0, y: 1 },\n            bounds: {\n                min: { x: 0, y: 0 },\n                max: { x: 800, y: 600 }\n            }\n        };\n\n        return Common.extend(composite, defaults, options);\n    };\n\n    // World is a Composite body\n    // see src/module/Outro.js for these aliases:\n\n    /**\n     * An alias for Composite.clear since World is also a Composite\n     * @method clear\n     * @param {world} world\n     * @param {boolean} keepStatic\n     */\n\n    /**\n     * An alias for Composite.add since World is also a Composite\n     * @method addComposite\n     * @param {world} world\n     * @param {composite} composite\n     * @return {world} The original world with the objects from composite added\n     */\n\n     /**\n      * An alias for Composite.addBody since World is also a Composite\n      * @method addBody\n      * @param {world} world\n      * @param {body} body\n      * @return {world} The original world with the body added\n      */\n\n     /**\n      * An alias for Composite.addConstraint since World is also a Composite\n      * @method addConstraint\n      * @param {world} world\n      * @param {constraint} constraint\n      * @return {world} The original world with the constraint added\n      */\n\n})();\n\n;   // End src/body/World.js\n\n\n// Begin src/collision/Contact.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Contact\n*/\n\nvar Contact = {};\n\n(function() {\n\n    /**\n     * Description\n     * @method create\n     * @param {vertex} vertex\n     * @return {contact} A new contact\n     */\n    Contact.create = function(vertex) {\n        return {\n            id: Contact.id(vertex),\n            vertex: vertex,\n            normalImpulse: 0,\n            tangentImpulse: 0\n        };\n    };\n\n    /**\n     * Description\n     * @method id\n     * @param {vertex} vertex\n     * @return {string} Unique contactID\n     */\n    Contact.id = function(vertex) {\n        return vertex.body.id + '_' + vertex.index;\n    };\n\n})();\n\n\n;   // End src/collision/Contact.js\n\n\n// Begin src/collision/Detector.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Detector\n*/\n\n// TODO: speculative contacts\n\nvar Detector = {};\n\n(function() {\n\n    /**\n     * Description\n     * @method collisions\n     * @param {pair[]} broadphasePairs\n     * @param {engine} engine\n     * @return {array} collisions\n     */\n    Detector.collisions = function(broadphasePairs, engine) {\n        var collisions = [],\n            metrics = engine.metrics,\n            pairsTable = engine.pairs.table;\n\n        for (var i = 0; i < broadphasePairs.length; i++) {\n            var bodyA = broadphasePairs[i][0],\n                bodyB = broadphasePairs[i][1];\n\n            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))\n                continue;\n\n            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))\n                continue;\n\n            metrics.midphaseTests += 1;\n\n            // mid phase\n            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {\n\n                // find a previous collision we could reuse\n                var pairId = Pair.id(bodyA, bodyB),\n                    pair = pairsTable[pairId],\n                    previousCollision;\n\n                if (pair && pair.isActive) {\n                    previousCollision = pair.collision;\n                } else {\n                    previousCollision = null;\n                }\n\n                // narrow phase\n                var collision = SAT.collides(bodyA, bodyB, previousCollision);\n\n                metrics.narrowphaseTests += 1;\n\n                if (collision.reused)\n                    metrics.narrowReuseCount += 1;\n\n                if (collision.collided) {\n                    collisions.push(collision);\n                    metrics.narrowDetections += 1;\n                }\n            }\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Description\n     * @method bruteForce\n     * @param {body[]} bodies\n     * @param {engine} engine\n     * @return {array} collisions\n     */\n    Detector.bruteForce = function(bodies, engine) {\n        var collisions = [],\n            metrics = engine.metrics,\n            pairsTable = engine.pairs.table;\n\n        for (var i = 0; i < bodies.length; i++) {\n            for (var j = i + 1; j < bodies.length; j++) {\n                var bodyA = bodies[i],\n                    bodyB = bodies[j];\n\n                // NOTE: could share a function for the below, but may drop performance?\n\n                if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))\n                    continue;\n\n                if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))\n                    continue;\n\n                metrics.midphaseTests += 1;\n\n                // mid phase\n                if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {\n\n                    // find a previous collision we could reuse\n                    var pairId = Pair.id(bodyA, bodyB),\n                        pair = pairsTable[pairId],\n                        previousCollision;\n\n                    if (pair && pair.isActive) {\n                        previousCollision = pair.collision;\n                    } else {\n                        previousCollision = null;\n                    }\n\n                    // narrow phase\n                    var collision = SAT.collides(bodyA, bodyB, previousCollision);\n\n                    metrics.narrowphaseTests += 1;\n\n                    if (collision.reused)\n                        metrics.narrowReuseCount += 1;\n\n                    if (collision.collided) {\n                        collisions.push(collision);\n                        metrics.narrowDetections += 1;\n                    }\n                }\n            }\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\n     * See `body.collisionFilter` for more information.\n     * @method canCollide\n     * @param {} filterA\n     * @param {} filterB\n     * @return {bool} `true` if collision can occur\n     */\n    Detector.canCollide = function(filterA, filterB) {\n        if (filterA.group === filterB.group && filterA.group !== 0)\n            return filterA.group > 0;\n\n        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\n    };\n\n})();\n\n\n;   // End src/collision/Detector.js\n\n\n// Begin src/collision/Grid.js\n\n/**\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class Grid\n*/\n\nvar Grid = {};\n\n(function() {\n\n    /**\n     * Description\n     * @method create\n     * @param {} options\n     * @return {grid} A new grid\n     */\n    Grid.create = function(options) {\n        var defaults = {\n            controller: Grid,\n            detector: Detector.collisions,\n            buckets: {},\n            pairs: {},\n            pairsList: [],\n            bucketWidth: 48,\n            bucketHeight: 48\n        };\n\n        return Common.extend(defaults, options);\n    };\n\n    /**\n     * Description\n     * @method update\n     * @param {grid} grid\n     * @param {body[]} bodies\n     * @param {engine} engine\n     * @param {boolean} forceUpdate\n     */\n    Grid.update = function(grid, bodies, engine, forceUpdate) {\n        var i, col, row,\n            world = engine.world,\n            buckets = grid.buckets,\n            bucket,\n            bucketId,\n            metrics = engine.metrics,\n            gridChanged = false;\n\n        metrics.broadphaseTests = 0;\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isSleeping && !forceUpdate)\n                continue;\n\n            // don't update out of world bodies\n            if (body.bounds.max.x < 0 || body.bounds.min.x > world.bounds.width\n                || body.bounds.max.y < 0 || body.bounds.min.y > world.bounds.height)\n                continue;\n\n            var newRegion = _getRegion(grid, body);\n\n            // if the body has changed grid region\n            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\n\n                metrics.broadphaseTests += 1;\n\n                if (!body.region || forceUpdate)\n                    body.region = newRegion;\n\n                var union = _regionUnion(newRegion, body.region);\n\n                // update grid buckets affected by region change\n                // iterate over the union of both regions\n                for (col = union.startCol; col <= union.endCol; col++) {\n                    for (row = union.startRow; row <= union.endRow; row++) {\n                        bucketId = _getBucketId(col, row);\n                        bucket = buckets[bucketId];\n\n                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol\n                                                && row >= newRegion.startRow && row <= newRegion.endRow);\n\n                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol\n                                                && row >= body.region.startRow && row <= body.region.endRow);\n\n                        // remove from old region buckets\n                        if (!isInsideNewRegion && isInsideOldRegion) {\n                            if (isInsideOldRegion) {\n                                if (bucket)\n                                    _bucketRemoveBody(grid, bucket, body);\n                            }\n                        }\n\n                        // add to new region buckets\n                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {\n                            if (!bucket)\n                                bucket = _createBucket(buckets, bucketId);\n                            _bucketAddBody(grid, bucket, body);\n                        }\n                    }\n                }\n\n                // set the new region\n                body.region = newRegion;\n\n                // flag changes so we can update pairs\n                gridChanged = true;\n            }\n        }\n\n        // update pairs list only if pairs changed (i.e. a body changed region)\n        if (gridChanged)\n            grid.pairsList = _createActivePairsList(grid);\n    };\n\n    /**\n     * Description\n     * @method clear\n     * @param {grid} grid\n     */\n    Grid.clear = function(grid) {\n        grid.buckets = {};\n        grid.pairs = {};\n        grid.pairsList = [];\n    };\n\n    /**\n     * Description\n     * @method _regionUnion\n     * @private\n     * @param {} regionA\n     * @param {} regionB\n     * @return CallExpression\n     */\n    var _regionUnion = function(regionA, regionB) {\n        var startCol = Math.min(regionA.startCol, regionB.startCol),\n            endCol = Math.max(regionA.endCol, regionB.endCol),\n            startRow = Math.min(regionA.startRow, regionB.startRow),\n            endRow = Math.max(regionA.endRow, regionB.endRow);\n\n        return _createRegion(startCol, endCol, startRow, endRow);\n    };\n\n    /**\n     * Description\n     * @method _getRegion\n     * @private\n     * @param {} grid\n     * @param {} body\n     * @return CallExpression\n     */\n    var _getRegion = function(grid, body) {\n        var bounds = body.bounds,\n            startCol = Math.floor(bounds.min.x / grid.bucketWidth),\n            endCol = Math.floor(bounds.max.x / grid.bucketWidth),\n            startRow = Math.floor(bounds.min.y / grid.bucketHeight),\n            endRow = Math.floor(bounds.max.y / grid.bucketHeight);\n\n        return _createRegion(startCol, endCol, startRow, endRow);\n    };\n\n    /**\n     * Description\n     * @method _createRegion\n     * @private\n     * @param {} startCol\n     * @param {} endCol\n     * @param {} startRow\n     * @param {} endRow\n     * @return ObjectExpression\n     */\n    var _createRegion = function(startCol, endCol, startRow, endRow) {\n        return {\n            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,\n            startCol: startCol,\n            endCol: endCol,\n            startRow: startRow,\n            endRow: endRow\n        };\n    };\n\n    /**\n     * Description\n     * @method _getBucketId\n     * @private\n     * @param {} column\n     * @param {} row\n     * @return BinaryExpression\n     */\n    var _getBucketId = function(column, row) {\n        return column + ',' + row;\n    };\n\n    /**\n     * Description\n     * @method _createBucket\n     * @private\n     * @param {} buckets\n     * @param {} bucketId\n     * @return bucket\n     */\n    var _createBucket = function(buckets, bucketId) {\n        var bucket = buckets[bucketId] = [];\n        return bucket;\n    };\n\n    /**\n     * Description\n     * @method _bucketAddBody\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */\n    var _bucketAddBody = function(grid, bucket, body) {\n        // add new pairs\n        for (var i = 0; i < bucket.length; i++) {\n            var bodyB = bucket[i];\n\n            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))\n                continue;\n\n            // keep track of the number of buckets the pair exists in\n            // important for Grid.update to work\n            var pairId = Pair.id(body, bodyB),\n                pair = grid.pairs[pairId];\n\n            if (pair) {\n                pair[2] += 1;\n            } else {\n                grid.pairs[pairId] = [body, bodyB, 1];\n            }\n        }\n\n        // add to bodies (after pairs, otherwise pairs with self)\n        bucket.push(body);\n    };\n\n    /**\n     * Description\n     * @method _bucketRemoveBody\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */\n    var _bucketRemoveBody = function(grid, bucket, body) {\n        // remove from bucket\n        bucket.splice(Common.indexOf(bucket, body), 1);\n\n        // update pair counts\n        for (var i = 0; i < bucket.length; i++) {\n            // keep track of the number of buckets the pair exists in\n            // important for _createActivePairsList to work\n            var bodyB = bucket[i],\n                pairId = Pair.id(body, bodyB),\n                pair = grid.pairs[pairId];\n\n            if (pair)\n                pair[2] -= 1;\n        }\n    };\n\n    /**\n     * Description\n     * @method _createActivePairsList\n     * @private\n     * @param {} grid\n     * @return pairs\n     */\n    var _createActivePairsList = function(grid) {\n        var pairKeys,\n            pair,\n            pairs = [];\n\n        // grid.pairs is used as a hashmap\n        pairKeys = Common.keys(grid.pairs);\n\n        // iterate over grid.pairs\n        for (var k = 0; k < pairKeys.length; k++) {\n            pair = grid.pairs[pairKeys[k]];\n\n            // if pair exists in at least one bucket\n            // it is a pair that needs further collision testing so push it\n            if (pair[2] > 0) {\n                pairs.push(pair);\n            } else {\n                delete grid.pairs[pairKeys[k]];\n            }\n        }\n\n        return pairs;\n    };\n\n})();\n\n;   // End src/collision/Grid.js\n\n\n// Begin src/collision/Pair.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Pair\n*/\n\nvar Pair = {};\n\n(function() {\n\n    /**\n     * Description\n     * @method create\n     * @param {collision} collision\n     * @return {pair} A new pair\n     */\n    Pair.create = function(collision, timestamp) {\n        var bodyA = collision.bodyA,\n            bodyB = collision.bodyB;\n\n        var pair = {\n            id: Pair.id(bodyA, bodyB),\n            bodyA: bodyA,\n            bodyB: bodyB,\n            contacts: {},\n            activeContacts: [],\n            separation: 0,\n            isActive: true,\n            timeCreated: timestamp,\n            timeUpdated: timestamp,\n            inverseMass: bodyA.inverseMass + bodyB.inverseMass,\n            friction: Math.min(bodyA.friction, bodyB.friction),\n            restitution: Math.max(bodyA.restitution, bodyB.restitution),\n            slop: Math.max(bodyA.slop, bodyB.slop)\n        };\n\n        Pair.update(pair, collision, timestamp);\n\n        return pair;\n    };\n\n    /**\n     * Description\n     * @method update\n     * @param {pair} pair\n     * @param {collision} collision\n     */\n    Pair.update = function(pair, collision, timestamp) {\n        var contacts = pair.contacts,\n            supports = collision.supports,\n            activeContacts = pair.activeContacts;\n\n        pair.collision = collision;\n        pair.inverseMass = collision.bodyA.inverseMass + collision.bodyB.inverseMass;\n        pair.friction = Math.min(collision.bodyA.friction, collision.bodyB.friction);\n        pair.restitution = Math.max(collision.bodyA.restitution, collision.bodyB.restitution);\n        pair.slop = Math.max(collision.bodyA.slop, collision.bodyB.slop);\n        activeContacts.length = 0;\n\n        if (collision.collided) {\n            for (var i = 0; i < supports.length; i++) {\n                var support = supports[i],\n                    contactId = Contact.id(support),\n                    contact = contacts[contactId];\n\n                if (contact) {\n                    activeContacts.push(contact);\n                } else {\n                    activeContacts.push(contacts[contactId] = Contact.create(support));\n                }\n            }\n\n            pair.separation = collision.depth;\n            Pair.setActive(pair, true, timestamp);\n        } else {\n            if (pair.isActive === true)\n                Pair.setActive(pair, false, timestamp);\n        }\n    };\n\n    /**\n     * Description\n     * @method setActive\n     * @param {pair} pair\n     * @param {bool} isActive\n     */\n    Pair.setActive = function(pair, isActive, timestamp) {\n        if (isActive) {\n            pair.isActive = true;\n            pair.timeUpdated = timestamp;\n        } else {\n            pair.isActive = false;\n            pair.activeContacts.length = 0;\n        }\n    };\n\n    /**\n     * Description\n     * @method id\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {string} Unique pairId\n     */\n    Pair.id = function(bodyA, bodyB) {\n        if (bodyA.id < bodyB.id) {\n            return bodyA.id + '_' + bodyB.id;\n        } else {\n            return bodyB.id + '_' + bodyA.id;\n        }\n    };\n\n})();\n\n\n;   // End src/collision/Pair.js\n\n\n// Begin src/collision/Pairs.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Pairs\n*/\n\nvar Pairs = {};\n\n(function() {\n\n    var _pairMaxIdleLife = 1000;\n\n    /**\n     * Creates a new pairs structure\n     * @method create\n     * @param {object} options\n     * @return {pairs} A new pairs structure\n     */\n    Pairs.create = function(options) {\n        return Common.extend({\n            table: {},\n            list: [],\n            collisionStart: [],\n            collisionActive: [],\n            collisionEnd: []\n        }, options);\n    };\n\n    /**\n     * Description\n     * @method update\n     * @param {object} pairs\n     * @param {collision[]} collisions\n     */\n    Pairs.update = function(pairs, collisions, timestamp) {\n        var pairsList = pairs.list,\n            pairsTable = pairs.table,\n            collisionStart = pairs.collisionStart,\n            collisionEnd = pairs.collisionEnd,\n            collisionActive = pairs.collisionActive,\n            activePairIds = [],\n            collision,\n            pairId,\n            pair,\n            i;\n\n        // clear collision state arrays, but maintain old reference\n        collisionStart.length = 0;\n        collisionEnd.length = 0;\n        collisionActive.length = 0;\n\n        for (i = 0; i < collisions.length; i++) {\n            collision = collisions[i];\n\n            if (collision.collided) {\n                pairId = Pair.id(collision.bodyA, collision.bodyB);\n                activePairIds.push(pairId);\n\n                pair = pairsTable[pairId];\n\n                if (pair) {\n                    // pair already exists (but may or may not be active)\n                    if (pair.isActive) {\n                        // pair exists and is active\n                        collisionActive.push(pair);\n                    } else {\n                        // pair exists but was inactive, so a collision has just started again\n                        collisionStart.push(pair);\n                    }\n\n                    // update the pair\n                    Pair.update(pair, collision, timestamp);\n                } else {\n                    // pair did not exist, create a new pair\n                    pair = Pair.create(collision, timestamp);\n                    pairsTable[pairId] = pair;\n\n                    // push the new pair\n                    collisionStart.push(pair);\n                    pairsList.push(pair);\n                }\n            }\n        }\n\n        // deactivate previously active pairs that are now inactive\n        for (i = 0; i < pairsList.length; i++) {\n            pair = pairsList[i];\n            if (pair.isActive && Common.indexOf(activePairIds, pair.id) === -1) {\n                Pair.setActive(pair, false, timestamp);\n                collisionEnd.push(pair);\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @method removeOld\n     * @param {object} pairs\n     */\n    Pairs.removeOld = function(pairs, timestamp) {\n        var pairsList = pairs.list,\n            pairsTable = pairs.table,\n            indexesToRemove = [],\n            pair,\n            collision,\n            pairIndex,\n            i;\n\n        for (i = 0; i < pairsList.length; i++) {\n            pair = pairsList[i];\n            collision = pair.collision;\n\n            // never remove sleeping pairs\n            if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {\n                pair.timeUpdated = timestamp;\n                continue;\n            }\n\n            // if pair is inactive for too long, mark it to be removed\n            if (timestamp - pair.timeUpdated > _pairMaxIdleLife) {\n                indexesToRemove.push(i);\n            }\n        }\n\n        // remove marked pairs\n        for (i = 0; i < indexesToRemove.length; i++) {\n            pairIndex = indexesToRemove[i] - i;\n            pair = pairsList[pairIndex];\n            delete pairsTable[pair.id];\n            pairsList.splice(pairIndex, 1);\n        }\n    };\n\n    /**\n     * Clears the given pairs structure\n     * @method create\n     * @param {object} options\n     * @param {pairs} pairs\n     */\n    Pairs.clear = function(pairs) {\n        pairs.table = {};\n        pairs.list.length = 0;\n        pairs.collisionStart.length = 0;\n        pairs.collisionActive.length = 0;\n        pairs.collisionEnd.length = 0;\n        return pairs;\n    };\n\n})();\n\n;   // End src/collision/Pairs.js\n\n\n// Begin src/collision/Query.js\n\n/**\n* The `Matter.Query` module contains methods for performing collision queries.\n*\n* @class Query\n*/\n\nvar Query = {};\n\n(function() {\n\n    /**\n     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\n     * @method ray\n     * @param {body[]} bodies\n     * @param {vector} startPoint\n     * @param {vector} endPoint\n     * @param {number} [rayWidth]\n     * @return {object[]} Collisions\n     */\n    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {\n        rayWidth = rayWidth || Number.MIN_VALUE;\n\n        var rayAngle = Vector.angle(startPoint, endPoint),\n            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),\n            rayX = (endPoint.x + startPoint.x) * 0.5,\n            rayY = (endPoint.y + startPoint.y) * 0.5,\n            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),\n            collisions = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var bodyA = bodies[i];\n\n            if (Bounds.overlaps(bodyA.bounds, ray.bounds)) {\n                var collision = SAT.collides(bodyA, ray);\n                if (collision.collided) {\n                    collision.body = collision.bodyA = collision.bodyB = bodyA;\n                    collisions.push(collision);\n                }\n            }\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\n     * @method region\n     * @param {body[]} bodies\n     * @param {bounds} bounds\n     * @param {bool} [outside=false]\n     * @return {body[]} The bodies matching the query\n     */\n    Query.region = function(bodies, bounds, outside) {\n        var result = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                overlaps = Bounds.overlaps(body.bounds, bounds);\n            if ((overlaps && !outside) || (!overlaps && outside))\n                result.push(body);\n        }\n\n        return result;\n    };\n\n})();\n\n;   // End src/collision/Query.js\n\n\n// Begin src/collision/Resolver.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Resolver\n*/\n\nvar Resolver = {};\n\n(function() {\n\n    var _restingThresh = 4,\n        _positionDampen = 0.2,\n        _positionWarming = 0.6;\n\n    /**\n     * Description\n     * @method solvePosition\n     * @param {pair[]} pairs\n     * @param {number} timeScale\n     */\n    Resolver.solvePosition = function(pairs, timeScale) {\n        var i,\n            pair,\n            collision,\n            bodyA,\n            bodyB,\n            vertex,\n            vertexCorrected,\n            normal,\n            bodyBtoA;\n\n        // find impulses required to resolve penetration\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n            bodyA = collision.bodyA;\n            bodyB = collision.bodyB;\n            vertex = collision.supports[0];\n            vertexCorrected = collision.supportCorrected;\n            normal = collision.normal;\n\n            // get current separation between body edges involved in collision\n            bodyBtoA = Vector.sub(Vector.add(bodyB.positionImpulse, vertex),\n                                    Vector.add(bodyA.positionImpulse, vertexCorrected));\n\n            pair.separation = Vector.dot(normal, bodyBtoA);\n        }\n\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n            bodyA = collision.bodyA;\n            bodyB = collision.bodyB;\n            normal = collision.normal;\n            positionImpulse = ((pair.separation * _positionDampen) - pair.slop) * timeScale;\n\n            if (bodyA.isStatic || bodyB.isStatic)\n                positionImpulse *= 2;\n\n            if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                bodyA.positionImpulse.x += normal.x * positionImpulse;\n                bodyA.positionImpulse.y += normal.y * positionImpulse;\n            }\n\n            if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                bodyB.positionImpulse.x -= normal.x * positionImpulse;\n                bodyB.positionImpulse.y -= normal.y * positionImpulse;\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @method postSolvePosition\n     * @param {body[]} bodies\n     */\n    Resolver.postSolvePosition = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {\n                // move the body without changing velocity\n                body.position.x += body.positionImpulse.x;\n                body.position.y += body.positionImpulse.y;\n                body.positionPrev.x += body.positionImpulse.x;\n                body.positionPrev.y += body.positionImpulse.y;\n\n                // update body geometry\n                Vertices.translate(body.vertices, body.positionImpulse);\n                Bounds.update(body.bounds, body.vertices, body.velocity);\n\n                // dampen accumulator to warm the next step\n                body.positionImpulse.x *= _positionWarming;\n                body.positionImpulse.y *= _positionWarming;\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @method preSolveVelocity\n     * @param {pair[]} pairs\n     */\n    Resolver.preSolveVelocity = function(pairs) {\n        var impulse = {},\n            i,\n            j,\n            pair,\n            contacts,\n            collision,\n            bodyA,\n            bodyB,\n            normal,\n            tangent,\n            contact,\n            contactVertex,\n            normalImpulse,\n            tangentImpulse,\n            offset;\n\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            contacts = pair.activeContacts;\n            collision = pair.collision;\n            bodyA = collision.bodyA;\n            bodyB = collision.bodyB;\n            normal = collision.normal;\n            tangent = collision.tangent;\n\n            // resolve each contact\n            for (j = 0; j < contacts.length; j++) {\n                contact = contacts[j];\n                contactVertex = contact.vertex;\n                normalImpulse = contact.normalImpulse;\n                tangentImpulse = contact.tangentImpulse;\n\n                // total impulse from contact\n                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\n                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\n\n                // apply impulse from contact\n                if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                    offset = Vector.sub(contactVertex, bodyA.position);\n                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\n                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\n                    bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;\n                }\n\n                if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                    offset = Vector.sub(contactVertex, bodyB.position);\n                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\n                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\n                    bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;\n                }\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @method solveVelocity\n     * @param {pair[]} pairs\n     */\n    Resolver.solveVelocity = function(pairs, timeScale) {\n        var impulse = {},\n            timeScaleSquared = timeScale * timeScale;\n\n        for (var i = 0; i < pairs.length; i++) {\n            var pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            var collision = pair.collision,\n                bodyA = collision.bodyA,\n                bodyB = collision.bodyB,\n                normal = collision.normal,\n                tangent = collision.tangent,\n                contacts = pair.activeContacts,\n                contactShare = 1 / contacts.length;\n\n            // update body velocities\n            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;\n            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;\n            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;\n            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;\n            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\n            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;\n\n            // resolve each contact\n            for (var j = 0; j < contacts.length; j++) {\n                var contact = contacts[j],\n                    contactVertex = contact.vertex,\n                    offsetA = Vector.sub(contactVertex, bodyA.position),\n                    offsetB = Vector.sub(contactVertex, bodyB.position),\n                    velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity)),\n                    velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity)),\n                    relativeVelocity = Vector.sub(velocityPointA, velocityPointB),\n                    normalVelocity = Vector.dot(normal, relativeVelocity);\n\n                var tangentVelocity = Vector.dot(tangent, relativeVelocity),\n                    tangentSpeed = Math.abs(tangentVelocity),\n                    tangentVelocityDirection = Common.sign(tangentVelocity);\n\n                // raw impulses\n                var normalImpulse = (1 + pair.restitution) * normalVelocity,\n                    normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1);\n\n                // coulomb friction\n                var tangentImpulse = tangentVelocity;\n                if (tangentSpeed > normalForce * pair.friction * timeScaleSquared)\n                    tangentImpulse = normalForce * pair.friction * timeScaleSquared * tangentVelocityDirection;\n\n                // modify impulses accounting for mass, inertia and offset\n                var oAcN = Vector.cross(offsetA, normal),\n                    oBcN = Vector.cross(offsetB, normal),\n                    share = contactShare / (pair.inverseMass + bodyA.inverseInertia * oAcN * oAcN  + bodyB.inverseInertia * oBcN * oBcN);\n                normalImpulse *= share;\n                tangentImpulse *= share;\n\n                // handle high velocity and resting collisions separately\n                if (normalVelocity < 0 && normalVelocity * normalVelocity > _restingThresh * timeScaleSquared) {\n                    // high velocity so clear cached contact impulse\n                    contact.normalImpulse = 0;\n                    contact.tangentImpulse = 0;\n                } else {\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\n\n                    // impulse constraint, tends to 0\n                    var contactNormalImpulse = contact.normalImpulse;\n                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);\n                    normalImpulse = contact.normalImpulse - contactNormalImpulse;\n\n                    // tangent impulse, tends to -maxFriction or maxFriction\n                    var contactTangentImpulse = contact.tangentImpulse;\n                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -tangentSpeed, tangentSpeed);\n                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\n                }\n\n                // total impulse from contact\n                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\n                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\n\n                // apply impulse from contact\n                if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\n                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\n                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;\n                }\n\n                if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\n                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\n                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;\n                }\n            }\n        }\n    };\n\n})();\n\n;   // End src/collision/Resolver.js\n\n\n// Begin src/collision/SAT.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class SAT\n*/\n\n// TODO: true circles and curves\n\nvar SAT = {};\n\n(function() {\n\n    /**\n     * Description\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {collision} previousCollision\n     * @return {collision} collision\n     */\n    SAT.collides = function(bodyA, bodyB, previousCollision) {\n        var overlapAB,\n            overlapBA,\n            minOverlap,\n            collision,\n            prevCol = previousCollision,\n            canReusePrevCol = false;\n\n        if (prevCol) {\n            // estimate total motion\n            var motion = bodyA.speed * bodyA.speed + bodyA.angularSpeed * bodyA.angularSpeed\n                       + bodyB.speed * bodyB.speed + bodyB.angularSpeed * bodyB.angularSpeed;\n\n            // we may be able to (partially) reuse collision result\n            // but only safe if collision was resting\n            canReusePrevCol = prevCol && prevCol.collided && motion < 0.2;\n\n            // reuse collision object\n            collision = prevCol;\n        } else {\n            collision = { collided: false, bodyA: bodyA, bodyB: bodyB };\n        }\n\n        if (prevCol && canReusePrevCol) {\n            // if we can reuse the collision result\n            // we only need to test the previously found axis\n            var axes = [prevCol.bodyA.axes[prevCol.axisNumber]];\n\n            minOverlap = _overlapAxes(prevCol.bodyA.vertices, prevCol.bodyB.vertices, axes);\n            collision.reused = true;\n\n            if (minOverlap.overlap <= 0) {\n                collision.collided = false;\n                return collision;\n            }\n        } else {\n            // if we can't reuse a result, perform a full SAT test\n\n            overlapAB = _overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);\n\n            if (overlapAB.overlap <= 0) {\n                collision.collided = false;\n                return collision;\n            }\n\n            overlapBA = _overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);\n\n            if (overlapBA.overlap <= 0) {\n                collision.collided = false;\n                return collision;\n            }\n\n            if (overlapAB.overlap < overlapBA.overlap) {\n                minOverlap = overlapAB;\n                collision.bodyA = bodyA;\n                collision.bodyB = bodyB;\n            } else {\n                minOverlap = overlapBA;\n                collision.bodyA = bodyB;\n                collision.bodyB = bodyA;\n            }\n\n            // important for reuse later\n            collision.axisNumber = minOverlap.axisNumber;\n        }\n\n        collision.collided = true;\n        collision.normal = minOverlap.axis;\n        collision.depth = minOverlap.overlap;\n\n        bodyA = collision.bodyA;\n        bodyB = collision.bodyB;\n\n        // ensure normal is facing away from bodyA\n        if (Vector.dot(collision.normal, Vector.sub(bodyB.position, bodyA.position)) > 0)\n            collision.normal = Vector.neg(collision.normal);\n\n        collision.tangent = Vector.perp(collision.normal);\n\n        collision.penetration = {\n            x: collision.normal.x * collision.depth,\n            y: collision.normal.y * collision.depth\n        };\n\n        // find support points, there is always either exactly one or two\n        var verticesB = _findSupports(bodyA, bodyB, collision.normal),\n            supports = collision.supports || [];\n        supports.length = 0;\n\n        // find the supports from bodyB that are inside bodyA\n        if (Vertices.contains(bodyA.vertices, verticesB[0]))\n            supports.push(verticesB[0]);\n\n        if (Vertices.contains(bodyA.vertices, verticesB[1]))\n            supports.push(verticesB[1]);\n\n        // find the supports from bodyA that are inside bodyB\n        if (supports.length < 2) {\n            var verticesA = _findSupports(bodyB, bodyA, Vector.neg(collision.normal));\n\n            if (Vertices.contains(bodyB.vertices, verticesA[0]))\n                supports.push(verticesA[0]);\n\n            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))\n                supports.push(verticesA[1]);\n        }\n\n        // account for the edge case of overlapping but no vertex containment\n        if (supports.length < 2)\n            supports = [verticesB[0]];\n\n        collision.supports = supports;\n        collision.supportCorrected = Vector.sub(supports[0], collision.penetration);\n\n        return collision;\n    };\n\n    /**\n     * Description\n     * @method _overlapAxes\n     * @private\n     * @param {} verticesA\n     * @param {} verticesB\n     * @param {} axes\n     * @return result\n     */\n    var _overlapAxes = function(verticesA, verticesB, axes) {\n        var projectionA = {},\n            projectionB = {},\n            result = { overlap: Number.MAX_VALUE },\n            overlap,\n            axis;\n\n        for (var i = 0; i < axes.length; i++) {\n            axis = axes[i];\n\n            _projectToAxis(projectionA, verticesA, axis);\n            _projectToAxis(projectionB, verticesB, axis);\n\n            overlap = projectionA.min < projectionB.min\n                        ? projectionA.max - projectionB.min\n                        : projectionB.max - projectionA.min;\n\n            if (overlap <= 0) {\n                result.overlap = overlap;\n                return result;\n            }\n\n            if (overlap < result.overlap) {\n                result.overlap = overlap;\n                result.axis = axis;\n                result.axisNumber = i;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Description\n     * @method _projectToAxis\n     * @private\n     * @param {} projection\n     * @param {} vertices\n     * @param {} axis\n     */\n    var _projectToAxis = function(projection, vertices, axis) {\n        var min = Vector.dot(vertices[0], axis),\n            max = min;\n\n        for (var i = 1; i < vertices.length; i += 1) {\n            var dot = Vector.dot(vertices[i], axis);\n\n            if (dot > max) {\n                max = dot;\n            } else if (dot < min) {\n                min = dot;\n            }\n        }\n\n        projection.min = min;\n        projection.max = max;\n    };\n\n    /**\n     * Description\n     * @method _findSupports\n     * @private\n     * @param {} bodyA\n     * @param {} bodyB\n     * @param {} normal\n     * @return ArrayExpression\n     */\n    var _findSupports = function(bodyA, bodyB, normal) {\n        var nearestDistance = Number.MAX_VALUE,\n            vertexToBody = { x: 0, y: 0 },\n            vertices = bodyB.vertices,\n            bodyAPosition = bodyA.position,\n            distance,\n            vertex,\n            vertexA = vertices[0],\n            vertexB = vertices[1];\n\n        // find closest vertex on bodyB\n        for (var i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            vertexToBody.x = vertex.x - bodyAPosition.x;\n            vertexToBody.y = vertex.y - bodyAPosition.y;\n            distance = -Vector.dot(normal, vertexToBody);\n\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                vertexA = vertex;\n            }\n        }\n\n        // find next closest vertex using the two connected to it\n        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;\n        vertex = vertices[prevIndex];\n        vertexToBody.x = vertex.x - bodyAPosition.x;\n        vertexToBody.y = vertex.y - bodyAPosition.y;\n        nearestDistance = -Vector.dot(normal, vertexToBody);\n        vertexB = vertex;\n\n        var nextIndex = (vertexA.index + 1) % vertices.length;\n        vertex = vertices[nextIndex];\n        vertexToBody.x = vertex.x - bodyAPosition.x;\n        vertexToBody.y = vertex.y - bodyAPosition.y;\n        distance = -Vector.dot(normal, vertexToBody);\n        if (distance < nearestDistance) {\n            vertexB = vertex;\n        }\n\n        return [vertexA, vertexB];\n    };\n\n})();\n\n\n;   // End src/collision/SAT.js\n\n\n// Begin src/constraint/Constraint.js\n\n/**\n* The `Matter.Constraint` module contains methods for creating and manipulating constraints.\n* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\n* The stiffness of constraints can be modified to create springs or elastic.\n*\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class Constraint\n*/\n\n// TODO: fix instabillity issues with torque\n// TODO: linked constraints\n// TODO: breakable constraints\n// TODO: collidable constraints\n// TODO: allow constrained bodies to sleep\n// TODO: handle 0 length constraints properly\n// TODO: impulse caching and warming\n\nvar Constraint = {};\n\n(function() {\n\n    var _minLength = 0.000001,\n        _minDifference = 0.001;\n\n    /**\n     * Creates a new constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {constraint} constraint\n     */\n    Constraint.create = function(options) {\n        var constraint = options;\n\n        // if bodies defined but no points, use body centre\n        if (constraint.bodyA && !constraint.pointA)\n            constraint.pointA = { x: 0, y: 0 };\n        if (constraint.bodyB && !constraint.pointB)\n            constraint.pointB = { x: 0, y: 0 };\n\n        // calculate static length using initial world space points\n        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,\n            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,\n            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));\n\n        constraint.length = constraint.length || length || _minLength;\n\n        // render\n        var render = {\n            visible: true,\n            lineWidth: 2,\n            strokeStyle: '#666'\n        };\n\n        constraint.render = Common.extend(render, constraint.render);\n\n        // option defaults\n        constraint.id = constraint.id || Common.nextId();\n        constraint.label = constraint.label || 'Constraint';\n        constraint.type = 'constraint';\n        constraint.stiffness = constraint.stiffness || 1;\n        constraint.angularStiffness = constraint.angularStiffness || 0;\n        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;\n        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;\n\n        return constraint;\n    };\n\n    /**\n     * Description\n     * @private\n     * @method solveAll\n     * @param {constraint[]} constraints\n     * @param {number} timeScale\n     */\n    Constraint.solveAll = function(constraints, timeScale) {\n        for (var i = 0; i < constraints.length; i++) {\n            Constraint.solve(constraints[i], timeScale);\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method solve\n     * @param {constraint} constraint\n     * @param {number} timeScale\n     */\n    Constraint.solve = function(constraint, timeScale) {\n        var bodyA = constraint.bodyA,\n            bodyB = constraint.bodyB,\n            pointA = constraint.pointA,\n            pointB = constraint.pointB;\n\n        // update reference angle\n        if (bodyA && !bodyA.isStatic) {\n            constraint.pointA = Vector.rotate(pointA, bodyA.angle - constraint.angleA);\n            constraint.angleA = bodyA.angle;\n        }\n\n        // update reference angle\n        if (bodyB && !bodyB.isStatic) {\n            constraint.pointB = Vector.rotate(pointB, bodyB.angle - constraint.angleB);\n            constraint.angleB = bodyB.angle;\n        }\n\n        var pointAWorld = pointA,\n            pointBWorld = pointB;\n\n        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);\n        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);\n\n        if (!pointAWorld || !pointBWorld)\n            return;\n\n        var delta = Vector.sub(pointAWorld, pointBWorld),\n            currentLength = Vector.magnitude(delta);\n\n        // prevent singularity\n        if (currentLength === 0)\n            currentLength = _minLength;\n\n        // solve distance constraint with Gauss-Siedel method\n        var difference = (currentLength - constraint.length) / currentLength,\n            normal = Vector.div(delta, currentLength),\n            force = Vector.mult(delta, difference * 0.5 * constraint.stiffness * timeScale * timeScale);\n\n        // if difference is very small, we can skip\n        if (Math.abs(1 - (currentLength / constraint.length)) < _minDifference * timeScale)\n            return;\n\n        var velocityPointA,\n            velocityPointB,\n            offsetA,\n            offsetB,\n            oAn,\n            oBn,\n            bodyADenom,\n            bodyBDenom;\n\n        if (bodyA && !bodyA.isStatic) {\n            // point body offset\n            offsetA = {\n                x: pointAWorld.x - bodyA.position.x + force.x,\n                y: pointAWorld.y - bodyA.position.y + force.y\n            };\n\n            // update velocity\n            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;\n            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;\n            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\n\n            // find point velocity and body mass\n            velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity));\n            oAn = Vector.dot(offsetA, normal);\n            bodyADenom = bodyA.inverseMass + bodyA.inverseInertia * oAn * oAn;\n        } else {\n            velocityPointA = { x: 0, y: 0 };\n            bodyADenom = bodyA ? bodyA.inverseMass : 0;\n        }\n\n        if (bodyB && !bodyB.isStatic) {\n            // point body offset\n            offsetB = {\n                x: pointBWorld.x - bodyB.position.x - force.x,\n                y: pointBWorld.y - bodyB.position.y - force.y\n            };\n\n            // update velocity\n            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;\n            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;\n            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;\n\n            // find point velocity and body mass\n            velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity));\n            oBn = Vector.dot(offsetB, normal);\n            bodyBDenom = bodyB.inverseMass + bodyB.inverseInertia * oBn * oBn;\n        } else {\n            velocityPointB = { x: 0, y: 0 };\n            bodyBDenom = bodyB ? bodyB.inverseMass : 0;\n        }\n\n        var relativeVelocity = Vector.sub(velocityPointB, velocityPointA),\n            normalImpulse = Vector.dot(normal, relativeVelocity) / (bodyADenom + bodyBDenom);\n\n        if (normalImpulse > 0) normalImpulse = 0;\n\n        var normalVelocity = {\n            x: normal.x * normalImpulse,\n            y: normal.y * normalImpulse\n        };\n\n        var torque;\n\n        if (bodyA && !bodyA.isStatic) {\n            torque = Vector.cross(offsetA, normalVelocity) * bodyA.inverseInertia * (1 - constraint.angularStiffness);\n\n            Sleeping.set(bodyA, false);\n\n            // clamp to prevent instabillity\n            // TODO: solve this properlly\n            torque = Common.clamp(torque, -0.01, 0.01);\n\n            // keep track of applied impulses for post solving\n            bodyA.constraintImpulse.x -= force.x;\n            bodyA.constraintImpulse.y -= force.y;\n            bodyA.constraintImpulse.angle += torque;\n\n            // apply forces\n            bodyA.position.x -= force.x;\n            bodyA.position.y -= force.y;\n            bodyA.angle += torque;\n        }\n\n        if (bodyB && !bodyB.isStatic) {\n            torque = Vector.cross(offsetB, normalVelocity) * bodyB.inverseInertia * (1 - constraint.angularStiffness);\n\n            Sleeping.set(bodyB, false);\n\n            // clamp to prevent instabillity\n            // TODO: solve this properlly\n            torque = Common.clamp(torque, -0.01, 0.01);\n\n            // keep track of applied impulses for post solving\n            bodyB.constraintImpulse.x += force.x;\n            bodyB.constraintImpulse.y += force.y;\n            bodyB.constraintImpulse.angle -= torque;\n\n            // apply forces\n            bodyB.position.x += force.x;\n            bodyB.position.y += force.y;\n            bodyB.angle -= torque;\n        }\n\n    };\n\n    /**\n     * Performs body updates required after solving constraints\n     * @private\n     * @method postSolveAll\n     * @param {body[]} bodies\n     */\n    Constraint.postSolveAll = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                impulse = body.constraintImpulse;\n\n            // update geometry and reset\n            Vertices.translate(body.vertices, impulse);\n\n            if (impulse.angle !== 0) {\n                Vertices.rotate(body.vertices, impulse.angle, body.position);\n                Axes.rotate(body.axes, impulse.angle);\n                impulse.angle = 0;\n            }\n\n            Bounds.update(body.bounds, body.vertices);\n\n            impulse.x = 0;\n            impulse.y = 0;\n        }\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Constraint\"\n     */\n\n    /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */\n\n    /**\n     * A flag that indicates if the constraint should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A `Number` that defines the line width to use when rendering the constraint outline.\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 2\n     */\n\n    /**\n     * A `String` that defines the stroke style to use when rendering the constraint outline.\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * The first possible `Body` that this constraint is attached to.\n     *\n     * @property bodyA\n     * @type body\n     * @default null\n     */\n\n    /**\n     * The second possible `Body` that this constraint is attached to.\n     *\n     * @property bodyB\n     * @type body\n     * @default null\n     */\n\n    /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\n     *\n     * @property pointA\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\n     *\n     * @property pointB\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.\n     * A value of `1` means the constraint should be very stiff.\n     * A value of `0.2` means the constraint acts like a soft spring.\n     *\n     * @property stiffness\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that specifies the target resting length of the constraint.\n     * It is calculated automatically in `Constraint.create` from intial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     *\n     * @property length\n     * @type number\n     */\n\n})();\n\n;   // End src/constraint/Constraint.js\n\n\n// Begin src/constraint/MouseConstraint.js\n\n/**\n* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.\n* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.\n*\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class MouseConstraint\n*/\n\nvar MouseConstraint = {};\n\n(function() {\n\n    /**\n     * Creates a new mouse constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {engine} engine\n     * @param {} options\n     * @return {MouseConstraint} A new MouseConstraint\n     */\n    MouseConstraint.create = function(engine, options) {\n        var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);\n\n        if (!mouse && engine && engine.render && engine.render.canvas) {\n            mouse = Mouse.create(engine.render.canvas);\n        } else {\n            mouse = Mouse.create();\n            Common.log('MouseConstraint.create: options.mouse was undefined, engine.render.canvas was undefined, may not function as expected', 'warn');\n        }\n\n        var constraint = Constraint.create({\n            label: 'Mouse Constraint',\n            pointA: mouse.position,\n            pointB: { x: 0, y: 0 },\n            length: 0.01,\n            stiffness: 0.1,\n            angularStiffness: 1,\n            render: {\n                strokeStyle: '#90EE90',\n                lineWidth: 3\n            }\n        });\n\n        var defaults = {\n            type: 'mouseConstraint',\n            mouse: mouse,\n            body: null,\n            constraint: constraint,\n            collisionFilter: {\n                category: 0x0001,\n                mask: 0xFFFFFFFF,\n                group: 0\n            }\n        };\n\n        var mouseConstraint = Common.extend(defaults, options);\n\n        Events.on(engine, 'tick', function() {\n            var allBodies = Composite.allBodies(engine.world);\n            MouseConstraint.update(mouseConstraint, allBodies);\n            _triggerEvents(mouseConstraint);\n        });\n\n        return mouseConstraint;\n    };\n\n    /**\n     * Updates the given mouse constraint.\n     * @private\n     * @method update\n     * @param {MouseConstraint} mouseConstraint\n     * @param {body[]} bodies\n     */\n    MouseConstraint.update = function(mouseConstraint, bodies) {\n        var mouse = mouseConstraint.mouse,\n            constraint = mouseConstraint.constraint,\n            body = mouseConstraint.body;\n\n        if (mouse.button === 0) {\n            if (!constraint.bodyB) {\n                for (var i = 0; i < bodies.length; i++) {\n                    body = bodies[i];\n                    if (Bounds.contains(body.bounds, mouse.position)\n                            && Vertices.contains(body.vertices, mouse.position)\n                            && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {\n\n                        constraint.pointA = mouse.position;\n                        constraint.bodyB = mouseConstraint.body = body;\n                        constraint.pointB = { x: mouse.position.x - body.position.x, y: mouse.position.y - body.position.y };\n                        constraint.angleB = body.angle;\n\n                        Sleeping.set(body, false);\n                        Events.trigger(mouseConstraint, 'startdrag', { mouse: mouse, body: body });\n                    }\n                }\n            } else {\n                Sleeping.set(constraint.bodyB, false);\n                constraint.pointA = mouse.position;\n            }\n        } else {\n            constraint.bodyB = mouseConstraint.body = null;\n            constraint.pointB = null;\n\n            if (body)\n                Events.trigger(mouseConstraint, 'enddrag', { mouse: mouse, body: body });\n        }\n    };\n\n    /**\n     * Triggers mouse constraint events\n     * @method _triggerEvents\n     * @private\n     * @param {mouse} mouse\n     */\n    var _triggerEvents = function(mouseConstraint) {\n        var mouse = mouseConstraint.mouse,\n            mouseEvents = mouse.sourceEvents;\n\n        if (mouseEvents.mousemove)\n            Events.trigger(mouseConstraint, 'mousemove', { mouse: mouse });\n\n        if (mouseEvents.mousedown)\n            Events.trigger(mouseConstraint, 'mousedown', { mouse: mouse });\n\n        if (mouseEvents.mouseup)\n            Events.trigger(mouseConstraint, 'mouseup', { mouse: mouse });\n\n        // reset the mouse state ready for the next step\n        Mouse.clearSourceEvents(mouse);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when the mouse has moved (or a touch moves) during the last step\n    *\n    * @event mousemove\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the mouse is down (or a touch has started) during the last step\n    *\n    * @event mousedown\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the mouse is up (or a touch has ended) during the last step\n    *\n    * @event mouseup\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the user starts dragging a body\n    *\n    * @event startdrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the user ends dragging a body\n    *\n    * @event enddrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body that has stopped being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     */\n\n    /**\n     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.\n     *\n     * @property mouse\n     * @type mouse\n     * @default mouse\n     */\n\n    /**\n     * The `Body` that is currently being moved by the user, or `null` if no body.\n     *\n     * @property body\n     * @type body\n     * @default null\n     */\n\n    /**\n     * The `Constraint` object that is used to move the body during interaction.\n     *\n     * @property constraint\n     * @type constraint\n     */\n\n    /**\n     * An `Object` that specifies the collision filter properties.\n     * The collision filter allows the user to define which types of body this mouse constraint can interact with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter\n     * @type object\n     */\n\n})();\n\n\n;   // End src/constraint/MouseConstraint.js\n\n\n// Begin src/core/Common.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Common\n*/\n\nvar Common = {};\n\n(function() {\n\n    Common._nextId = 0;\n    Common._seed = 0;\n\n    /**\n     * Description\n     * @method extend\n     * @param {} obj\n     * @param {boolean} deep\n     * @return {} obj extended\n     */\n    Common.extend = function(obj, deep) {\n        var argsStart,\n            args,\n            deepClone;\n\n        if (typeof deep === 'boolean') {\n            argsStart = 2;\n            deepClone = deep;\n        } else {\n            argsStart = 1;\n            deepClone = true;\n        }\n\n        args = Array.prototype.slice.call(arguments, argsStart);\n\n        for (var i = 0; i < args.length; i++) {\n            var source = args[i];\n\n            if (source) {\n                for (var prop in source) {\n                    if (deepClone && source[prop] && source[prop].constructor === Object) {\n                        if (!obj[prop] || obj[prop].constructor === Object) {\n                            obj[prop] = obj[prop] || {};\n                            Common.extend(obj[prop], deepClone, source[prop]);\n                        } else {\n                            obj[prop] = source[prop];\n                        }\n                    } else {\n                        obj[prop] = source[prop];\n                    }\n                }\n            }\n        }\n\n        return obj;\n    };\n\n    /**\n     * Creates a new clone of the object, if deep is true references will also be cloned\n     * @method clone\n     * @param {} obj\n     * @param {bool} deep\n     * @return {} obj cloned\n     */\n    Common.clone = function(obj, deep) {\n        return Common.extend({}, deep, obj);\n    };\n\n    /**\n     * Description\n     * @method keys\n     * @param {} obj\n     * @return {string[]} keys\n     */\n    Common.keys = function(obj) {\n        if (Object.keys)\n            return Object.keys(obj);\n\n        // avoid hasOwnProperty for performance\n        var keys = [];\n        for (var key in obj)\n            keys.push(key);\n        return keys;\n    };\n\n    /**\n     * Description\n     * @method values\n     * @param {} obj\n     * @return {array} Array of the objects property values\n     */\n    Common.values = function(obj) {\n        var values = [];\n\n        if (Object.keys) {\n            var keys = Object.keys(obj);\n            for (var i = 0; i < keys.length; i++) {\n                values.push(obj[keys[i]]);\n            }\n            return values;\n        }\n\n        // avoid hasOwnProperty for performance\n        for (var key in obj)\n            values.push(obj[key]);\n        return values;\n    };\n\n    /**\n     * Description\n     * @method shadeColor\n     * @param {string} color\n     * @param {number} percent\n     * @return {string} A hex colour string made by lightening or darkening color by percent\n     */\n    Common.shadeColor = function(color, percent) {\n        // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color\n        var colorInteger = parseInt(color.slice(1),16),\n            amount = Math.round(2.55 * percent),\n            R = (colorInteger >> 16) + amount,\n            B = (colorInteger >> 8 & 0x00FF) + amount,\n            G = (colorInteger & 0x0000FF) + amount;\n        return \"#\" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R :255) * 0x10000\n                + (B < 255 ? B < 1 ? 0 : B : 255) * 0x100\n                + (G < 255 ? G < 1 ? 0 : G : 255)).toString(16).slice(1);\n    };\n\n    /**\n     * Description\n     * @method shuffle\n     * @param {array} array\n     * @return {array} array shuffled randomly\n     */\n    Common.shuffle = function(array) {\n        for (var i = array.length - 1; i > 0; i--) {\n            var j = Math.floor(Common.random() * (i + 1));\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n        return array;\n    };\n\n    /**\n     * Description\n     * @method choose\n     * @param {array} choices\n     * @return {object} A random choice object from the array\n     */\n    Common.choose = function(choices) {\n        return choices[Math.floor(Common.random() * choices.length)];\n    };\n\n    /**\n     * Description\n     * @method isElement\n     * @param {object} obj\n     * @return {boolean} True if the object is a HTMLElement, otherwise false\n     */\n    Common.isElement = function(obj) {\n        // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n        try {\n            return obj instanceof HTMLElement;\n        }\n        catch(e){\n            return (typeof obj===\"object\") &&\n              (obj.nodeType===1) && (typeof obj.style === \"object\") &&\n              (typeof obj.ownerDocument ===\"object\");\n        }\n    };\n\n    /**\n     * Description\n     * @method clamp\n     * @param {number} value\n     * @param {number} min\n     * @param {number} max\n     * @return {number} The value clamped between min and max inclusive\n     */\n    Common.clamp = function(value, min, max) {\n        if (value < min)\n            return min;\n        if (value > max)\n            return max;\n        return value;\n    };\n\n    /**\n     * Description\n     * @method sign\n     * @param {number} value\n     * @return {number} -1 if negative, +1 if 0 or positive\n     */\n    Common.sign = function(value) {\n        return value < 0 ? -1 : 1;\n    };\n\n    /**\n     * Description\n     * @method now\n     * @return {number} the current timestamp (high-res if avaliable)\n     */\n    Common.now = function() {\n        // http://stackoverflow.com/questions/221294/how-do-you-get-a-timestamp-in-javascript\n        // https://gist.github.com/davidwaterston/2982531\n\n        var perf = window.performance;\n\n        if (perf) {\n            perf.now = perf.now || perf.webkitNow || perf.msNow || perf.oNow || perf.mozNow;\n            return +(perf.now());\n        }\n\n        return +(new Date());\n    };\n\n\n    /**\n     * Description\n     * @method random\n     * @param {number} min\n     * @param {number} max\n     * @return {number} A random number between min and max inclusive\n     */\n    Common.random = function(min, max) {\n        min = (typeof min !== \"undefined\") ? min : 0;\n        max = (typeof max !== \"undefined\") ? max : 1;\n        return min + _seededRandom() * (max - min);\n    };\n\n    /**\n     * Converts a CSS hex colour string into an integer\n     * @method colorToNumber\n     * @param {string} colorString\n     * @return {number} An integer representing the CSS hex string\n     */\n    Common.colorToNumber = function(colorString) {\n        colorString = colorString.replace('#','');\n\n        if (colorString.length == 3) {\n            colorString = colorString.charAt(0) + colorString.charAt(0)\n                        + colorString.charAt(1) + colorString.charAt(1)\n                        + colorString.charAt(2) + colorString.charAt(2);\n        }\n\n        return parseInt(colorString, 16);\n    };\n\n    /**\n     * A wrapper for console.log, for providing errors and warnings\n     * @method log\n     * @param {string} message\n     * @param {string} type\n     */\n    Common.log = function(message, type) {\n        if (!console || !console.log || !console.warn)\n            return;\n\n        var style;\n\n        switch (type) {\n\n        case 'warn':\n            console.warn('Matter.js:', message);\n            break;\n        case 'error':\n            console.log('Matter.js:', message);\n            break;\n\n        }\n    };\n\n    /**\n     * Returns the next unique sequential ID\n     * @method nextId\n     * @return {Number} Unique sequential ID\n     */\n    Common.nextId = function() {\n        return Common._nextId++;\n    };\n\n    /**\n     * A cross browser compatible indexOf implementation\n     * @method indexOf\n     * @param {array} haystack\n     * @param {object} needle\n     */\n    Common.indexOf = function(haystack, needle) {\n        if (haystack.indexOf)\n            return haystack.indexOf(needle);\n\n        for (var i = 0; i < haystack.length; i++) {\n            if (haystack[i] === needle)\n                return i;\n        }\n\n        return -1;\n    };\n\n    var _seededRandom = function() {\n        // https://gist.github.com/ngryman/3830489\n        Common._seed = (Common._seed * 9301 + 49297) % 233280;\n        return Common._seed / 233280;\n    };\n\n})();\n\n;   // End src/core/Common.js\n\n\n// Begin src/core/Engine.js\n\n/**\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\n* An engine is a controller that manages updating and rendering the simulation of the world.\n* See `Matter.Runner` for an optional game loop utility.\n*\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class Engine\n*/\n\nvar Engine = {};\n\n(function() {\n\n    var _fps = 60,\n        _delta = 1000 / _fps;\n\n    /**\n     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {HTMLElement} element\n     * @param {object} [options]\n     * @return {engine} engine\n     */\n    Engine.create = function(element, options) {\n\n        // options may be passed as the first (and only) argument\n        options = Common.isElement(element) ? options : element;\n        element = Common.isElement(element) ? element : null;\n\n        var defaults = {\n            enabled: true,\n            positionIterations: 6,\n            velocityIterations: 4,\n            constraintIterations: 2,\n            enableSleeping: false,\n            events: [],\n            timing: {\n                fps: _fps,\n                timestamp: 0,\n                delta: _delta,\n                correction: 1,\n                deltaMin: 1000 / _fps,\n                deltaMax: 1000 / (_fps * 0.5),\n                timeScale: 1,\n                isFixed: false,\n                frameRequestId: 0\n            },\n            render: {\n                element: element,\n                controller: Render\n            },\n            broadphase: {\n                controller: Grid\n            }\n        };\n\n        var engine = Common.extend(defaults, options);\n\n        engine.render = engine.render.controller.create(engine.render);\n        engine.world = World.create(engine.world);\n        engine.pairs = Pairs.create();\n        engine.metrics = engine.metrics || Metrics.create();\n        engine.broadphase = engine.broadphase.controller.create(engine.broadphase);\n\n        return engine;\n    };\n\n    /**\n     * Moves the simulation forward in time by `delta` ms.\n     * Triggers `beforeUpdate` and `afterUpdate` events.\n     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\n     * @method update\n     * @param {engine} engine\n     * @param {number} delta\n     * @param {number} [correction]\n     */\n    Engine.update = function(engine, delta, correction) {\n        correction = (typeof correction !== 'undefined') ? correction : 1;\n\n        var world = engine.world,\n            timing = engine.timing,\n            broadphase = engine.broadphase,\n            broadphasePairs = [],\n            i;\n\n        // increment timestamp\n        timing.timestamp += delta * timing.timeScale;\n        timing.correction = correction;\n\n        // create an event object\n        var event = {\n            timestamp: engine.timing.timestamp\n        };\n\n        Events.trigger(engine, 'beforeUpdate', event);\n\n        // get lists of all bodies and constraints, no matter what composites they are in\n        var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world);\n\n        // reset metrics logging\n        Metrics.reset(engine.metrics);\n\n        // if sleeping enabled, call the sleeping controller\n        if (engine.enableSleeping)\n            Sleeping.update(allBodies, timing.timeScale);\n\n        // applies gravity to all bodies\n        _bodiesApplyGravity(allBodies, world.gravity);\n\n        // update all body position and rotation by integration\n        _bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);\n\n        // update all constraints\n        for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, timing.timeScale);\n        }\n        Constraint.postSolveAll(allBodies);\n\n        // broadphase pass: find potential collision pairs\n        if (broadphase.controller) {\n\n            // if world is dirty, we must flush the whole grid\n            if (world.isModified)\n                broadphase.controller.clear(broadphase);\n\n            // update the grid buckets based on current bodies\n            broadphase.controller.update(broadphase, allBodies, engine, world.isModified);\n            broadphasePairs = broadphase.pairsList;\n        } else {\n\n            // if no broadphase set, we just pass all bodies\n            broadphasePairs = allBodies;\n        }\n\n        // narrowphase pass: find actual collisions, then create or update collision pairs\n        var collisions = broadphase.detector(broadphasePairs, engine);\n\n        // update collision pairs\n        var pairs = engine.pairs,\n            timestamp = timing.timestamp;\n        Pairs.update(pairs, collisions, timestamp);\n        Pairs.removeOld(pairs, timestamp);\n\n        // wake up bodies involved in collisions\n        if (engine.enableSleeping)\n            Sleeping.afterCollisions(pairs.list, timing.timeScale);\n\n        // trigger collision events\n        if (pairs.collisionStart.length > 0)\n            Events.trigger(engine, 'collisionStart', { pairs: pairs.collisionStart });\n\n        // iteratively resolve velocity between collisions\n        Resolver.preSolveVelocity(pairs.list);\n        for (i = 0; i < engine.velocityIterations; i++) {\n            Resolver.solveVelocity(pairs.list, timing.timeScale);\n        }\n\n        // iteratively resolve position between collisions\n        for (i = 0; i < engine.positionIterations; i++) {\n            Resolver.solvePosition(pairs.list, timing.timeScale);\n        }\n        Resolver.postSolvePosition(allBodies);\n\n        // trigger collision events\n        if (pairs.collisionActive.length > 0)\n            Events.trigger(engine, 'collisionActive', { pairs: pairs.collisionActive });\n\n        if (pairs.collisionEnd.length > 0)\n            Events.trigger(engine, 'collisionEnd', { pairs: pairs.collisionEnd });\n\n        // update metrics log\n        Metrics.update(engine.metrics, engine);\n\n        // clear force buffers\n        _bodiesClearForces(allBodies);\n\n        // clear all composite modified flags\n        if (world.isModified)\n            Composite.setModified(world, false, false, true);\n\n        Events.trigger(engine, 'afterUpdate', event);\n\n        return engine;\n    };\n\n    /**\n     * Renders the world by calling its defined renderer `engine.render.controller`. Triggers `beforeRender` and `afterRender` events.\n     * @method render\n     * @param {engine} engineA\n     * @param {engine} engineB\n     */\n    Engine.render = function(engine) {\n        // create an event object\n        var event = {\n            timestamp: engine.timing.timestamp\n        };\n\n        Events.trigger(engine, 'beforeRender', event);\n        engine.render.controller.world(engine);\n        Events.trigger(engine, 'afterRender', event);\n    };\n\n    /**\n     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\n     * @method merge\n     * @param {engine} engineA\n     * @param {engine} engineB\n     */\n    Engine.merge = function(engineA, engineB) {\n        Common.extend(engineA, engineB);\n\n        if (engineB.world) {\n            engineA.world = engineB.world;\n\n            Engine.clear(engineA);\n\n            var bodies = Composite.allBodies(engineA.world);\n\n            for (var i = 0; i < bodies.length; i++) {\n                var body = bodies[i];\n                Sleeping.set(body, false);\n                body.id = Common.nextId();\n            }\n        }\n    };\n\n    /**\n     * Clears the engine including the world, pairs and broadphase.\n     * @method clear\n     * @param {engine} engine\n     */\n    Engine.clear = function(engine) {\n        var world = engine.world;\n\n        Pairs.clear(engine.pairs);\n\n        var broadphase = engine.broadphase;\n        if (broadphase.controller) {\n            var bodies = Composite.allBodies(world);\n            broadphase.controller.clear(broadphase);\n            broadphase.controller.update(broadphase, bodies, engine, true);\n        }\n    };\n\n    /**\n     * Zeroes the `body.force` and `body.torque` force buffers.\n     * @method bodiesClearForces\n     * @private\n     * @param {body[]} bodies\n     */\n    var _bodiesClearForces = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            // reset force buffers\n            body.force.x = 0;\n            body.force.y = 0;\n            body.torque = 0;\n        }\n    };\n\n    /**\n     * Applys a mass dependant force to all given bodies.\n     * @method bodiesApplyGravity\n     * @private\n     * @param {body[]} bodies\n     * @param {vector} gravity\n     */\n    var _bodiesApplyGravity = function(bodies, gravity) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isStatic || body.isSleeping)\n                continue;\n\n            // apply gravity\n            body.force.y += body.mass * gravity.y * 0.001;\n            body.force.x += body.mass * gravity.x * 0.001;\n        }\n    };\n\n    /**\n     * Applys `Body.update` to all given `bodies`.\n     * @method updateAll\n     * @private\n     * @param {body[]} bodies\n     * @param {number} deltaTime\n     * The amount of time elapsed between updates\n     * @param {number} timeScale\n     * @param {number} correction\n     * The Verlet correction factor (deltaTime / lastDeltaTime)\n     * @param {bounds} worldBounds\n     */\n    var _bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isStatic || body.isSleeping)\n                continue;\n\n            // don't update out of world bodies\n            if (body.bounds.max.x < worldBounds.min.x || body.bounds.min.x > worldBounds.max.x\n                || body.bounds.max.y < worldBounds.min.y || body.bounds.min.y > worldBounds.max.y)\n                continue;\n\n            Body.update(body, deltaTime, timeScale, correction);\n        }\n    };\n\n    /**\n     * An alias for `Runner.run`, see `Matter.Runner` for more information.\n     * @method run\n     * @param {engine} engine\n     */\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired at the start of a tick, before any updates to the engine or timing\n    *\n    * @event beforeTick\n    * @param {} event An event object\n    * @param {DOMHighResTimeStamp} event.timestamp The timestamp of the current tick\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine timing updated, but just before engine state updated\n    *\n    * @event tick\n    * @param {} event An event object\n    * @param {DOMHighResTimeStamp} event.timestamp The timestamp of the current tick\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired just before an update\n    *\n    * @event beforeUpdate\n    * @param {} event An event object\n    * @param {DOMHighResTimeStamp} event.timestamp The timestamp of the current tick\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update and all collision events\n    *\n    * @event afterUpdate\n    * @param {} event An event object\n    * @param {DOMHighResTimeStamp} event.timestamp The timestamp of the current tick\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired just before rendering\n    *\n    * @event beforeRender\n    * @param {} event An event object\n    * @param {DOMHighResTimeStamp} event.timestamp The timestamp of the current tick\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after rendering\n    *\n    * @event afterRender\n    * @param {} event An event object\n    * @param {DOMHighResTimeStamp} event.timestamp The timestamp of the current tick\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update and after rendering\n    *\n    * @event afterTick\n    * @param {} event An event object\n    * @param {DOMHighResTimeStamp} event.timestamp The timestamp of the current tick\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\n    *\n    * @event collisionStart\n    * @param {} event An event object\n    * @param {} event.pairs List of affected pairs\n    * @param {DOMHighResTimeStamp} event.timestamp The timestamp of the current tick\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\n    *\n    * @event collisionActive\n    * @param {} event An event object\n    * @param {} event.pairs List of affected pairs\n    * @param {DOMHighResTimeStamp} event.timestamp The timestamp of the current tick\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\n    *\n    * @event collisionEnd\n    * @param {} event An event object\n    * @param {} event.pairs List of affected pairs\n    * @param {DOMHighResTimeStamp} event.timestamp The timestamp of the current tick\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A flag that specifies whether the engine is running or not.\n     *\n     * @property enabled\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * An integer `Number` that specifies the number of position iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property positionIterations\n     * @type number\n     * @default 6\n     */\n\n    /**\n     * An integer `Number` that specifies the number of velocity iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property velocityIterations\n     * @type number\n     * @default 4\n     */\n\n    /**\n     * An integer `Number` that specifies the number of constraint iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     * The default value of `2` is usually very adequate.\n     *\n     * @property constraintIterations\n     * @type number\n     * @default 2\n     */\n\n    /**\n     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\n     * Sleeping can improve stability and performance, but often at the expense of accuracy.\n     *\n     * @property enableSleeping\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * An `Object` containing properties regarding the timing systems of the engine.\n     *\n     * @property timing\n     * @type object\n     */\n\n    /**\n     * A `Number` that specifies the global scaling factor of time for all bodies.\n     * A value of `0` freezes the simulation.\n     * A value of `0.1` gives a slow-motion effect.\n     * A value of `1.2` gives a speed-up effect.\n     *\n     * @property timing.timeScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`.\n     * It is incremented on every `Engine.update` by the `timing.delta`.\n     *\n     * @property timing.timestamp\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Boolean` that specifies if the `Engine.run` game loop should use a fixed timestep (otherwise it is variable).\n     * If timing is fixed, then the apparant simulation speed will change depending on the frame rate (but behaviour will be deterministic).\n     * If the timing is variable, then the apparant simulation speed will be constant (approximately, but at the cost of determininism).\n     *\n     * @property timing.isFixed\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A `Number` that specifies the time step between updates in milliseconds.\n     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.\n     * If it is `false`, then `delta` can dynamically change to maintain the correct apparant simulation speed.\n     *\n     * @property timing.delta\n     * @type number\n     * @default 1000 / 60\n     */\n\n    /**\n     * A `Number` that specifies the time correction factor to apply to the current timestep.\n     * It is automatically handled when using `Engine.run`, but is also only optional even if you use your own game loop.\n     * The value is defined as `delta / lastDelta`, i.e. the percentage change of `delta` between steps.\n     * This value is always `1` (no correction) when frame rate is constant or `engine.timing.isFixed` is `true`.\n     * If the framerate and hence `delta` are changing, then correction should be applied to the current update to account for the change.\n     * See the paper on <a href=\"http://lonesock.net/article/verlet.html\">Time Corrected Verlet</a> for more information.\n     *\n     * @property timing.correction\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.\n     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.\n     *\n     * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).\n     * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.\n     *\n     * @property render\n     * @type render\n     * @default a Matter.Render instance\n     */\n\n    /**\n     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.\n     *\n     * @property broadphase\n     * @type grid\n     * @default a Matter.Grid instance\n     */\n\n    /**\n     * A `World` composite object that will contain all simulated bodies and constraints.\n     *\n     * @property world\n     * @type world\n     * @default a Matter.World instance\n     */\n\n})();\n\n;   // End src/core/Engine.js\n\n\n// Begin src/core/Events.js\n\n/**\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class Events\n*/\n\nvar Events = {};\n\n(function() {\n\n    /**\n     * Subscribes a callback function to the given object's `eventName`.\n     * @method on\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */\n    Events.on = function(object, eventNames, callback) {\n        var names = eventNames.split(' '),\n            name;\n\n        for (var i = 0; i < names.length; i++) {\n            name = names[i];\n            object.events = object.events || {};\n            object.events[name] = object.events[name] || [];\n            object.events[name].push(callback);\n        }\n\n        return callback;\n    };\n\n    /**\n     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.\n     * @method off\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */\n    Events.off = function(object, eventNames, callback) {\n        if (!eventNames) {\n            object.events = {};\n            return;\n        }\n\n        // handle Events.off(object, callback)\n        if (typeof eventNames === 'function') {\n            callback = eventNames;\n            eventNames = Common.keys(object.events).join(' ');\n        }\n\n        var names = eventNames.split(' ');\n\n        for (var i = 0; i < names.length; i++) {\n            var callbacks = object.events[names[i]],\n                newCallbacks = [];\n\n            if (callback) {\n                for (var j = 0; j < callbacks.length; j++) {\n                    if (callbacks[j] !== callback)\n                        newCallbacks.push(callbacks[j]);\n                }\n            }\n\n            object.events[names[i]] = newCallbacks;\n        }\n    };\n\n    /**\n     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.\n     * @method trigger\n     * @param {} object\n     * @param {string} eventNames\n     * @param {} event\n     */\n    Events.trigger = function(object, eventNames, event) {\n        var names,\n            name,\n            callbacks,\n            eventClone;\n\n        if (object.events) {\n            if (!event)\n                event = {};\n\n            names = eventNames.split(' ');\n\n            for (var i = 0; i < names.length; i++) {\n                name = names[i];\n                callbacks = object.events[name];\n\n                if (callbacks) {\n                    eventClone = Common.clone(event, false);\n                    eventClone.name = name;\n                    eventClone.source = object;\n\n                    for (var j = 0; j < callbacks.length; j++) {\n                        callbacks[j].apply(object, [eventClone]);\n                    }\n                }\n            }\n        }\n    };\n\n})();\n\n;   // End src/core/Events.js\n\n\n// Begin src/core/Metrics.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Metrics\n*/\n\nvar Metrics = {};\n\n(function() {\n\n    /**\n     * Description\n     * @method create\n     * @return {metrics} A new metrics\n     */\n    Metrics.create = function() {\n        return {\n            extended: false,\n            narrowDetections: 0,\n            narrowphaseTests: 0,\n            narrowReuse: 0,\n            narrowReuseCount: 0,\n            midphaseTests: 0,\n            broadphaseTests: 0,\n            narrowEff: 0.0001,\n            midEff: 0.0001,\n            broadEff: 0.0001,\n            collisions: 0,\n            buckets: 0,\n            bodies: 0,\n            pairs: 0\n        };\n    };\n\n    /**\n     * Description\n     * @method reset\n     * @param {metrics} metrics\n     */\n    Metrics.reset = function(metrics) {\n        if (metrics.extended) {\n            metrics.narrowDetections = 0;\n            metrics.narrowphaseTests = 0;\n            metrics.narrowReuse = 0;\n            metrics.narrowReuseCount = 0;\n            metrics.midphaseTests = 0;\n            metrics.broadphaseTests = 0;\n            metrics.narrowEff = 0;\n            metrics.midEff = 0;\n            metrics.broadEff = 0;\n            metrics.collisions = 0;\n            metrics.buckets = 0;\n            metrics.pairs = 0;\n            metrics.bodies = 0;\n        }\n    };\n\n    /**\n     * Description\n     * @method update\n     * @param {metrics} metrics\n     * @param {engine} engine\n     */\n    Metrics.update = function(metrics, engine) {\n        if (metrics.extended) {\n            var world = engine.world,\n                bodies = Composite.allBodies(world);\n\n            metrics.collisions = metrics.narrowDetections;\n            metrics.pairs = engine.pairs.list.length;\n            metrics.bodies = bodies.length;\n            metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2);\n            metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2);\n            metrics.broadEff = (1 - (metrics.broadphaseTests / (bodies.length || 1))).toFixed(2);\n            metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2);\n            //var broadphase = engine.broadphase[engine.broadphase.current];\n            //if (broadphase.instance)\n            //    metrics.buckets = Common.keys(broadphase.instance.buckets).length;\n        }\n    };\n\n})();\n\n\n;   // End src/core/Metrics.js\n\n\n// Begin src/core/Mouse.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Mouse\n*/\n\nvar Mouse = {};\n\n(function() {\n\n    /**\n     * Description\n     * @method create\n     * @param {HTMLElement} element\n     * @return {mouse} A new mouse\n     */\n    Mouse.create = function(element) {\n        var mouse = {};\n\n        if (!element) {\n            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');\n        }\n\n        mouse.element = element || document.body;\n        mouse.absolute = { x: 0, y: 0 };\n        mouse.position = { x: 0, y: 0 };\n        mouse.mousedownPosition = { x: 0, y: 0 };\n        mouse.mouseupPosition = { x: 0, y: 0 };\n        mouse.offset = { x: 0, y: 0 };\n        mouse.scale = { x: 1, y: 1 };\n        mouse.wheelDelta = 0;\n        mouse.button = -1;\n        mouse.pixelRatio = mouse.element.getAttribute('data-pixel-ratio') || 1;\n\n        mouse.sourceEvents = {\n            mousemove: null,\n            mousedown: null,\n            mouseup: null,\n            mousewheel: null\n        };\n\n        mouse.mousemove = function(event) {\n            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                mouse.button = 0;\n                event.preventDefault();\n            }\n\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.sourceEvents.mousemove = event;\n        };\n\n        mouse.mousedown = function(event) {\n            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                mouse.button = 0;\n                event.preventDefault();\n            } else {\n                mouse.button = event.button;\n            }\n\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mousedownPosition.x = mouse.position.x;\n            mouse.mousedownPosition.y = mouse.position.y;\n            mouse.sourceEvents.mousedown = event;\n        };\n\n        mouse.mouseup = function(event) {\n            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                event.preventDefault();\n            }\n\n            mouse.button = -1;\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mouseupPosition.x = mouse.position.x;\n            mouse.mouseupPosition.y = mouse.position.y;\n            mouse.sourceEvents.mouseup = event;\n        };\n\n        mouse.mousewheel = function(event) {\n            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n            event.preventDefault();\n        };\n\n        Mouse.setElement(mouse, mouse.element);\n\n        return mouse;\n    };\n\n    /**\n     * Sets the element the mouse is bound to (and relative to)\n     * @method setElement\n     * @param {mouse} mouse\n     * @param {HTMLElement} element\n     */\n    Mouse.setElement = function(mouse, element) {\n        mouse.element = element;\n\n        element.addEventListener('mousemove', mouse.mousemove);\n        element.addEventListener('mousedown', mouse.mousedown);\n        element.addEventListener('mouseup', mouse.mouseup);\n\n        element.addEventListener(\"mousewheel\", mouse.mousewheel);\n        element.addEventListener(\"DOMMouseScroll\", mouse.mousewheel);\n\n        element.addEventListener('touchmove', mouse.mousemove);\n        element.addEventListener('touchstart', mouse.mousedown);\n        element.addEventListener('touchend', mouse.mouseup);\n    };\n\n    /**\n     * Clears all captured source events\n     * @method clearSourceEvents\n     * @param {mouse} mouse\n     */\n    Mouse.clearSourceEvents = function(mouse) {\n        mouse.sourceEvents.mousemove = null;\n        mouse.sourceEvents.mousedown = null;\n        mouse.sourceEvents.mouseup = null;\n        mouse.sourceEvents.mousewheel = null;\n        mouse.wheelDelta = 0;\n    };\n\n    /**\n     * Sets the offset\n     * @method setOffset\n     * @param {mouse} mouse\n     */\n    Mouse.setOffset = function(mouse, offset) {\n        mouse.offset.x = offset.x;\n        mouse.offset.y = offset.y;\n        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n    };\n\n    /**\n     * Sets the scale\n     * @method setScale\n     * @param {mouse} mouse\n     */\n    Mouse.setScale = function(mouse, scale) {\n        mouse.scale.x = scale.x;\n        mouse.scale.y = scale.y;\n        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n    };\n\n    /**\n     * Description\n     * @method _getRelativeMousePosition\n     * @private\n     * @param {} event\n     * @param {} element\n     * @param {number} pixelRatio\n     * @return {}\n     */\n    var _getRelativeMousePosition = function(event, element, pixelRatio) {\n        var elementBounds = element.getBoundingClientRect(),\n            rootNode = (document.documentElement || document.body.parentNode || document.body),\n            scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : rootNode.scrollLeft,\n            scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : rootNode.scrollTop,\n            touches = event.changedTouches,\n            x, y;\n\n        if (touches) {\n            x = touches[0].pageX - elementBounds.left - scrollX;\n            y = touches[0].pageY - elementBounds.top - scrollY;\n        } else {\n            x = event.pageX - elementBounds.left - scrollX;\n            y = event.pageY - elementBounds.top - scrollY;\n        }\n\n        return {\n            x: x / (element.clientWidth / element.width * pixelRatio),\n            y: y / (element.clientHeight / element.height * pixelRatio)\n        };\n    };\n\n})();\n\n\n;   // End src/core/Mouse.js\n\n\n// Begin src/core/Runner.js\n\n/**\n* The `Matter.Runner` module is an optional utility which provides a game loop,\n* that handles updating and rendering a `Matter.Engine` for you within a browser.\n* Note that the method `Engine.run` is an alias for `Runner.run`.\n*\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class Runner\n*/\n\nvar Runner = {};\n\n(function() {\n\n    var _fps = 60,\n        _deltaSampleSize = _fps,\n        _delta = 1000 / _fps;\n\n    var _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame\n                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame\n                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, _delta); };\n\n    var _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame\n                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n\n    /**\n     * Provides a basic game loop that handles updating the engine for you.\n     * Calls `Engine.update` and `Engine.render` on the `requestAnimationFrame` event automatically.\n     * Handles time correction and non-fixed dynamic timing (if enabled).\n     * Triggers `beforeTick`, `tick` and `afterTick` events.\n     * @method run\n     * @param {engine} engine\n     */\n    Runner.run = function(engine) {\n        var counterTimestamp = 0,\n            frameCounter = 0,\n            deltaHistory = [],\n            timePrev,\n            timeScalePrev = 1;\n\n        (function render(time){\n            var timing = engine.timing,\n                delta,\n                correction = 1;\n\n            timing.frameRequestId = _requestAnimationFrame(render);\n\n            if (!engine.enabled)\n                return;\n\n            // create an event object\n            var event = {\n                timestamp: time\n            };\n\n            Events.trigger(engine, 'beforeTick', event);\n\n            if (timing.isFixed) {\n                // fixed timestep\n                delta = timing.delta;\n            } else {\n                // dynamic timestep based on wall clock between calls\n                delta = (time - timePrev) || timing.delta;\n                timePrev = time;\n\n                // optimistically filter delta over a few frames, to improve stability\n                deltaHistory.push(delta);\n                deltaHistory = deltaHistory.slice(-_deltaSampleSize);\n                delta = Math.min.apply(null, deltaHistory);\n\n                // limit delta\n                delta = delta < timing.deltaMin ? timing.deltaMin : delta;\n                delta = delta > timing.deltaMax ? timing.deltaMax : delta;\n\n                // time correction for delta\n                correction = delta / timing.delta;\n\n                // update engine timing object\n                timing.delta = delta;\n            }\n\n            // time correction for time scaling\n            if (timeScalePrev !== 0)\n                correction *= timing.timeScale / timeScalePrev;\n\n            if (timing.timeScale === 0)\n                correction = 0;\n\n            timeScalePrev = timing.timeScale;\n\n            // fps counter\n            frameCounter += 1;\n            if (time - counterTimestamp >= 1000) {\n                timing.fps = frameCounter * ((time - counterTimestamp) / 1000);\n                counterTimestamp = time;\n                frameCounter = 0;\n            }\n\n            Events.trigger(engine, 'tick', event);\n\n            // if world has been modified, clear the render scene graph\n            if (engine.world.isModified && engine.render.controller.clear)\n                engine.render.controller.clear(engine.render);\n\n            // update\n            Engine.update(engine, delta, correction);\n\n            // render\n            Engine.render(engine);\n\n            Events.trigger(engine, 'afterTick', event);\n        })();\n    };\n\n    /**\n     * Ends execution of `Runner.run` on the given `engine`, by canceling the animation frame request event loop.\n     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.\n     * @method stop\n     * @param {engine} engine\n     */\n    Runner.stop = function(engine) {\n        _cancelAnimationFrame(engine.timing.frameRequestId);\n    };\n\n})();\n\n\n;   // End src/core/Runner.js\n\n\n// Begin src/core/Sleeping.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Sleeping\n*/\n\nvar Sleeping = {};\n\n(function() {\n\n    Sleeping._motionWakeThreshold = 0.18;\n    Sleeping._motionSleepThreshold = 0.08;\n    Sleeping._minBias = 0.9;\n\n    /**\n     * Puts bodies to sleep or wakes them up depending on their motion.\n     * @method update\n     * @param {body[]} bodies\n     * @param {number} timeScale\n     */\n    Sleeping.update = function(bodies, timeScale) {\n        var timeFactor = timeScale * timeScale * timeScale;\n\n        // update bodies sleeping status\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;\n\n            // wake up bodies if they have a force applied\n            if (body.force.x > 0 || body.force.y > 0) {\n                Sleeping.set(body, false);\n                continue;\n            }\n\n            var minMotion = Math.min(body.motion, motion),\n                maxMotion = Math.max(body.motion, motion);\n\n            // biased average motion estimation between frames\n            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\n\n            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {\n                body.sleepCounter += 1;\n\n                if (body.sleepCounter >= body.sleepThreshold)\n                    Sleeping.set(body, true);\n            } else if (body.sleepCounter > 0) {\n                body.sleepCounter -= 1;\n            }\n        }\n    };\n\n    /**\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\n     * @method afterCollisions\n     * @param {pair[]} pairs\n     * @param {number} timeScale\n     */\n    Sleeping.afterCollisions = function(pairs, timeScale) {\n        var timeFactor = timeScale * timeScale * timeScale;\n\n        // wake up bodies involved in collisions\n        for (var i = 0; i < pairs.length; i++) {\n            var pair = pairs[i];\n\n            // don't wake inactive pairs\n            if (!pair.isActive)\n                continue;\n\n            var collision = pair.collision,\n                bodyA = collision.bodyA,\n                bodyB = collision.bodyB;\n\n            // don't wake if at least one body is static\n            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)\n                continue;\n\n            if (bodyA.isSleeping || bodyB.isSleeping) {\n                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,\n                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;\n\n                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {\n                    Sleeping.set(sleepingBody, false);\n                }\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @method set\n     * @param {body} body\n     * @param {boolean} isSleeping\n     */\n    Sleeping.set = function(body, isSleeping) {\n        if (isSleeping) {\n            body.isSleeping = true;\n            body.sleepCounter = body.sleepThreshold;\n\n            body.positionImpulse.x = 0;\n            body.positionImpulse.y = 0;\n\n            body.positionPrev.x = body.position.x;\n            body.positionPrev.y = body.position.y;\n\n            body.anglePrev = body.angle;\n            body.speed = 0;\n            body.angularSpeed = 0;\n            body.motion = 0;\n        } else {\n            body.isSleeping = false;\n            body.sleepCounter = 0;\n        }\n    };\n\n})();\n\n;   // End src/core/Sleeping.js\n\n\n// Begin src/factory/Bodies.js\n\n/**\n* The `Matter.Bodies` module contains factory methods for creating rigid body models\n* with commonly used body configurations (such as rectangles, circles and other polygons).\n*\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class Bodies\n*/\n\n// TODO: true circle bodies\n\nvar Bodies = {};\n\n(function() {\n\n    /**\n     * Creates a new rigid body model with a rectangle hull.\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method rectangle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {object} [options]\n     * @return {body} A new rectangle body\n     */\n    Bodies.rectangle = function(x, y, width, height, options) {\n        options = options || {};\n\n        var rectangle = {\n            label: 'Rectangle Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius,\n                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, rectangle, options));\n    };\n\n    /**\n     * Creates a new rigid body model with a trapezoid hull.\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method trapezoid\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} slope\n     * @param {object} [options]\n     * @return {body} A new trapezoid body\n     */\n    Bodies.trapezoid = function(x, y, width, height, slope, options) {\n        options = options || {};\n\n        slope *= 0.5;\n        var roof = (1 - (slope * 2)) * width;\n\n        var x1 = width * slope,\n            x2 = x1 + roof,\n            x3 = x2 + x1;\n\n        var trapezoid = {\n            label: 'Trapezoid Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath('L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0')\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius,\n                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, trapezoid, options));\n    };\n\n    /**\n     * Creates a new rigid body model with a circle hull.\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method circle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {object} [options]\n     * @param {number} maxSides\n     * @return {body} A new circle body\n     */\n    Bodies.circle = function(x, y, radius, options, maxSides) {\n        options = options || {};\n        options.label = 'Circle Body';\n\n        // approximate circles with polygons until true circles implemented in SAT\n\n        maxSides = maxSides || 25;\n        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\n\n        // optimisation: always use even number of sides (half the number of unique axes)\n        if (sides % 2 === 1)\n            sides += 1;\n\n        // flag for better rendering\n        options.circleRadius = radius;\n\n        return Bodies.polygon(x, y, sides, radius, options);\n    };\n\n    /**\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides.\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method polygon\n     * @param {number} x\n     * @param {number} y\n     * @param {number} sides\n     * @param {number} radius\n     * @param {object} [options]\n     * @return {body} A new regular polygon body\n     */\n    Bodies.polygon = function(x, y, sides, radius, options) {\n        options = options || {};\n\n        if (sides < 3)\n            return Bodies.circle(x, y, radius, options);\n\n        var theta = 2 * Math.PI / sides,\n            path = '',\n            offset = theta * 0.5;\n\n        for (var i = 0; i < sides; i += 1) {\n            var angle = offset + (i * theta),\n                xx = Math.cos(angle) * radius,\n                yy = Math.sin(angle) * radius;\n\n            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\n        }\n\n        var polygon = {\n            label: 'Polygon Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath(path)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius,\n                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, polygon, options));\n    };\n\n})();\n\n\n;   // End src/factory/Bodies.js\n\n\n// Begin src/factory/Composites.js\n\n/**\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class Composites\n*/\n\nvar Composites = {};\n\n(function() {\n\n    /**\n     * Description\n     * @method stack\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */\n    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\n        var stack = Composite.create({ label: 'Stack' }),\n            x = xx,\n            y = yy,\n            lastBody,\n            i = 0;\n\n        for (var row = 0; row < rows; row++) {\n            var maxHeight = 0;\n\n            for (var column = 0; column < columns; column++) {\n                var body = callback(x, y, column, row, lastBody, i);\n\n                if (body) {\n                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,\n                        bodyWidth = body.bounds.max.x - body.bounds.min.x;\n\n                    if (bodyHeight > maxHeight)\n                        maxHeight = bodyHeight;\n\n                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });\n\n                    x = body.bounds.max.x + columnGap;\n\n                    Composite.addBody(stack, body);\n\n                    lastBody = body;\n                    i += 1;\n                }\n            }\n\n            y += maxHeight + rowGap;\n            x = xx;\n        }\n\n        return stack;\n    };\n\n    /**\n     * Description\n     * @method chain\n     * @param {composite} composite\n     * @param {number} xOffsetA\n     * @param {number} yOffsetA\n     * @param {number} xOffsetB\n     * @param {number} yOffsetB\n     * @param {object} options\n     * @return {composite} A new composite containing objects chained together with constraints\n     */\n    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\n        var bodies = composite.bodies;\n\n        for (var i = 1; i < bodies.length; i++) {\n            var bodyA = bodies[i - 1],\n                bodyB = bodies[i],\n                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,\n                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x,\n                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,\n                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\n\n            var defaults = {\n                bodyA: bodyA,\n                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },\n                bodyB: bodyB,\n                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }\n            };\n\n            var constraint = Common.extend(defaults, options);\n\n            Composite.addConstraint(composite, Constraint.create(constraint));\n        }\n\n        composite.label += ' Chain';\n\n        return composite;\n    };\n\n    /**\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces\n     * @method mesh\n     * @param {composite} composite\n     * @param {number} columns\n     * @param {number} rows\n     * @param {boolean} crossBrace\n     * @param {object} options\n     * @return {composite} The composite containing objects meshed together with constraints\n     */\n    Composites.mesh = function(composite, columns, rows, crossBrace, options) {\n        var bodies = composite.bodies,\n            row,\n            col,\n            bodyA,\n            bodyB,\n            bodyC;\n\n        for (row = 0; row < rows; row++) {\n            for (col = 0; col < columns; col++) {\n                if (col > 0) {\n                    bodyA = bodies[(col - 1) + (row * columns)];\n                    bodyB = bodies[col + (row * columns)];\n                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\n                }\n            }\n\n            for (col = 0; col < columns; col++) {\n                if (row > 0) {\n                    bodyA = bodies[col + ((row - 1) * columns)];\n                    bodyB = bodies[col + (row * columns)];\n                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\n\n                    if (crossBrace && col > 0) {\n                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\n                    }\n\n                    if (crossBrace && col < columns - 1) {\n                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\n                    }\n                }\n            }\n        }\n\n        composite.label += ' Mesh';\n\n        return composite;\n    };\n\n    /**\n     * Description\n     * @method pyramid\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */\n    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\n        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {\n            var actualRows = Math.min(rows, Math.ceil(columns / 2)),\n                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\n\n            if (row > actualRows)\n                return;\n\n            // reverse row order\n            row = actualRows - row;\n\n            var start = row,\n                end = columns - 1 - row;\n\n            if (column < start || column > end)\n                return;\n\n            // retroactively fix the first body's position, since width was unknown\n            if (i === 1) {\n                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });\n            }\n\n            var xOffset = lastBody ? column * lastBodyWidth : 0;\n\n            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);\n        });\n    };\n\n    /**\n     * Description\n     * @method newtonsCradle\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} number\n     * @param {number} size\n     * @param {number} length\n     * @return {composite} A new composite newtonsCradle body\n     */\n    Composites.newtonsCradle = function(xx, yy, number, size, length) {\n        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });\n\n        for (var i = 0; i < number; i++) {\n            var separation = 1.9,\n                circle = Bodies.circle(xx + i * (size * separation), yy + length, size,\n                            { inertia: 99999, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 0.01 }),\n                constraint = Constraint.create({ pointA: { x: xx + i * (size * separation), y: yy }, bodyB: circle });\n\n            Composite.addBody(newtonsCradle, circle);\n            Composite.addConstraint(newtonsCradle, constraint);\n        }\n\n        return newtonsCradle;\n    };\n\n    /**\n     * Description\n     * @method car\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} width\n     * @param {number} height\n     * @param {number} wheelSize\n     * @return {composite} A new composite car body\n     */\n    Composites.car = function(xx, yy, width, height, wheelSize) {\n        var group = Body.nextGroup(true),\n            wheelBase = -20,\n            wheelAOffset = -width * 0.5 + wheelBase,\n            wheelBOffset = width * 0.5 - wheelBase,\n            wheelYOffset = 0;\n\n        var car = Composite.create({ label: 'Car' }),\n            body = Bodies.trapezoid(xx, yy, width, height, 0.3, {\n                collisionFilter: {\n                    group: group\n                },\n                friction: 0.01,\n                chamfer: {\n                    radius: 10\n                }\n            });\n\n        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {\n            collisionFilter: {\n                group: group\n            },\n            restitution: 0.5,\n            friction: 0.9,\n            density: 0.01\n        });\n\n        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {\n            collisionFilter: {\n                group: group\n            },\n            restitution: 0.5,\n            friction: 0.9,\n            density: 0.01\n        });\n\n        var axelA = Constraint.create({\n            bodyA: body,\n            pointA: { x: wheelAOffset, y: wheelYOffset },\n            bodyB: wheelA,\n            stiffness: 0.5\n        });\n\n        var axelB = Constraint.create({\n            bodyA: body,\n            pointA: { x: wheelBOffset, y: wheelYOffset },\n            bodyB: wheelB,\n            stiffness: 0.5\n        });\n\n        Composite.addBody(car, body);\n        Composite.addBody(car, wheelA);\n        Composite.addBody(car, wheelB);\n        Composite.addConstraint(car, axelA);\n        Composite.addConstraint(car, axelB);\n\n        return car;\n    };\n\n    /**\n     * Creates a simple soft body like object\n     * @method softBody\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {boolean} crossBrace\n     * @param {number} particleRadius\n     * @param {} particleOptions\n     * @param {} constraintOptions\n     * @return {composite} A new composite softBody\n     */\n    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\n        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);\n        constraintOptions = Common.extend({ stiffness: 0.4 }, constraintOptions);\n\n        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {\n            return Bodies.circle(x, y, particleRadius, particleOptions);\n        });\n\n        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\n\n        softBody.label = 'Soft Body';\n\n        return softBody;\n    };\n\n})();\n\n\n;   // End src/factory/Composites.js\n\n\n// Begin src/geometry/Axes.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Axes\n*/\n\nvar Axes = {};\n\n(function() {\n\n    /**\n     * Description\n     * @method fromVertices\n     * @param {vertices} vertices\n     * @return {axes} A new axes from the given vertices\n     */\n    Axes.fromVertices = function(vertices) {\n        var axes = {};\n\n        // find the unique axes, using edge normal gradients\n        for (var i = 0; i < vertices.length; i++) {\n            var j = (i + 1) % vertices.length,\n                normal = Vector.normalise({\n                    x: vertices[j].y - vertices[i].y,\n                    y: vertices[i].x - vertices[j].x\n                }),\n                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);\n\n            // limit precision\n            gradient = gradient.toFixed(3).toString();\n\n            axes[gradient] = normal;\n        }\n\n        return Common.values(axes);\n    };\n\n    /**\n     * Description\n     * @method rotate\n     * @param {axes} axes\n     * @param {number} angle\n     */\n    Axes.rotate = function(axes, angle) {\n        if (angle === 0)\n            return;\n\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n\n        for (var i = 0; i < axes.length; i++) {\n            var axis = axes[i],\n                xx;\n            xx = axis.x * cos - axis.y * sin;\n            axis.y = axis.x * sin + axis.y * cos;\n            axis.x = xx;\n        }\n    };\n\n})();\n\n;   // End src/geometry/Axes.js\n\n\n// Begin src/geometry/Bounds.js\n\n/**\n* _Internal Class_, not generally used outside of the engine's internals.\n*\n* @class Bounds\n*/\n\nvar Bounds = {};\n\n(function() {\n\n    /**\n     * Description\n     * @method create\n     * @param {vertices} vertices\n     * @return {bounds} A new bounds object\n     */\n    Bounds.create = function(vertices) {\n        var bounds = {\n            min: { x: 0, y: 0 },\n            max: { x: 0, y: 0 }\n        };\n\n        if (vertices)\n            Bounds.update(bounds, vertices);\n\n        return bounds;\n    };\n\n    /**\n     * Description\n     * @method update\n     * @param {bounds} bounds\n     * @param {vertices} vertices\n     * @param {vector} velocity\n     */\n    Bounds.update = function(bounds, vertices, velocity) {\n        bounds.min.x = Number.MAX_VALUE;\n        bounds.max.x = Number.MIN_VALUE;\n        bounds.min.y = Number.MAX_VALUE;\n        bounds.max.y = Number.MIN_VALUE;\n\n        for (var i = 0; i < vertices.length; i++) {\n            var vertex = vertices[i];\n            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\n            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\n            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\n            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\n        }\n\n        if (velocity) {\n            if (velocity.x > 0) {\n                bounds.max.x += velocity.x;\n            } else {\n                bounds.min.x += velocity.x;\n            }\n\n            if (velocity.y > 0) {\n                bounds.max.y += velocity.y;\n            } else {\n                bounds.min.y += velocity.y;\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @method contains\n     * @param {bounds} bounds\n     * @param {vector} point\n     * @return {boolean} True if the bounds contain the point, otherwise false\n     */\n    Bounds.contains = function(bounds, point) {\n        return point.x >= bounds.min.x && point.x <= bounds.max.x\n               && point.y >= bounds.min.y && point.y <= bounds.max.y;\n    };\n\n    /**\n     * Description\n     * @method overlaps\n     * @param {bounds} boundsA\n     * @param {bounds} boundsB\n     * @return {boolean} True if the bounds overlap, otherwise false\n     */\n    Bounds.overlaps = function(boundsA, boundsB) {\n        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x\n                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);\n    };\n\n    /**\n     * Translates the bounds by the given vector\n     * @method translate\n     * @param {bounds} bounds\n     * @param {vector} vector\n     */\n    Bounds.translate = function(bounds, vector) {\n        bounds.min.x += vector.x;\n        bounds.max.x += vector.x;\n        bounds.min.y += vector.y;\n        bounds.max.y += vector.y;\n    };\n\n    /**\n     * Shifts the bounds to the given position\n     * @method shift\n     * @param {bounds} bounds\n     * @param {vector} position\n     */\n    Bounds.shift = function(bounds, position) {\n        var deltaX = bounds.max.x - bounds.min.x,\n            deltaY = bounds.max.y - bounds.min.y;\n\n        bounds.min.x = position.x;\n        bounds.max.x = position.x + deltaX;\n        bounds.min.y = position.y;\n        bounds.max.y = position.y + deltaY;\n    };\n\n})();\n\n;   // End src/geometry/Bounds.js\n\n\n// Begin src/geometry/Vector.js\n\n/**\n* The `Matter.Vector` module contains methods for creating and manipulating vectors.\n* Vectors are the basis of all the geometry related operations in the engine.\n* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\n*\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class Vector\n*/\n\n// TODO: consider params for reusing vector objects\n\nvar Vector = {};\n\n(function() {\n\n    /**\n     * Returns a new vector with `x` and `y` copied from the given `vector`.\n     * @method clone\n     * @param {vector} vector\n     * @return {vector} A new cloned vector\n     */\n    Vector.clone = function(vector) {\n        return { x: vector.x, y: vector.y };\n    };\n\n    /**\n     * Returns the magnitude (length) of a vector.\n     * @method magnitude\n     * @param {vector} vector\n     * @return {number} The magnitude of the vector\n     */\n    Vector.magnitude = function(vector) {\n        return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));\n    };\n\n    /**\n     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).\n     * @method magnitudeSquared\n     * @param {vector} vector\n     * @return {number} The squared magnitude of the vector\n     */\n    Vector.magnitudeSquared = function(vector) {\n        return (vector.x * vector.x) + (vector.y * vector.y);\n    };\n\n    /**\n     * Rotates the vector about (0, 0) by specified angle.\n     * @method rotate\n     * @param {vector} vector\n     * @param {number} angle\n     * @return {vector} A new vector rotated about (0, 0)\n     */\n    Vector.rotate = function(vector, angle) {\n        var cos = Math.cos(angle), sin = Math.sin(angle);\n        return {\n            x: vector.x * cos - vector.y * sin,\n            y: vector.x * sin + vector.y * cos\n        };\n    };\n\n    /**\n     * Rotates the vector about a specified point by specified angle.\n     * @method rotateAbout\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} point\n     * @return {vector} A new vector rotated about the point\n     */\n    Vector.rotateAbout = function(vector, angle, point) {\n        var cos = Math.cos(angle), sin = Math.sin(angle);\n        return {\n            x: point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin),\n            y: point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos)\n        };\n    };\n\n    /**\n     * Normalises a vector (such that its magnitude is `1`).\n     * @method normalise\n     * @param {vector} vector\n     * @return {vector} A new vector normalised\n     */\n    Vector.normalise = function(vector) {\n        var magnitude = Vector.magnitude(vector);\n        if (magnitude === 0)\n            return { x: 0, y: 0 };\n        return { x: vector.x / magnitude, y: vector.y / magnitude };\n    };\n\n    /**\n     * Returns the dot-product of two vectors.\n     * @method dot\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The dot product of the two vectors\n     */\n    Vector.dot = function(vectorA, vectorB) {\n        return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);\n    };\n\n    /**\n     * Returns the cross-product of two vectors.\n     * @method cross\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The cross product of the two vectors\n     */\n    Vector.cross = function(vectorA, vectorB) {\n        return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);\n    };\n\n    /**\n     * Adds the two vectors.\n     * @method add\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {vector} A new vector of vectorA and vectorB added\n     */\n    Vector.add = function(vectorA, vectorB) {\n        return { x: vectorA.x + vectorB.x, y: vectorA.y + vectorB.y };\n    };\n\n    /**\n     * Subtracts the two vectors.\n     * @method sub\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {vector} A new vector of vectorA and vectorB subtracted\n     */\n    Vector.sub = function(vectorA, vectorB) {\n        return { x: vectorA.x - vectorB.x, y: vectorA.y - vectorB.y };\n    };\n\n    /**\n     * Multiplies a vector and a scalar.\n     * @method mult\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector multiplied by scalar\n     */\n    Vector.mult = function(vector, scalar) {\n        return { x: vector.x * scalar, y: vector.y * scalar };\n    };\n\n    /**\n     * Divides a vector and a scalar.\n     * @method div\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector divided by scalar\n     */\n    Vector.div = function(vector, scalar) {\n        return { x: vector.x / scalar, y: vector.y / scalar };\n    };\n\n    /**\n     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.\n     * @method perp\n     * @param {vector} vector\n     * @param {bool} [negate=false]\n     * @return {vector} The perpendicular vector\n     */\n    Vector.perp = function(vector, negate) {\n        negate = negate === true ? -1 : 1;\n        return { x: negate * -vector.y, y: negate * vector.x };\n    };\n\n    /**\n     * Negates both components of a vector such that it points in the opposite direction.\n     * @method neg\n     * @param {vector} vector\n     * @return {vector} The negated vector\n     */\n    Vector.neg = function(vector) {\n        return { x: -vector.x, y: -vector.y };\n    };\n\n    /**\n     * Returns the angle in radians between the two vectors relative to the x-axis.\n     * @method angle\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The angle in radians\n     */\n    Vector.angle = function(vectorA, vectorB) {\n        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);\n    };\n\n})();\n\n;   // End src/geometry/Vector.js\n\n\n// Begin src/geometry/Vertices.js\n\n/**\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\n*\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class Vertices\n*/\n\n// TODO: convex decomposition - http://mnbayazit.com/406/bayazit\n\nvar Vertices = {};\n\n(function() {\n\n    /**\n     * Creates a new set of `Matter.Body` compatible vertices.\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\n     *\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n     *\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\n     * but with some additional references required for efficient collision detection routines.\n     *\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\n     *\n     * @method create\n     * @param {vector[]} points\n     * @param {body} body\n     */\n    Vertices.create = function(points, body) {\n        var vertices = [];\n\n        for (var i = 0; i < points.length; i++) {\n            var point = points[i],\n                vertex = {};\n\n            vertex.x = point.x;\n            vertex.y = point.y;\n            vertex.index = i;\n            vertex.body = body;\n\n            vertices.push(vertex);\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Parses a _simple_ SVG-style path into a `Matter.Vertices` object for the given `Matter.Body`.\n     * @method fromPath\n     * @param {string} path\n     * @param {body} body\n     * @return {vertices} vertices\n     */\n    Vertices.fromPath = function(path, body) {\n        var pathPattern = /L\\s*([\\-\\d\\.]*)\\s*([\\-\\d\\.]*)/ig,\n            points = [];\n\n        path.replace(pathPattern, function(match, x, y) {\n            points.push({ x: parseFloat(x), y: parseFloat(y) });\n        });\n\n        return Vertices.create(points, body);\n    };\n\n    /**\n     * Returns the centre (centroid) of the set of vertices.\n     * @method centre\n     * @param {vertices} vertices\n     * @return {vector} The centre point\n     */\n    Vertices.centre = function(vertices) {\n        var area = Vertices.area(vertices, true),\n            centre = { x: 0, y: 0 },\n            cross,\n            temp,\n            j;\n\n        for (var i = 0; i < vertices.length; i++) {\n            j = (i + 1) % vertices.length;\n            cross = Vector.cross(vertices[i], vertices[j]);\n            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\n            centre = Vector.add(centre, temp);\n        }\n\n        return Vector.div(centre, 6 * area);\n    };\n\n    /**\n     * Returns the area of the set of vertices.\n     * @method area\n     * @param {vertices} vertices\n     * @param {bool} signed\n     * @return {number} The area\n     */\n    Vertices.area = function(vertices, signed) {\n        var area = 0,\n            j = vertices.length - 1;\n\n        for (var i = 0; i < vertices.length; i++) {\n            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n            j = i;\n        }\n\n        if (signed)\n            return area / 2;\n\n        return Math.abs(area) / 2;\n    };\n\n    /**\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\n     * @method inertia\n     * @param {vertices} vertices\n     * @param {number} mass\n     * @return {number} The polygon's moment of inertia\n     */\n    Vertices.inertia = function(vertices, mass) {\n        var numerator = 0,\n            denominator = 0,\n            v = vertices,\n            cross,\n            j;\n\n        // find the polygon's moment of inertia, using second moment of area\n        // http://www.physicsforums.com/showthread.php?t=25293\n        for (var n = 0; n < v.length; n++) {\n            j = (n + 1) % v.length;\n            cross = Math.abs(Vector.cross(v[j], v[n]));\n            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\n            denominator += cross;\n        }\n\n        return (mass / 6) * (numerator / denominator);\n    };\n\n    /**\n     * Translates the set of vertices in-place.\n     * @method translate\n     * @param {vertices} vertices\n     * @param {vector} vector\n     * @param {number} scalar\n     */\n    Vertices.translate = function(vertices, vector, scalar) {\n        var i;\n        if (scalar) {\n            for (i = 0; i < vertices.length; i++) {\n                vertices[i].x += vector.x * scalar;\n                vertices[i].y += vector.y * scalar;\n            }\n        } else {\n            for (i = 0; i < vertices.length; i++) {\n                vertices[i].x += vector.x;\n                vertices[i].y += vector.y;\n            }\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Rotates the set of vertices in-place.\n     * @method rotate\n     * @param {vertices} vertices\n     * @param {number} angle\n     * @param {vector} point\n     */\n    Vertices.rotate = function(vertices, angle, point) {\n        if (angle === 0)\n            return;\n\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n\n        for (var i = 0; i < vertices.length; i++) {\n            var vertice = vertices[i],\n                dx = vertice.x - point.x,\n                dy = vertice.y - point.y;\n\n            vertice.x = point.x + (dx * cos - dy * sin);\n            vertice.y = point.y + (dx * sin + dy * cos);\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Returns `true` if the `point` is inside the set of `vertices`.\n     * @method contains\n     * @param {vertices} vertices\n     * @param {vector} point\n     * @return {boolean} True if the vertices contains point, otherwise false\n     */\n    Vertices.contains = function(vertices, point) {\n        for (var i = 0; i < vertices.length; i++) {\n            var vertice = vertices[i],\n                nextVertice = vertices[(i + 1) % vertices.length];\n            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Scales the vertices from a point (default is centre) in-place.\n     * @method scale\n     * @param {vertices} vertices\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     */\n    Vertices.scale = function(vertices, scaleX, scaleY, point) {\n        if (scaleX === 1 && scaleY === 1)\n            return vertices;\n\n        point = point || Vertices.centre(vertices);\n\n        var vertex,\n            delta;\n\n        for (var i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            delta = Vector.sub(vertex, point);\n            vertices[i].x = point.x + delta.x * scaleX;\n            vertices[i].y = point.y + delta.y * scaleY;\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\n     * @method chamfer\n     * @param {vertices} vertices\n     * @param {number[]} radius\n     * @param {number} quality\n     * @param {number} qualityMin\n     * @param {number} qualityMax\n     */\n    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {\n        radius = radius || [8];\n\n        if (!radius.length)\n            radius = [radius];\n\n        // quality defaults to -1, which is auto\n        quality = (typeof quality !== 'undefined') ? quality : -1;\n        qualityMin = qualityMin || 2;\n        qualityMax = qualityMax || 14;\n\n        var newVertices = [];\n\n        for (var i = 0; i < vertices.length; i++) {\n            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\n                vertex = vertices[i],\n                nextVertex = vertices[(i + 1) % vertices.length],\n                currentRadius = radius[i < radius.length ? i : radius.length - 1];\n\n            if (currentRadius === 0) {\n                newVertices.push(vertex);\n                continue;\n            }\n\n            var prevNormal = Vector.normalise({\n                x: vertex.y - prevVertex.y,\n                y: prevVertex.x - vertex.x\n            });\n\n            var nextNormal = Vector.normalise({\n                x: nextVertex.y - vertex.y,\n                y: vertex.x - nextVertex.x\n            });\n\n            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\n                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\n                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\n                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\n\n            var precision = quality;\n\n            if (quality === -1) {\n                // automatically decide precision\n                precision = Math.pow(currentRadius, 0.32) * 1.75;\n            }\n\n            precision = Common.clamp(precision, qualityMin, qualityMax);\n\n            // use an even value for precision, more likely to reduce axes by using symmetry\n            if (precision % 2 === 1)\n                precision += 1;\n\n            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\n                theta = alpha / precision;\n\n            for (var j = 0; j < precision; j++) {\n                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\n            }\n        }\n\n        return newVertices;\n    };\n\n})();\n\n\n;   // End src/geometry/Vertices.js\n\n\n// Begin src/render/Render.js\n\n/**\n* The `Matter.Render` module is the default `render.controller` used by a `Matter.Engine`.\n* This renderer is HTML5 canvas based and supports a number of drawing options including sprites and viewports.\n*\n* It is possible develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.\n* A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).\n*\n* See also `Matter.RenderPixi` for an alternate WebGL, scene-graph based renderer.\n*\n* @class Render\n*/\n\nvar Render = {};\n\n(function() {\n\n    /**\n     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {render} A new renderer\n     */\n    Render.create = function(options) {\n        var defaults = {\n            controller: Render,\n            element: null,\n            canvas: null,\n            options: {\n                width: 800,\n                height: 600,\n                pixelRatio: 1,\n                background: '#fafafa',\n                wireframeBackground: '#222',\n                hasBounds: false,\n                enabled: true,\n                wireframes: true,\n                showSleeping: true,\n                showDebug: false,\n                showBroadphase: false,\n                showBounds: false,\n                showVelocity: false,\n                showCollisions: false,\n                showAxes: false,\n                showPositions: false,\n                showAngleIndicator: false,\n                showIds: false,\n                showShadows: false\n            }\n        };\n\n        var render = Common.extend(defaults, options);\n\n        render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);\n        render.context = render.canvas.getContext('2d');\n        render.textures = {};\n\n        render.bounds = render.bounds || {\n            min: {\n                x: 0,\n                y: 0\n            },\n            max: {\n                x: render.options.width,\n                y: render.options.height\n            }\n        };\n\n        if (render.options.pixelRatio !== 1) {\n            Render.setPixelRatio(render, render.options.pixelRatio);\n        }\n\n        if (Common.isElement(render.element)) {\n            render.element.appendChild(render.canvas);\n        } else {\n            Common.log('Render.create: options.element was undefined, render.canvas was created but not appended', 'warn');\n        }\n\n        return render;\n    };\n\n    /**\n     * Sets the pixel ratio of the renderer and updates the canvas.\n     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.\n     * @method setPixelRatio\n     * @param {render} render\n     * @param {number} pixelRatio\n     */\n    Render.setPixelRatio = function(render, pixelRatio) {\n        var options = render.options,\n            canvas = render.canvas;\n\n        if (pixelRatio === 'auto') {\n            pixelRatio = _getPixelRatio(canvas);\n        }\n\n        options.pixelRatio = pixelRatio;\n        canvas.setAttribute('data-pixel-ratio', pixelRatio);\n        canvas.width = options.width * pixelRatio;\n        canvas.height = options.height * pixelRatio;\n        canvas.style.width = options.width + 'px';\n        canvas.style.height = options.height + 'px';\n        render.context.scale(pixelRatio, pixelRatio);\n    };\n\n    /**\n     * Renders the given `engine`'s `Matter.World` object.\n     * This is the entry point for all rendering and should be called every time the scene changes.\n     * @method world\n     * @param {engine} engine\n     */\n    Render.world = function(engine) {\n        var render = engine.render,\n            world = engine.world,\n            canvas = render.canvas,\n            context = render.context,\n            options = render.options,\n            allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world),\n            background = options.wireframes ? options.wireframeBackground : options.background,\n            bodies = [],\n            constraints = [],\n            i;\n\n        // apply background if it has changed\n        if (render.currentBackground !== background)\n            _applyBackground(render, background);\n\n        // clear the canvas with a transparent fill, to allow the canvas background to show\n        context.globalCompositeOperation = 'source-in';\n        context.fillStyle = \"transparent\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n        context.globalCompositeOperation = 'source-over';\n\n        // handle bounds\n        if (options.hasBounds) {\n            var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n                boundsHeight = render.bounds.max.y - render.bounds.min.y,\n                boundsScaleX = boundsWidth / options.width,\n                boundsScaleY = boundsHeight / options.height;\n\n            // filter out bodies that are not in view\n            for (i = 0; i < allBodies.length; i++) {\n                var body = allBodies[i];\n                if (Bounds.overlaps(body.bounds, render.bounds))\n                    bodies.push(body);\n            }\n\n            // filter out constraints that are not in view\n            for (i = 0; i < allConstraints.length; i++) {\n                var constraint = allConstraints[i],\n                    bodyA = constraint.bodyA,\n                    bodyB = constraint.bodyB,\n                    pointAWorld = constraint.pointA,\n                    pointBWorld = constraint.pointB;\n\n                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);\n                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);\n\n                if (!pointAWorld || !pointBWorld)\n                    continue;\n\n                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))\n                    constraints.push(constraint);\n            }\n\n            // transform the view\n            context.scale(1 / boundsScaleX, 1 / boundsScaleY);\n            context.translate(-render.bounds.min.x, -render.bounds.min.y);\n        } else {\n            constraints = allConstraints;\n            bodies = allBodies;\n        }\n\n        if (!options.wireframes || (engine.enableSleeping && options.showSleeping)) {\n            // fully featured rendering of bodies\n            Render.bodies(engine, bodies, context);\n        } else {\n            // optimised method for wireframes only\n            Render.bodyWireframes(engine, bodies, context);\n        }\n\n        if (options.showBounds)\n            Render.bodyBounds(engine, bodies, context);\n\n        if (options.showAxes || options.showAngleIndicator)\n            Render.bodyAxes(engine, bodies, context);\n\n        if (options.showPositions)\n            Render.bodyPositions(engine, bodies, context);\n\n        if (options.showVelocity)\n            Render.bodyVelocity(engine, bodies, context);\n\n        if (options.showIds)\n            Render.bodyIds(engine, bodies, context);\n\n        if (options.showCollisions)\n            Render.collisions(engine, engine.pairs.list, context);\n\n        Render.constraints(constraints, context);\n\n        if (options.showBroadphase && engine.broadphase.controller === Grid)\n            Render.grid(engine, engine.broadphase, context);\n\n        if (options.showDebug)\n            Render.debug(engine, context);\n\n        if (options.hasBounds) {\n            // revert view transforms\n            context.setTransform(options.pixelRatio, 0, 0, options.pixelRatio, 0, 0);\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method debug\n     * @param {engine} engine\n     * @param {RenderingContext} context\n     */\n    Render.debug = function(engine, context) {\n        var c = context,\n            world = engine.world,\n            render = engine.render,\n            options = render.options,\n            bodies = Composite.allBodies(world),\n            space = \"    \";\n\n        if (engine.timing.timestamp - (render.debugTimestamp || 0) >= 500) {\n            var text = \"\";\n            text += \"fps: \" + Math.round(engine.timing.fps) + space;\n\n            if (engine.metrics.extended) {\n                text += \"delta: \" + engine.timing.delta.toFixed(3) + space;\n                text += \"correction: \" + engine.timing.correction.toFixed(3) + space;\n                text += \"bodies: \" + bodies.length + space;\n\n                if (engine.broadphase.controller === Grid)\n                    text += \"buckets: \" + engine.metrics.buckets + space;\n\n                text += \"\\n\";\n\n                text += \"collisions: \" + engine.metrics.collisions + space;\n                text += \"pairs: \" + engine.pairs.list.length + space;\n                text += \"broad: \" + engine.metrics.broadEff + space;\n                text += \"mid: \" + engine.metrics.midEff + space;\n                text += \"narrow: \" + engine.metrics.narrowEff + space;\n            }\n\n            render.debugString = text;\n            render.debugTimestamp = engine.timing.timestamp;\n        }\n\n        if (render.debugString) {\n            c.font = \"12px Arial\";\n\n            if (options.wireframes) {\n                c.fillStyle = 'rgba(255,255,255,0.5)';\n            } else {\n                c.fillStyle = 'rgba(0,0,0,0.5)';\n            }\n\n            var split = render.debugString.split('\\n');\n\n            for (var i = 0; i < split.length; i++) {\n                c.fillText(split[i], 50, 50 + i * 18);\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method constraints\n     * @param {constraint[]} constraints\n     * @param {RenderingContext} context\n     */\n    Render.constraints = function(constraints, context) {\n        var c = context;\n\n        for (var i = 0; i < constraints.length; i++) {\n            var constraint = constraints[i];\n\n            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)\n                continue;\n\n            var bodyA = constraint.bodyA,\n                bodyB = constraint.bodyB;\n\n            if (bodyA) {\n                c.beginPath();\n                c.moveTo(bodyA.position.x + constraint.pointA.x, bodyA.position.y + constraint.pointA.y);\n            } else {\n                c.beginPath();\n                c.moveTo(constraint.pointA.x, constraint.pointA.y);\n            }\n\n            if (bodyB) {\n                c.lineTo(bodyB.position.x + constraint.pointB.x, bodyB.position.y + constraint.pointB.y);\n            } else {\n                c.lineTo(constraint.pointB.x, constraint.pointB.y);\n            }\n\n            c.lineWidth = constraint.render.lineWidth;\n            c.strokeStyle = constraint.render.strokeStyle;\n            c.stroke();\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method bodyShadows\n     * @param {engine} engine\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyShadows = function(engine, bodies, context) {\n        var c = context,\n            render = engine.render;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            if (body.circleRadius) {\n                c.beginPath();\n                c.arc(body.position.x, body.position.y, body.circleRadius, 0, 2 * Math.PI);\n                c.closePath();\n            } else {\n                c.beginPath();\n                c.moveTo(body.vertices[0].x, body.vertices[0].y);\n                for (var j = 1; j < body.vertices.length; j++) {\n                    c.lineTo(body.vertices[j].x, body.vertices[j].y);\n                }\n                c.closePath();\n            }\n\n            var distanceX = body.position.x - render.options.width * 0.5,\n                distanceY = body.position.y - render.options.height * 0.2,\n                distance = Math.abs(distanceX) + Math.abs(distanceY);\n\n            c.shadowColor = 'rgba(0,0,0,0.15)';\n            c.shadowOffsetX = 0.05 * distanceX;\n            c.shadowOffsetY = 0.05 * distanceY;\n            c.shadowBlur = 1 + 12 * Math.min(1, distance / 1000);\n\n            c.fill();\n\n            c.shadowColor = null;\n            c.shadowOffsetX = null;\n            c.shadowOffsetY = null;\n            c.shadowBlur = null;\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method bodies\n     * @param {engine} engine\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodies = function(engine, bodies, context) {\n        var c = context,\n            render = engine.render,\n            options = render.options,\n            i;\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            if (body.render.sprite && body.render.sprite.texture && !options.wireframes) {\n                // body sprite\n                var sprite = body.render.sprite,\n                    texture = _getTexture(render, sprite.texture);\n\n                if (options.showSleeping && body.isSleeping)\n                    c.globalAlpha = 0.5;\n\n                c.translate(body.position.x, body.position.y);\n                c.rotate(body.angle);\n\n                c.drawImage(texture, texture.width * -0.5 * sprite.xScale, texture.height * -0.5 * sprite.yScale,\n                            texture.width * sprite.xScale, texture.height * sprite.yScale);\n\n                // revert translation, hopefully faster than save / restore\n                c.rotate(-body.angle);\n                c.translate(-body.position.x, -body.position.y);\n\n                if (options.showSleeping && body.isSleeping)\n                    c.globalAlpha = 1;\n            } else {\n                // body polygon\n                if (body.circleRadius) {\n                    c.beginPath();\n                    c.arc(body.position.x, body.position.y, body.circleRadius, 0, 2 * Math.PI);\n                } else {\n                    c.beginPath();\n                    c.moveTo(body.vertices[0].x, body.vertices[0].y);\n                    for (var j = 1; j < body.vertices.length; j++) {\n                        c.lineTo(body.vertices[j].x, body.vertices[j].y);\n                    }\n                    c.closePath();\n                }\n\n                if (!options.wireframes) {\n                    if (options.showSleeping && body.isSleeping) {\n                        c.fillStyle = Common.shadeColor(body.render.fillStyle, 50);\n                    } else {\n                        c.fillStyle = body.render.fillStyle;\n                    }\n\n                    c.lineWidth = body.render.lineWidth;\n                    c.strokeStyle = body.render.strokeStyle;\n                    c.fill();\n                    c.stroke();\n                } else {\n                    c.lineWidth = 1;\n                    c.strokeStyle = '#bbb';\n                    if (options.showSleeping && body.isSleeping)\n                        c.strokeStyle = 'rgba(255,255,255,0.2)';\n                    c.stroke();\n                }\n            }\n        }\n\n    };\n\n    /**\n     * Optimised method for drawing body wireframes in one pass\n     * @private\n     * @method bodyWireframes\n     * @param {engine} engine\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyWireframes = function(engine, bodies, context) {\n        var c = context,\n            i,\n            j;\n\n        c.beginPath();\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            c.moveTo(body.vertices[0].x, body.vertices[0].y);\n\n            for (j = 1; j < body.vertices.length; j++) {\n                c.lineTo(body.vertices[j].x, body.vertices[j].y);\n            }\n\n            c.lineTo(body.vertices[0].x, body.vertices[0].y);\n        }\n\n        c.lineWidth = 1;\n        c.strokeStyle = '#bbb';\n        c.stroke();\n    };\n\n    /**\n     * Draws body bounds\n     * @private\n     * @method bodyBounds\n     * @param {engine} engine\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyBounds = function(engine, bodies, context) {\n        var c = context,\n            render = engine.render,\n            options = render.options;\n\n        c.beginPath();\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.render.visible)\n                c.rect(body.bounds.min.x, body.bounds.min.y, body.bounds.max.x - body.bounds.min.x, body.bounds.max.y - body.bounds.min.y);\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,255,255,0.08)';\n        } else {\n            c.strokeStyle = 'rgba(0,0,0,0.1)';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Draws body angle indicators and axes\n     * @private\n     * @method bodyAxes\n     * @param {engine} engine\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyAxes = function(engine, bodies, context) {\n        var c = context,\n            render = engine.render,\n            options = render.options,\n            i,\n            j;\n\n        c.beginPath();\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            if (options.showAxes) {\n                // render all axes\n                for (j = 0; j < body.axes.length; j++) {\n                    var axis = body.axes[j];\n                    c.moveTo(body.position.x, body.position.y);\n                    c.lineTo(body.position.x + axis.x * 20, body.position.y + axis.y * 20);\n                }\n            } else {\n                // render a single axis indicator\n                c.moveTo(body.position.x, body.position.y);\n                c.lineTo((body.vertices[0].x + body.vertices[body.vertices.length-1].x) / 2,\n                         (body.vertices[0].y + body.vertices[body.vertices.length-1].y) / 2);\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'indianred';\n        } else {\n            c.strokeStyle = 'rgba(0,0,0,0.3)';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Draws body positions\n     * @private\n     * @method bodyPositions\n     * @param {engine} engine\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyPositions = function(engine, bodies, context) {\n        var c = context,\n            render = engine.render,\n            options = render.options,\n            body,\n            i;\n\n        c.beginPath();\n\n        // render current positions\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (body.render.visible) {\n                c.arc(body.position.x, body.position.y, 3, 0, 2 * Math.PI, false);\n                c.closePath();\n            }\n        }\n\n        if (options.wireframes) {\n            c.fillStyle = 'indianred';\n        } else {\n            c.fillStyle = 'rgba(0,0,0,0.5)';\n        }\n        c.fill();\n\n        c.beginPath();\n\n        // render previous positions\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (body.render.visible) {\n                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);\n                c.closePath();\n            }\n        }\n\n        c.fillStyle = 'rgba(255,165,0,0.8)';\n        c.fill();\n    };\n\n    /**\n     * Draws body velocity\n     * @private\n     * @method bodyVelocity\n     * @param {engine} engine\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyVelocity = function(engine, bodies, context) {\n        var c = context;\n\n        c.beginPath();\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            c.moveTo(body.position.x, body.position.y);\n            c.lineTo(body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);\n        }\n\n        c.lineWidth = 3;\n        c.strokeStyle = 'cornflowerblue';\n        c.stroke();\n    };\n\n    /**\n     * Draws body ids\n     * @private\n     * @method bodyIds\n     * @param {engine} engine\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyIds = function(engine, bodies, context) {\n        var c = context;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            c.font = \"12px Arial\";\n            c.fillStyle = 'rgba(255,255,255,0.5)';\n            c.fillText(body.id, body.position.x + 10, body.position.y - 10);\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method collisions\n     * @param {engine} engine\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */\n    Render.collisions = function(engine, pairs, context) {\n        var c = context,\n            options = engine.render.options,\n            pair,\n            collision,\n            i,\n            j;\n\n        c.beginPath();\n\n        // render collision positions\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            collision = pair.collision;\n            for (j = 0; j < pair.activeContacts.length; j++) {\n                var contact = pair.activeContacts[j],\n                    vertex = contact.vertex;\n                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);\n            }\n        }\n\n        if (options.wireframes) {\n            c.fillStyle = 'rgba(255,255,255,0.7)';\n        } else {\n            c.fillStyle = 'orange';\n        }\n        c.fill();\n\n        c.beginPath();\n\n        // render collision normals\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            collision = pair.collision;\n\n            if (pair.activeContacts.length > 0) {\n                var normalPosX = pair.activeContacts[0].vertex.x,\n                    normalPosY = pair.activeContacts[0].vertex.y;\n\n                if (pair.activeContacts.length === 2) {\n                    normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;\n                    normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;\n                }\n\n                c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);\n                c.lineTo(normalPosX, normalPosY);\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.7)';\n        } else {\n            c.strokeStyle = 'orange';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method grid\n     * @param {engine} engine\n     * @param {grid} grid\n     * @param {RenderingContext} context\n     */\n    Render.grid = function(engine, grid, context) {\n        var c = context,\n            options = engine.render.options;\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,180,0,0.1)';\n        } else {\n            c.strokeStyle = 'rgba(255,180,0,0.5)';\n        }\n\n        c.beginPath();\n\n        var bucketKeys = Common.keys(grid.buckets);\n\n        for (var i = 0; i < bucketKeys.length; i++) {\n            var bucketId = bucketKeys[i];\n\n            if (grid.buckets[bucketId].length < 2)\n                continue;\n\n            var region = bucketId.split(',');\n            c.rect(0.5 + parseInt(region[0], 10) * grid.bucketWidth,\n                    0.5 + parseInt(region[1], 10) * grid.bucketHeight,\n                    grid.bucketWidth,\n                    grid.bucketHeight);\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method inspector\n     * @param {inspector} inspector\n     * @param {RenderingContext} context\n     */\n    Render.inspector = function(inspector, context) {\n        var engine = inspector.engine,\n            selected = inspector.selected,\n            render = engine.render,\n            options = render.options,\n            bounds;\n\n        if (options.hasBounds) {\n            var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n                boundsHeight = render.bounds.max.y - render.bounds.min.y,\n                boundsScaleX = boundsWidth / render.options.width,\n                boundsScaleY = boundsHeight / render.options.height;\n\n            context.scale(1 / boundsScaleX, 1 / boundsScaleY);\n            context.translate(-render.bounds.min.x, -render.bounds.min.y);\n        }\n\n        for (var i = 0; i < selected.length; i++) {\n            var item = selected[i].data;\n\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.9)';\n            context.setLineDash([1,2]);\n\n            switch (item.type) {\n\n            case 'body':\n\n                // render body selections\n                bounds = item.bounds;\n                context.beginPath();\n                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3),\n                             Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));\n                context.closePath();\n                context.stroke();\n\n                break;\n\n            case 'constraint':\n\n                // render constraint selections\n                var point = item.pointA;\n                if (item.bodyA)\n                    point = item.pointB;\n                context.beginPath();\n                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);\n                context.closePath();\n                context.stroke();\n\n                break;\n\n            }\n\n            context.setLineDash([0]);\n            context.translate(-0.5, -0.5);\n        }\n\n        // render selection region\n        if (inspector.selectStart !== null) {\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.6)';\n            context.fillStyle = 'rgba(255,165,0,0.1)';\n            bounds = inspector.selectBounds;\n            context.beginPath();\n            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y),\n                         Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));\n            context.closePath();\n            context.stroke();\n            context.fill();\n            context.translate(-0.5, -0.5);\n        }\n\n        if (options.hasBounds)\n            context.setTransform(1, 0, 0, 1, 0, 0);\n    };\n\n    /**\n     * Description\n     * @method _createCanvas\n     * @private\n     * @param {} width\n     * @param {} height\n     * @return canvas\n     */\n    var _createCanvas = function(width, height) {\n        var canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        canvas.oncontextmenu = function() { return false; };\n        canvas.onselectstart = function() { return false; };\n        return canvas;\n    };\n\n    /**\n     * Gets the pixel ratio of the canvas.\n     * @method _getPixelRatio\n     * @private\n     * @param {HTMLElement} canvas\n     * @return {Number} pixel ratio\n     */\n    var _getPixelRatio = function(canvas) {\n        var context = canvas.getContext('2d'),\n            devicePixelRatio = window.devicePixelRatio || 1,\n            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio\n                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio\n                                      || context.backingStorePixelRatio || 1;\n\n        return devicePixelRatio / backingStorePixelRatio;\n    };\n\n    /**\n     * Gets the requested texture (an Image) via its path\n     * @method _getTexture\n     * @private\n     * @param {render} render\n     * @param {string} imagePath\n     * @return {Image} texture\n     */\n    var _getTexture = function(render, imagePath) {\n        var image = render.textures[imagePath];\n\n        if (image)\n            return image;\n\n        image = render.textures[imagePath] = new Image();\n        image.src = imagePath;\n\n        return image;\n    };\n\n    /**\n     * Applies the background to the canvas using CSS.\n     * @method applyBackground\n     * @private\n     * @param {render} render\n     * @param {string} background\n     */\n    var _applyBackground = function(render, background) {\n        var cssBackground = background;\n\n        if (/(jpg|gif|png)$/.test(background))\n            cssBackground = 'url(' + background + ')';\n\n        render.canvas.style.background = cssBackground;\n        render.canvas.style.backgroundSize = \"contain\";\n        render.currentBackground = background;\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A back-reference to the `Matter.Render` module.\n     *\n     * @property controller\n     * @type render\n     */\n\n    /**\n     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)\n     *\n     * @property element\n     * @type HTMLElement\n     * @default null\n     */\n\n    /**\n     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     * @default null\n     */\n\n    /**\n     * The configuration options of the renderer.\n     *\n     * @property options\n     * @type {}\n     */\n\n    /**\n     * The target width in pixels of the `render.canvas` to be created.\n     *\n     * @property options.width\n     * @type number\n     * @default 800\n     */\n\n    /**\n     * The target height in pixels of the `render.canvas` to be created.\n     *\n     * @property options.height\n     * @type number\n     * @default 600\n     */\n\n    /**\n     * A flag that specifies if `render.bounds` should be used when rendering.\n     *\n     * @property options.hasBounds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A `Bounds` object that specifies the drawing view region.\n     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).\n     * This allows for creating views that can pan or zoom around the scene.\n     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.\n     *\n     * @property bounds\n     * @type bounds\n     */\n\n    /**\n     * The 2d rendering context from the `render.canvas` element.\n     *\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n\n    /**\n     * The sprite texture cache.\n     *\n     * @property textures\n     * @type {}\n     */\n\n})();\n\n\n;   // End src/render/Render.js\n\n\n// Begin src/render/RenderPixi.js\n\n/**\n* See [Demo.js](https://github.com/liabru/matter-js/blob/master/demo/js/Demo.js)\n* and [DemoMobile.js](https://github.com/liabru/matter-js/blob/master/demo/js/DemoMobile.js) for usage examples.\n*\n* @class RenderPixi\n*/\n\nvar RenderPixi = {};\n\n(function() {\n\n    /**\n     * Creates a new Pixi.js WebGL renderer\n     * @method create\n     * @param {object} options\n     * @return {RenderPixi} A new renderer\n     */\n    RenderPixi.create = function(options) {\n        var defaults = {\n            controller: RenderPixi,\n            element: null,\n            canvas: null,\n            options: {\n                width: 800,\n                height: 600,\n                background: '#fafafa',\n                wireframeBackground: '#222',\n                hasBounds: false,\n                enabled: true,\n                wireframes: true,\n                showSleeping: true,\n                showDebug: false,\n                showBroadphase: false,\n                showBounds: false,\n                showVelocity: false,\n                showCollisions: false,\n                showAxes: false,\n                showPositions: false,\n                showAngleIndicator: false,\n                showIds: false,\n                showShadows: false\n            }\n        };\n\n        var render = Common.extend(defaults, options),\n            transparent = !render.options.wireframes && render.options.background === 'transparent';\n\n        // init pixi\n        render.context = new PIXI.WebGLRenderer(render.options.width, render.options.height, render.canvas, transparent, true);\n        render.canvas = render.context.view;\n        render.container = new PIXI.DisplayObjectContainer();\n        render.stage = new PIXI.Stage();\n        render.stage.addChild(render.container);\n        render.bounds = render.bounds || {\n            min: {\n                x: 0,\n                y: 0\n            },\n            max: {\n                x: render.options.width,\n                y: render.options.height\n            }\n        };\n\n        // caches\n        render.textures = {};\n        render.sprites = {};\n        render.primitives = {};\n\n        // use a sprite batch for performance\n        render.spriteBatch = new PIXI.SpriteBatch();\n        render.container.addChild(render.spriteBatch);\n\n        // insert canvas\n        if (Common.isElement(render.element)) {\n            render.element.appendChild(render.canvas);\n        } else {\n            Common.log('No \"render.element\" passed, \"render.canvas\" was not inserted into document.', 'warn');\n        }\n\n        // prevent menus on canvas\n        render.canvas.oncontextmenu = function() { return false; };\n        render.canvas.onselectstart = function() { return false; };\n\n        return render;\n    };\n\n    /**\n     * Clears the scene graph\n     * @method clear\n     * @param {RenderPixi} render\n     */\n    RenderPixi.clear = function(render) {\n        var container = render.container,\n            spriteBatch = render.spriteBatch;\n\n        // clear stage container\n        while (container.children[0]) {\n            container.removeChild(container.children[0]);\n        }\n\n        // clear sprite batch\n        while (spriteBatch.children[0]) {\n            spriteBatch.removeChild(spriteBatch.children[0]);\n        }\n\n        var bgSprite = render.sprites['bg-0'];\n\n        // clear caches\n        render.textures = {};\n        render.sprites = {};\n        render.primitives = {};\n\n        // set background sprite\n        render.sprites['bg-0'] = bgSprite;\n        if (bgSprite)\n            spriteBatch.addChildAt(bgSprite, 0);\n\n        // add sprite batch back into container\n        render.container.addChild(render.spriteBatch);\n\n        // reset background state\n        render.currentBackground = null;\n\n        // reset bounds transforms\n        container.scale.set(1, 1);\n        container.position.set(0, 0);\n    };\n\n    /**\n     * Sets the background of the canvas\n     * @method setBackground\n     * @param {RenderPixi} render\n     * @param {string} background\n     */\n    RenderPixi.setBackground = function(render, background) {\n        if (render.currentBackground !== background) {\n            var isColor = background.indexOf && background.indexOf('#') !== -1,\n                bgSprite = render.sprites['bg-0'];\n\n            if (isColor) {\n                // if solid background color\n                var color = Common.colorToNumber(background);\n                render.stage.setBackgroundColor(color);\n\n                // remove background sprite if existing\n                if (bgSprite)\n                    render.spriteBatch.removeChild(bgSprite);\n            } else {\n                // initialise background sprite if needed\n                if (!bgSprite) {\n                    var texture = _getTexture(render, background);\n\n                    bgSprite = render.sprites['bg-0'] = new PIXI.Sprite(texture);\n                    bgSprite.position.x = 0;\n                    bgSprite.position.y = 0;\n                    render.spriteBatch.addChildAt(bgSprite, 0);\n                }\n            }\n\n            render.currentBackground = background;\n        }\n    };\n\n    /**\n     * Description\n     * @method world\n     * @param {engine} engine\n     */\n    RenderPixi.world = function(engine) {\n        var render = engine.render,\n            world = engine.world,\n            context = render.context,\n            stage = render.stage,\n            container = render.container,\n            options = render.options,\n            bodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world),\n            constraints = [],\n            i;\n\n        if (options.wireframes) {\n            RenderPixi.setBackground(render, options.wireframeBackground);\n        } else {\n            RenderPixi.setBackground(render, options.background);\n        }\n\n        // handle bounds\n        var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n            boundsHeight = render.bounds.max.y - render.bounds.min.y,\n            boundsScaleX = boundsWidth / render.options.width,\n            boundsScaleY = boundsHeight / render.options.height;\n\n        if (options.hasBounds) {\n            // Hide bodies that are not in view\n            for (i = 0; i < bodies.length; i++) {\n                var body = bodies[i];\n                body.render.sprite.visible = Bounds.overlaps(body.bounds, render.bounds);\n            }\n\n            // filter out constraints that are not in view\n            for (i = 0; i < allConstraints.length; i++) {\n                var constraint = allConstraints[i],\n                    bodyA = constraint.bodyA,\n                    bodyB = constraint.bodyB,\n                    pointAWorld = constraint.pointA,\n                    pointBWorld = constraint.pointB;\n\n                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);\n                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);\n\n                if (!pointAWorld || !pointBWorld)\n                    continue;\n\n                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))\n                    constraints.push(constraint);\n            }\n\n            // transform the view\n            container.scale.set(1 / boundsScaleX, 1 / boundsScaleY);\n            container.position.set(-render.bounds.min.x * (1 / boundsScaleX), -render.bounds.min.y * (1 / boundsScaleY));\n        } else {\n            constraints = allConstraints;\n        }\n\n        for (i = 0; i < bodies.length; i++)\n            RenderPixi.body(engine, bodies[i]);\n\n        for (i = 0; i < constraints.length; i++)\n            RenderPixi.constraint(engine, constraints[i]);\n\n        context.render(stage);\n    };\n\n\n    /**\n     * Description\n     * @method constraint\n     * @param {engine} engine\n     * @param {constraint} constraint\n     */\n    RenderPixi.constraint = function(engine, constraint) {\n        var render = engine.render,\n            bodyA = constraint.bodyA,\n            bodyB = constraint.bodyB,\n            pointA = constraint.pointA,\n            pointB = constraint.pointB,\n            container = render.container,\n            constraintRender = constraint.render,\n            primitiveId = 'c-' + constraint.id,\n            primitive = render.primitives[primitiveId];\n\n        // initialise constraint primitive if not existing\n        if (!primitive)\n            primitive = render.primitives[primitiveId] = new PIXI.Graphics();\n\n        // don't render if constraint does not have two end points\n        if (!constraintRender.visible || !constraint.pointA || !constraint.pointB) {\n            primitive.clear();\n            return;\n        }\n\n        // add to scene graph if not already there\n        if (Common.indexOf(container.children, primitive) === -1)\n            container.addChild(primitive);\n\n        // render the constraint on every update, since they can change dynamically\n        primitive.clear();\n        primitive.beginFill(0, 0);\n        primitive.lineStyle(constraintRender.lineWidth, Common.colorToNumber(constraintRender.strokeStyle), 1);\n\n        if (bodyA) {\n            primitive.moveTo(bodyA.position.x + pointA.x, bodyA.position.y + pointA.y);\n        } else {\n            primitive.moveTo(pointA.x, pointA.y);\n        }\n\n        if (bodyB) {\n            primitive.lineTo(bodyB.position.x + pointB.x, bodyB.position.y + pointB.y);\n        } else {\n            primitive.lineTo(pointB.x, pointB.y);\n        }\n\n        primitive.endFill();\n    };\n\n    /**\n     * Description\n     * @method body\n     * @param {engine} engine\n     * @param {body} body\n     */\n    RenderPixi.body = function(engine, body) {\n        var render = engine.render,\n            bodyRender = body.render;\n\n        if (!bodyRender.visible)\n            return;\n\n        if (bodyRender.sprite && bodyRender.sprite.texture) {\n            var spriteId = 'b-' + body.id,\n                sprite = render.sprites[spriteId],\n                spriteBatch = render.spriteBatch;\n\n            // initialise body sprite if not existing\n            if (!sprite)\n                sprite = render.sprites[spriteId] = _createBodySprite(render, body);\n\n            // add to scene graph if not already there\n            if (Common.indexOf(spriteBatch.children, sprite) === -1)\n                spriteBatch.addChild(sprite);\n\n            // update body sprite\n            sprite.position.x = body.position.x;\n            sprite.position.y = body.position.y;\n            sprite.rotation = body.angle;\n            sprite.scale.x = bodyRender.sprite.xScale || 1;\n            sprite.scale.y = bodyRender.sprite.yScale || 1;\n        } else {\n            var primitiveId = 'b-' + body.id,\n                primitive = render.primitives[primitiveId],\n                container = render.container;\n\n            // initialise body primitive if not existing\n            if (!primitive) {\n                primitive = render.primitives[primitiveId] = _createBodyPrimitive(render, body);\n                primitive.initialAngle = body.angle;\n            }\n\n            // add to scene graph if not already there\n            if (Common.indexOf(container.children, primitive) === -1)\n                container.addChild(primitive);\n\n            // update body primitive\n            primitive.position.x = body.position.x;\n            primitive.position.y = body.position.y;\n            primitive.rotation = body.angle - primitive.initialAngle;\n        }\n    };\n\n    /**\n     * Creates a body sprite\n     * @method _createBodySprite\n     * @private\n     * @param {RenderPixi} render\n     * @param {body} body\n     * @return {PIXI.Sprite} sprite\n     */\n    var _createBodySprite = function(render, body) {\n        var bodyRender = body.render,\n            texturePath = bodyRender.sprite.texture,\n            texture = _getTexture(render, texturePath),\n            sprite = new PIXI.Sprite(texture);\n\n        sprite.anchor.x = 0.5;\n        sprite.anchor.y = 0.5;\n\n        return sprite;\n    };\n\n    /**\n     * Creates a body primitive\n     * @method _createBodyPrimitive\n     * @private\n     * @param {RenderPixi} render\n     * @param {body} body\n     * @return {PIXI.Graphics} graphics\n     */\n    var _createBodyPrimitive = function(render, body) {\n        var bodyRender = body.render,\n            options = render.options,\n            primitive = new PIXI.Graphics();\n\n        primitive.clear();\n\n        if (!options.wireframes) {\n            primitive.beginFill(Common.colorToNumber(bodyRender.fillStyle), 1);\n            primitive.lineStyle(body.render.lineWidth, Common.colorToNumber(bodyRender.strokeStyle), 1);\n        } else {\n            primitive.beginFill(0, 0);\n            primitive.lineStyle(1, Common.colorToNumber('#bbb'), 1);\n        }\n\n        primitive.moveTo(body.vertices[0].x - body.position.x, body.vertices[0].y - body.position.y);\n\n        for (var j = 1; j < body.vertices.length; j++) {\n            primitive.lineTo(body.vertices[j].x - body.position.x, body.vertices[j].y - body.position.y);\n        }\n\n        primitive.lineTo(body.vertices[0].x - body.position.x, body.vertices[0].y - body.position.y);\n\n        primitive.endFill();\n\n        // angle indicator\n        if (options.showAngleIndicator || options.showAxes) {\n            primitive.beginFill(0, 0);\n\n            if (options.wireframes) {\n                primitive.lineStyle(1, Common.colorToNumber('#CD5C5C'), 1);\n            } else {\n                primitive.lineStyle(1, Common.colorToNumber(body.render.strokeStyle));\n            }\n\n            primitive.moveTo(0, 0);\n            primitive.lineTo(((body.vertices[0].x + body.vertices[body.vertices.length-1].x) / 2) - body.position.x,\n                             ((body.vertices[0].y + body.vertices[body.vertices.length-1].y) / 2) - body.position.y);\n\n            primitive.endFill();\n        }\n\n        return primitive;\n    };\n\n    /**\n     * Gets the requested texture (a PIXI.Texture) via its path\n     * @method _getTexture\n     * @private\n     * @param {RenderPixi} render\n     * @param {string} imagePath\n     * @return {PIXI.Texture} texture\n     */\n    var _getTexture = function(render, imagePath) {\n        var texture = render.textures[imagePath];\n\n        if (!texture)\n            texture = render.textures[imagePath] = PIXI.Texture.fromImage(imagePath);\n\n        return texture;\n    };\n\n})();\n\n\n;   // End src/render/RenderPixi.js\n\n\n// aliases\n\nWorld.add = Composite.add;\nWorld.remove = Composite.remove;\nWorld.addComposite = Composite.addComposite;\nWorld.addBody = Composite.addBody;\nWorld.addConstraint = Composite.addConstraint;\nWorld.removeConstraint = Composite.removeConstraint;\nWorld.clear = Composite.clear;\n\nEngine.run = Runner.run;\n\n// exports\n\nMatter.Body = Body;\nMatter.Composite = Composite;\nMatter.World = World;\nMatter.Contact = Contact;\nMatter.Detector = Detector;\nMatter.Grid = Grid;\nMatter.Pairs = Pairs;\nMatter.Pair = Pair;\nMatter.Resolver = Resolver;\nMatter.SAT = SAT;\nMatter.Constraint = Constraint;\nMatter.MouseConstraint = MouseConstraint;\nMatter.Common = Common;\nMatter.Engine = Engine;\nMatter.Metrics = Metrics;\nMatter.Mouse = Mouse;\nMatter.Sleeping = Sleeping;\nMatter.Bodies = Bodies;\nMatter.Composites = Composites;\nMatter.Axes = Axes;\nMatter.Bounds = Bounds;\nMatter.Vector = Vector;\nMatter.Vertices = Vertices;\nMatter.Render = Render;\nMatter.RenderPixi = RenderPixi;\nMatter.Events = Events;\nMatter.Query = Query;\nMatter.Runner = Runner;\n\n// CommonJS module\nif (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n        exports = module.exports = Matter;\n    }\n    exports.Matter = Matter;\n}\n\n// AMD module\nif (typeof define === 'function' && define.amd) {\n    define('Matter', [], function () {\n        return Matter;\n    });\n}\n\n// browser\nif (typeof window === 'object' && typeof window.document === 'object') {\n    window.Matter = Matter;\n}\n\n// End Matter namespace closure\n\n})();\n",
    "/**\r\n * @license\r\n * pixi.js - v1.5.1\r\n * Copyright (c) 2012-2014, Mat Groves\r\n * http://goodboydigital.com/\r\n *\r\n * Compiled: 2014-02-13\r\n *\r\n * pixi.js is licensed under the MIT License.\r\n * http://www.opensource.org/licenses/mit-license.php\r\n */\r\n/**\r\n * @author Mat Groves http://matgroves.com/ @Doormat23\r\n */\r\n\r\n(function(){\r\n\r\n    var root = this;\r\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * @module PIXI\n */\nvar PIXI = PIXI || {};\n\n/* \n* \n* This file contains a lot of pixi consts which are used across the rendering engine\n* @class Consts\n*/\nPIXI.WEBGL_RENDERER = 0;\nPIXI.CANVAS_RENDERER = 1;\n\n// useful for testing against if your lib is using pixi.\nPIXI.VERSION = \"v1.5.1\";\n\n// the various blend modes supported by pixi\nPIXI.blendModes = {\n    NORMAL:0,\n    ADD:1,\n    MULTIPLY:2,\n    SCREEN:3,\n    OVERLAY:4,\n    DARKEN:5,\n    LIGHTEN:6,\n    COLOR_DODGE:7,\n    COLOR_BURN:8,\n    HARD_LIGHT:9,\n    SOFT_LIGHT:10,\n    DIFFERENCE:11,\n    EXCLUSION:12,\n    HUE:13,\n    SATURATION:14,\n    COLOR:15,\n    LUMINOSITY:16\n};\n\n// the scale modes\nPIXI.scaleModes = {\n    DEFAULT:0,\n    LINEAR:0,\n    NEAREST:1\n};\n\n// interaction frequency \nPIXI.INTERACTION_FREQUENCY = 30;\nPIXI.AUTO_PREVENT_DEFAULT = true;\n\nPIXI.RAD_TO_DEG = 180 / Math.PI;\nPIXI.DEG_TO_RAD = Math.PI / 180;\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.\n *\n * @class Point\n * @constructor\n * @param x {Number} position of the point on the x axis\n * @param y {Number} position of the point on the y axis\n */\nPIXI.Point = function(x, y)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n};\n\n/**\n * Creates a clone of this point\n *\n * @method clone\n * @return {Point} a copy of the point\n */\nPIXI.Point.prototype.clone = function()\n{\n    return new PIXI.Point(this.x, this.y);\n};\n\n// constructor\nPIXI.Point.prototype.constructor = PIXI.Point;\n\nPIXI.Point.prototype.set = function(x, y)\n{\n    this.x = x || 0;\n    this.y = y || ( (y !== 0) ? this.x : 0 ) ;\n};\n\n\r\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.\n *\n * @class Rectangle\n * @constructor\n * @param x {Number} The X coord of the upper-left corner of the rectangle\n * @param y {Number} The Y coord of the upper-left corner of the rectangle\n * @param width {Number} The overall width of this rectangle\n * @param height {Number} The overall height of this rectangle\n */\nPIXI.Rectangle = function(x, y, width, height)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property width\n     * @type Number\n     * @default 0\n     */\n    this.width = width || 0;\n\n    /**\n     * @property height\n     * @type Number\n     * @default 0\n     */\n    this.height = height || 0;\n};\n\n/**\n * Creates a clone of this Rectangle\n *\n * @method clone\n * @return {Rectangle} a copy of the rectangle\n */\nPIXI.Rectangle.prototype.clone = function()\n{\n    return new PIXI.Rectangle(this.x, this.y, this.width, this.height);\n};\n\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this Rectangle\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coords are within this Rectangle\n */\nPIXI.Rectangle.prototype.contains = function(x, y)\n{\n    if(this.width <= 0 || this.height <= 0)\n        return false;\n\n    var x1 = this.x;\n    if(x >= x1 && x <= x1 + this.width)\n    {\n        var y1 = this.y;\n\n        if(y >= y1 && y <= y1 + this.height)\n        {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n// constructor\nPIXI.Rectangle.prototype.constructor = PIXI.Rectangle;\n\nPIXI.EmptyRectangle = new PIXI.Rectangle(0,0,0,0);\r\n/**\n * @author Adrien Brault <adrien.brault@gmail.com>\n */\n\n/**\n * @class Polygon\n * @constructor\n * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,\n *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be\n *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the\n *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are\n *      Numbers.\n */\nPIXI.Polygon = function(points)\n{\n    //if points isn't an array, use arguments as the array\n    if(!(points instanceof Array))\n        points = Array.prototype.slice.call(arguments);\n\n    //if this is a flat array of numbers, convert it to points\n    if(typeof points[0] === 'number') {\n        var p = [];\n        for(var i = 0, il = points.length; i < il; i+=2) {\n            p.push(\n                new PIXI.Point(points[i], points[i + 1])\n            );\n        }\n\n        points = p;\n    }\n\n    this.points = points;\n};\n\n/**\n * Creates a clone of this polygon\n *\n * @method clone\n * @return {Polygon} a copy of the polygon\n */\nPIXI.Polygon.prototype.clone = function()\n{\n    var points = [];\n    for (var i=0; i<this.points.length; i++) {\n        points.push(this.points[i].clone());\n    }\n\n    return new PIXI.Polygon(points);\n};\n\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this polygon\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coordinates are within this polygon\n */\nPIXI.Polygon.prototype.contains = function(x, y)\n{\n    var inside = false;\n\n    // use some raycasting to test hits\n    // https://github.com/substack/point-in-polygon/blob/master/index.js\n    for(var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y,\n            xj = this.points[j].x, yj = this.points[j].y,\n            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n        if(intersect) inside = !inside;\n    }\n\n    return inside;\n};\n\n// constructor\nPIXI.Polygon.prototype.constructor = PIXI.Polygon;\n\r\n/**\n * @author Chad Engler <chad@pantherdev.com>\n */\n\n/**\n * The Circle object can be used to specify a hit area for displayObjects\n *\n * @class Circle\n * @constructor\n * @param x {Number} The X coordinate of the upper-left corner of the framing rectangle of this circle\n * @param y {Number} The Y coordinate of the upper-left corner of the framing rectangle of this circle\n * @param radius {Number} The radius of the circle\n */\nPIXI.Circle = function(x, y, radius)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property radius\n     * @type Number\n     * @default 0\n     */\n    this.radius = radius || 0;\n};\n\n/**\n * Creates a clone of this Circle instance\n *\n * @method clone\n * @return {Circle} a copy of the polygon\n */\nPIXI.Circle.prototype.clone = function()\n{\n    return new PIXI.Circle(this.x, this.y, this.radius);\n};\n\n/**\n * Checks whether the x, and y coordinates passed to this function are contained within this circle\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coordinates are within this polygon\n */\nPIXI.Circle.prototype.contains = function(x, y)\n{\n    if(this.radius <= 0)\n        return false;\n\n    var dx = (this.x - x),\n        dy = (this.y - y),\n        r2 = this.radius * this.radius;\n\n    dx *= dx;\n    dy *= dy;\n\n    return (dx + dy <= r2);\n};\n\n// constructor\nPIXI.Circle.prototype.constructor = PIXI.Circle;\n\n\r\n/**\n * @author Chad Engler <chad@pantherdev.com>\n */\n\n/**\n * The Ellipse object can be used to specify a hit area for displayObjects\n *\n * @class Ellipse\n * @constructor\n * @param x {Number} The X coordinate of the upper-left corner of the framing rectangle of this ellipse\n * @param y {Number} The Y coordinate of the upper-left corner of the framing rectangle of this ellipse\n * @param width {Number} The overall width of this ellipse\n * @param height {Number} The overall height of this ellipse\n */\nPIXI.Ellipse = function(x, y, width, height)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property width\n     * @type Number\n     * @default 0\n     */\n    this.width = width || 0;\n\n    /**\n     * @property height\n     * @type Number\n     * @default 0\n     */\n    this.height = height || 0;\n};\n\n/**\n * Creates a clone of this Ellipse instance\n *\n * @method clone\n * @return {Ellipse} a copy of the ellipse\n */\nPIXI.Ellipse.prototype.clone = function()\n{\n    return new PIXI.Ellipse(this.x, this.y, this.width, this.height);\n};\n\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this ellipse\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coords are within this ellipse\n */\nPIXI.Ellipse.prototype.contains = function(x, y)\n{\n    if(this.width <= 0 || this.height <= 0)\n        return false;\n\n    //normalize the coords to an ellipse with center 0,0\n    var normx = ((x - this.x) / this.width),\n        normy = ((y - this.y) / this.height);\n\n    normx *= normx;\n    normy *= normy;\n\n    return (normx + normy <= 1);\n};\n\n/**\n* Returns the framing rectangle of the ellipse as a PIXI.Rectangle object\n*\n* @method getBounds\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.Ellipse.prototype.getBounds = function()\n{\n    return new PIXI.Rectangle(this.x, this.y, this.width, this.height);\n};\n\n// constructor\nPIXI.Ellipse.prototype.constructor = PIXI.Ellipse;\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.determineMatrixArrayType = function() {\n    return (typeof Float32Array !== 'undefined') ? Float32Array : Array;\n};\n\n/*\n* @class Matrix2\n* The Matrix2 class will choose the best type of array to use between\n* a regular javascript Array and a Float32Array if the latter is available\n*\n*/\nPIXI.Matrix2 = PIXI.determineMatrixArrayType();\n\n/*\n* @class Matrix\n* The Matrix class is now an object, which makes it a lot faster, \n* here is a representation of it : \n* | a | b | tx|\n* | c | c | ty|\n* | 0 | 0 | 1 |\n*\n*/\nPIXI.Matrix = function()\n{\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n};\n\n/**\n * Creates a pixi matrix object based on the array given as a parameter\n *\n * @method fromArray\n * @param array {Array} The array that the matrix will be filled with\n */\nPIXI.Matrix.prototype.fromArray = function(array)\n{\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n};\n\n/**\n * Creates an array from the current Matrix object\n *\n * @method toArray\n * @param transpose {Boolean} Whether we need to transpose the matrix or not\n * @return array {Array} the newly created array which contains the matrix\n */\nPIXI.Matrix.prototype.toArray = function(transpose)\n{\n    if(!this.array) this.array = new Float32Array(9);\n    var array = this.array;\n\n    if(transpose)\n    {\n        this.array[0] = this.a;\n        this.array[1] = this.c;\n        this.array[2] = 0;\n        this.array[3] = this.b;\n        this.array[4] = this.d;\n        this.array[5] = 0;\n        this.array[6] = this.tx;\n        this.array[7] = this.ty;\n        this.array[8] = 1;\n    }\n    else\n    {\n        this.array[0] = this.a;\n        this.array[1] = this.b;\n        this.array[2] = this.tx;\n        this.array[3] = this.c;\n        this.array[4] = this.d;\n        this.array[5] = this.ty;\n        this.array[6] = 0;\n        this.array[7] = 0;\n        this.array[8] = 1;\n    }\n\n    return array;//[this.a, this.b, this.tx, this.c, this.d, this.ty, 0, 0, 1];\n};\n\nPIXI.identityMatrix = new PIXI.Matrix();\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * @class DisplayObject\n * @constructor\n */\nPIXI.DisplayObject = function()\n{\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     *\n     * @property position\n     * @type Point\n     */\n    this.position = new PIXI.Point();\n\n    /**\n     * The scale factor of the object.\n     *\n     * @property scale\n     * @type Point\n     */\n    this.scale = new PIXI.Point(1,1);//{x:1, y:1};\n\n    /**\n     * The pivot point of the displayObject that it rotates around\n     *\n     * @property pivot\n     * @type Point\n     */\n    this.pivot = new PIXI.Point(0,0);\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * @property rotation\n     * @type Number\n     */\n    this.rotation = 0;\n\n    /**\n     * The opacity of the object.\n     *\n     * @property alpha\n     * @type Number\n     */\n    this.alpha = 1;\n\n    /**\n     * The visibility of the object.\n     *\n     * @property visible\n     * @type Boolean\n     */\n    this.visible = true;\n\n    /**\n     * This is the defined area that will pick up mouse / touch events. It is null by default.\n     * Setting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)\n     *\n     * @property hitArea\n     * @type Rectangle|Circle|Ellipse|Polygon\n     */\n    this.hitArea = null;\n\n    /**\n     * This is used to indicate if the displayObject should display a mouse hand cursor on rollover\n     *\n     * @property buttonMode\n     * @type Boolean\n     */\n    this.buttonMode = false;\n\n    /**\n     * Can this object be rendered\n     *\n     * @property renderable\n     * @type Boolean\n     */\n    this.renderable = false;\n\n    /**\n     * [read-only] The display object container that contains this display object.\n     *\n     * @property parent\n     * @type DisplayObjectContainer\n     * @readOnly\n     */\n    this.parent = null;\n\n    /**\n     * [read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.\n     *\n     * @property stage\n     * @type Stage\n     * @readOnly\n     */\n    this.stage = null;\n\n    /**\n     * [read-only] The multiplied alpha of the displayObject\n     *\n     * @property worldAlpha\n     * @type Number\n     * @readOnly\n     */\n    this.worldAlpha = 1;\n\n    /**\n     * [read-only] Whether or not the object is interactive, do not toggle directly! use the `interactive` property\n     *\n     * @property _interactive\n     * @type Boolean\n     * @readOnly\n     * @private\n     */\n    this._interactive = false;\n\n    /**\n     * This is the cursor that will be used when the mouse is over this object. To enable this the element must have interaction = true and buttonMode = true\n     * \n     * @property defaultCursor\n     * @type String\n     *\n    */\n    this.defaultCursor = 'pointer';\n\n    /**\n     * [read-only] Current transform of the object based on world (parent) factors\n     *\n     * @property worldTransform\n     * @type Mat3\n     * @readOnly\n     * @private\n     */\n    this.worldTransform = new PIXI.Matrix();\n\n    /**\n     * [NYI] Unknown\n     *\n     * @property color\n     * @type Array<>\n     * @private\n     */\n    this.color = [];\n\n    /**\n     * [NYI] Holds whether or not this object is dynamic, for rendering optimization\n     *\n     * @property dynamic\n     * @type Boolean\n     * @private\n     */\n    this.dynamic = true;\n\n    // cached sin rotation and cos rotation\n    this._sr = 0;\n    this._cr = 1;\n\n    /**\n     * The area the filter is applied to \n     *\n     * @property filterArea\n     * @type Rectangle\n     */\n    this.filterArea = new PIXI.Rectangle(0,0,1,1);\n\n    /**\n     * The original, cached bounds of the object\n     *\n     * @property _bounds\n     * @type Rectangle\n     * @private\n     */\n    this._bounds = new PIXI.Rectangle(0, 0, 1, 1);\n    /**\n     * The most up-to-date bounds of the object\n     *\n     * @property _currentBounds\n     * @type Rectangle\n     * @private\n     */\n    this._currentBounds = null;\n    /**\n     * The original, cached mask of the object\n     *\n     * @property _currentBounds\n     * @type Rectangle\n     * @private\n     */\n    this._mask = null;\n\n    /*\n     * MOUSE Callbacks\n     */\n\n    /**\n     * A callback that is used when the users clicks on the displayObject with their mouse\n     * @method click\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user clicks the mouse down over the sprite\n     * @method mousedown\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the mouse that was over the displayObject\n     * for this callback to be fired the mouse must have been pressed down over the displayObject\n     * @method mouseup\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the mouse that was over the displayObject but is no longer over the displayObject\n     * for this callback to be fired, The touch must have started over the displayObject\n     * @method mouseupoutside\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the users mouse rolls over the displayObject\n     * @method mouseover\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the users mouse leaves the displayObject\n     * @method mouseout\n     * @param interactionData {InteractionData}\n     */\n\n\n    /*\n     * TOUCH Callbacks\n     */\n\n    /**\n     * A callback that is used when the users taps on the sprite with their finger\n     * basically a touch version of click\n     * @method tap\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user touches over the displayObject\n     * @method touchstart\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases a touch over the displayObject\n     * @method touchend\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the touch that was over the displayObject\n     * for this callback to be fired, The touch must have started over the sprite\n     * @method touchendoutside\n     * @param interactionData {InteractionData}\n     */\n};\n\n// constructor\nPIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;\n\n/**\n * [Deprecated] Indicates if the sprite will have touch and mouse interactivity. It is false by default\n * Instead of using this function you can now simply set the interactive property to true or false\n *\n * @method setInteractive\n * @param interactive {Boolean}\n * @deprecated Simply set the `interactive` property directly\n */\nPIXI.DisplayObject.prototype.setInteractive = function(interactive)\n{\n    this.interactive = interactive;\n};\n\n/**\n * Indicates if the sprite will have touch and mouse interactivity. It is false by default\n *\n * @property interactive\n * @type Boolean\n * @default false\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'interactive', {\n    get: function() {\n        return this._interactive;\n    },\n    set: function(value) {\n        this._interactive = value;\n\n        // TODO more to be done here..\n        // need to sort out a re-crawl!\n        if(this.stage)this.stage.dirty = true;\n    }\n});\n\n/**\n * [read-only] Indicates if the sprite is globaly visible.\n *\n * @property worldVisible\n * @type Boolean\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'worldVisible', {\n    get: function() {\n        var item = this;\n\n        do\n        {\n            if(!item.visible)return false;\n            item = item.parent;\n        }\n        while(item);\n\n        return true;\n    }\n});\n\n/**\n * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.\n * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.\n * To remove a mask, set this property to null.\n *\n * @property mask\n * @type Graphics\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'mask', {\n    get: function() {\n        return this._mask;\n    },\n    set: function(value) {\n\n        if(this._mask)this._mask.isMask = false;\n        this._mask = value;\n        if(this._mask)this._mask.isMask = true;\n    }\n});\n\n/**\n * Sets the filters for the displayObject.\n * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n * To remove filters simply set this property to 'null'\n * @property filters\n * @type Array An array of filters\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'filters', {\n    get: function() {\n        return this._filters;\n    },\n    set: function(value) {\n\n        if(value)\n        {\n            // now put all the passes in one place..\n            var passes = [];\n            for (var i = 0; i < value.length; i++)\n            {\n                var filterPasses = value[i].passes;\n                for (var j = 0; j < filterPasses.length; j++)\n                {\n                    passes.push(filterPasses[j]);\n                }\n            }\n\n            // TODO change this as it is legacy\n            this._filterBlock = {target:this, filterPasses:passes};\n        }\n\n        this._filters = value;\n    }\n});\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.DisplayObject.prototype.updateTransform = function()\n{\n    // TODO OPTIMIZE THIS!! with dirty\n    if(this.rotation !== this.rotationCache)\n    {\n\n        this.rotationCache = this.rotation;\n        this._sr =  Math.sin(this.rotation);\n        this._cr =  Math.cos(this.rotation);\n    }\n\n   // var localTransform = this.localTransform//.toArray();\n    var parentTransform = this.parent.worldTransform;//.toArray();\n    var worldTransform = this.worldTransform;//.toArray();\n    var px = this.pivot.x;\n    var py = this.pivot.y;\n\n    var a00 = this._cr * this.scale.x,\n        a01 = -this._sr * this.scale.y,\n        a10 = this._sr * this.scale.x,\n        a11 = this._cr * this.scale.y,\n        a02 = this.position.x - a00 * px - py * a01,\n        a12 = this.position.y - a11 * py - px * a10,\n        b00 = parentTransform.a, b01 = parentTransform.b,\n        b10 = parentTransform.c, b11 = parentTransform.d;\n\n    worldTransform.a = b00 * a00 + b01 * a10;\n    worldTransform.b = b00 * a01 + b01 * a11;\n    worldTransform.tx = b00 * a02 + b01 * a12 + parentTransform.tx;\n\n    worldTransform.c = b10 * a00 + b11 * a10;\n    worldTransform.d = b10 * a01 + b11 * a11;\n    worldTransform.ty = b10 * a02 + b11 * a12 + parentTransform.ty;\n\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n};\n\n/**\n * Retrieves the bounds of the displayObject as a rectangle object\n *\n * @method getBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.DisplayObject.prototype.getBounds = function( matrix )\n{\n    matrix = matrix;//just to get passed js hinting (and preserve inheritance)\n    return PIXI.EmptyRectangle;\n};\n\n/**\n * Retrieves the local bounds of the displayObject as a rectangle object\n *\n * @method getLocalBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.DisplayObject.prototype.getLocalBounds = function()\n{\n    //var matrixCache = this.worldTransform;\n\n    return this.getBounds(PIXI.identityMatrix);///PIXI.EmptyRectangle();\n};\n\n/**\n * Sets the object's stage reference, the stage this object is connected to\n *\n * @method setStageReference\n * @param stage {Stage} the stage that the object will have as its current stage reference\n */\nPIXI.DisplayObject.prototype.setStageReference = function(stage)\n{\n    this.stage = stage;\n    if(this._interactive)this.stage.dirty = true;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObject.prototype._renderWebGL = function(renderSession)\n{\n    // OVERWRITE;\n    // this line is just here to pass jshinting :)\n    renderSession = renderSession;\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObject.prototype._renderCanvas = function(renderSession)\n{\n    // OVERWRITE;\n    // this line is just here to pass jshinting :)\n    renderSession = renderSession;\n};\n\n/**\n * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n *\n * @property x\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'x', {\n    get: function() {\n        return  this.position.x;\n    },\n    set: function(value) {\n        this.position.x = value;\n    }\n});\n\n/**\n * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n *\n * @property y\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'y', {\n    get: function() {\n        return  this.position.y;\n    },\n    set: function(value) {\n        this.position.y = value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * A DisplayObjectContainer represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n * @class DisplayObjectContainer\n * @extends DisplayObject\n * @constructor\n */\nPIXI.DisplayObjectContainer = function()\n{\n    PIXI.DisplayObject.call( this );\n\n    /**\n     * [read-only] The array of children of this container.\n     *\n     * @property children\n     * @type Array<DisplayObject>\n     * @readOnly\n     */\n    this.children = [];\n};\n\n// constructor\nPIXI.DisplayObjectContainer.prototype = Object.create( PIXI.DisplayObject.prototype );\nPIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;\n\n/**\n * The width of the displayObjectContainer, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\n\n /*\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'width', {\n    get: function() {\n        return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function(value) {\n        this.scale.x = value / (this.getLocalBounds().width/this.scale.x);\n        this._width = value;\n    }\n});\n*/\n\n/**\n * The height of the displayObjectContainer, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\n\n/*\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'height', {\n    get: function() {\n        return  this.scale.y * this.getLocalBounds().height;\n    },\n    set: function(value) {\n        this.scale.y = value / (this.getLocalBounds().height/this.scale.y);\n        this._height = value;\n    }\n});\n*/\n\n/**\n * Adds a child to the container.\n *\n * @method addChild\n * @param child {DisplayObject} The DisplayObject to add to the container\n */\nPIXI.DisplayObjectContainer.prototype.addChild = function(child)\n{\n    this.addChildAt(child, this.children.length);\n};\n\n/**\n * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n *\n * @method addChildAt\n * @param child {DisplayObject} The child to add\n * @param index {Number} The index to place the child in\n */\nPIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index)\n{\n    if(index >= 0 && index <= this.children.length)\n    {\n        if(child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n\n        this.children.splice(index, 0, child);\n\n        if(this.stage)child.setStageReference(this.stage);\n    }\n    else\n    {\n        throw new Error(child + ' The index '+ index +' supplied is out of bounds ' + this.children.length);\n    }\n};\n\n/**\n * [NYI] Swaps the depth of 2 displayObjects\n *\n * @method swapChildren\n * @param child {DisplayObject}\n * @param child2 {DisplayObject}\n * @private\n */\nPIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2)\n{\n    if(child === child2) {\n        return;\n    }\n\n    var index1 = this.children.indexOf(child);\n    var index2 = this.children.indexOf(child2);\n\n    if(index1 < 0 || index2 < 0) {\n        throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.');\n    }\n\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    \n};\n\n/**\n * Returns the child at the specified index\n *\n * @method getChildAt\n * @param index {Number} The index to get the child from\n */\nPIXI.DisplayObjectContainer.prototype.getChildAt = function(index)\n{\n    if(index >= 0 && index < this.children.length)\n    {\n        return this.children[index];\n    }\n    else\n    {\n        throw new Error('The supplied DisplayObjects must be a child of the caller ' + this);\n    }\n};\n\n/**\n * Removes a child from the container.\n *\n * @method removeChild\n * @param child {DisplayObject} The DisplayObject to remove\n */\nPIXI.DisplayObjectContainer.prototype.removeChild = function(child)\n{\n    var index = this.children.indexOf( child );\n    if ( index !== -1 )\n    {\n        // update the stage reference..\n        if(this.stage)child.removeStageReference();\n\n        child.parent = undefined;\n        this.children.splice( index, 1 );\n    }\n    else\n    {\n        throw new Error(child + ' The supplied DisplayObject must be a child of the caller ' + this);\n    }\n};\n\n\n/**\n* Removes all the children \n*\n* @method removeAll\n* NOT tested yet\n*/\n/* PIXI.DisplayObjectContainer.prototype.removeAll = function()\n{\n\n\n    for(var i = 0 , j = this.children.length; i < j; i++)\n    {\n        this.removeChild(this.children[i]);\n    }\n    \n};\n*/\n/*\n * Updates the container's childrens transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.DisplayObjectContainer.prototype.updateTransform = function()\n{\n    //this._currentBounds = null;\n\n    if(!this.visible)return;\n\n    PIXI.DisplayObject.prototype.updateTransform.call( this );\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i].updateTransform();\n    }\n};\n\n/**\n * Retrieves the bounds of the displayObjectContainer as a rectangle object\n *\n * @method getBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.DisplayObjectContainer.prototype.getBounds = function(matrix)\n{\n    if(this.children.length === 0)return PIXI.EmptyRectangle;\n\n    // TODO the bounds have already been calculated this render session so return what we have\n    if(matrix)\n    {\n        var matrixCache = this.worldTransform;\n        this.worldTransform = matrix;\n        this.updateTransform();\n        this.worldTransform = matrixCache;\n    }\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var childBounds;\n    var childMaxX;\n    var childMaxY;\n\n    var childVisible = false;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        \n        if(!child.visible)continue;\n\n        childVisible = true;\n\n        childBounds = this.children[i].getBounds( matrix );\n     \n        minX = minX < childBounds.x ? minX : childBounds.x;\n        minY = minY < childBounds.y ? minY : childBounds.y;\n\n        childMaxX = childBounds.width + childBounds.x;\n        childMaxY = childBounds.height + childBounds.y;\n\n        maxX = maxX > childMaxX ? maxX : childMaxX;\n        maxY = maxY > childMaxY ? maxY : childMaxY;\n    }\n\n    if(!childVisible)\n        return PIXI.EmptyRectangle;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.y = minY;\n    bounds.width = maxX - minX;\n    bounds.height = maxY - minY;\n\n    // TODO: store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    //this._currentBounds = bounds;\n   \n    return bounds;\n};\n\nPIXI.DisplayObjectContainer.prototype.getLocalBounds = function()\n{\n    var matrixCache = this.worldTransform;\n\n    this.worldTransform = PIXI.identityMatrix;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n    var bounds = this.getBounds();\n\n    this.worldTransform = matrixCache;\n\n    return bounds;\n};\n\n/**\n * Sets the container's stage reference, the stage this object is connected to\n *\n * @method setStageReference\n * @param stage {Stage} the stage that the container will have as its current stage reference\n */\nPIXI.DisplayObjectContainer.prototype.setStageReference = function(stage)\n{\n    this.stage = stage;\n    if(this._interactive)this.stage.dirty = true;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child.setStageReference(stage);\n    }\n};\n\n/**\n * removes the current stage reference of the container\n *\n * @method removeStageReference\n */\nPIXI.DisplayObjectContainer.prototype.removeStageReference = function()\n{\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child.removeStageReference();\n    }\n\n    if(this._interactive)this.stage.dirty = true;\n    \n    this.stage = null;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObjectContainer.prototype._renderWebGL = function(renderSession)\n{\n    if(!this.visible || this.alpha <= 0)return;\n    \n    var i,j;\n\n    if(this._mask || this._filters)\n    {\n        if(this._mask)\n        {\n            renderSession.spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            renderSession.spriteBatch.start();\n        }\n\n        if(this._filters)\n        {\n            renderSession.spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        renderSession.spriteBatch.stop();\n\n        if(this._filters)renderSession.filterManager.popFilter();\n        if(this._mask)renderSession.maskManager.popMask(renderSession);\n        \n        renderSession.spriteBatch.start();\n    }\n    else\n    {\n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObjectContainer.prototype._renderCanvas = function(renderSession)\n{\n    if(this.visible === false || this.alpha === 0)return;\n\n    if(this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, renderSession.context);\n    }\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child._renderCanvas(renderSession);\n    }\n\n    if(this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession.context);\n    }\n};\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n *\n * @class Sprite\n * @extends DisplayObjectContainer\n * @constructor\n * @param texture {Texture} The texture for this sprite\n * \n * A sprite can be created directly from an image like this : \n * var sprite = nex PIXI.Sprite.FromImage('assets/image.png');\n * yourStage.addChild(sprite);\n * then obviously don't forget to add it to the stage you have already created\n */\nPIXI.Sprite = function(texture)\n{\n    PIXI.DisplayObjectContainer.call( this );\n\n    /**\n     * The anchor sets the origin point of the texture.\n     * The default is 0,0 this means the texture's origin is the top left\n     * Setting than anchor to 0.5,0.5 means the textures origin is centred\n     * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner\n     *\n     * @property anchor\n     * @type Point\n     */\n    this.anchor = new PIXI.Point();\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = texture;\n\n    /**\n     * The width of the sprite (this is initially set by the texture)\n     *\n     * @property _width\n     * @type Number\n     * @private\n     */\n    this._width = 0;\n\n    /**\n     * The height of the sprite (this is initially set by the texture)\n     *\n     * @property _height\n     * @type Number\n     * @private\n     */\n    this._height = 0;\n\n\n    /**\n     * The tint applied to the sprite. This is a hex value\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;// * Math.random();\n    \n    /**\n     * The blend mode to be applied to the sprite\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n\n    if(texture.baseTexture.hasLoaded)\n    {\n        this.onTextureUpdate();\n    }\n    else\n    {\n        this.onTextureUpdateBind = this.onTextureUpdate.bind(this);\n        this.texture.addEventListener( 'update', this.onTextureUpdateBind );\n    }\n\n    this.renderable = true;\n};\n\n// constructor\nPIXI.Sprite.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Sprite.prototype.constructor = PIXI.Sprite;\n\n/**\n * The width of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'width', {\n    get: function() {\n        return this.scale.x * this.texture.frame.width;\n    },\n    set: function(value) {\n        this.scale.x = value / this.texture.frame.width;\n        this._width = value;\n    }\n});\n\n/**\n * The height of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'height', {\n    get: function() {\n        return  this.scale.y * this.texture.frame.height;\n    },\n    set: function(value) {\n        this.scale.y = value / this.texture.frame.height;\n        this._height = value;\n    }\n});\n\n/**\n * Sets the texture of the sprite\n *\n * @method setTexture\n * @param texture {Texture} The PIXI texture that is displayed by the sprite\n */\nPIXI.Sprite.prototype.setTexture = function(texture)\n{\n    // stop current texture;\n    if(this.texture.baseTexture !== texture.baseTexture)\n    {\n        this.textureChange = true;\n        this.texture = texture;\n    }\n    else\n    {\n        this.texture = texture;\n    }\n\n    this.cachedTint = 0xFFFFFF;\n    this.updateFrame = true;\n};\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\nPIXI.Sprite.prototype.onTextureUpdate = function()\n{\n    // so if _width is 0 then width was not set..\n    if(this._width)this.scale.x = this._width / this.texture.frame.width;\n    if(this._height)this.scale.y = this._height / this.texture.frame.height;\n\n\n    this.updateFrame = true;\n};\n\n/**\n* Returns the framing rectangle of the sprite as a PIXI.Rectangle object\n*\n* @method getBounds\n* @param matrix {Matrix} the transformation matrix of the sprite\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.Sprite.prototype.getBounds = function(matrix)\n{\n\n    var width = this.texture.frame.width;\n    var height = this.texture.frame.height;\n\n    var w0 = width * (1-this.anchor.x);\n    var w1 = width * -this.anchor.x;\n\n    var h0 = height * (1-this.anchor.y);\n    var h1 = height * -this.anchor.y;\n\n    var worldTransform = matrix || this.worldTransform ;\n\n    var a = worldTransform.a;\n    var b = worldTransform.c;\n    var c = worldTransform.b;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    minX = x1 < minX ? x1 : minX;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y1 < minY ? y1 : minY;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x1 > maxX ? x1 : maxX;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y1 > maxY ? y1 : maxY;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    this._currentBounds = bounds;\n\n    return bounds;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Sprite.prototype._renderWebGL = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(!this.visible || this.alpha <= 0)return;\n    \n    var i,j;\n\n    // do a quick check to see if this element has a mask or a filter.\n    if(this._mask || this._filters)\n    {\n        var spriteBatch =  renderSession.spriteBatch;\n\n        if(this._mask)\n        {\n            spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            spriteBatch.start();\n        }\n\n        if(this._filters)\n        {\n            spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        // add this sprite to the batch\n        spriteBatch.render(this);\n\n        // now loop through the children and make sure they get rendered\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        // time to stop the sprite batch as either a mask element or a filter draw will happen next\n        spriteBatch.stop();\n\n        if(this._filters)renderSession.filterManager.popFilter();\n        if(this._mask)renderSession.maskManager.popMask(renderSession);\n        \n        spriteBatch.start();\n    }\n    else\n    {\n        renderSession.spriteBatch.render(this);\n\n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n    }\n\n   \n    //TODO check culling  \n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Sprite.prototype._renderCanvas = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(this.visible === false || this.alpha === 0)return;\n    \n    var frame = this.texture.frame;\n    var context = renderSession.context;\n    var texture = this.texture;\n\n    if(this.blendMode !== renderSession.currentBlendMode)\n    {\n        renderSession.currentBlendMode = this.blendMode;\n        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n    }\n\n    if(this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, renderSession.context);\n    }\n\n    \n\n    //ignore null sources\n    if(frame && frame.width && frame.height && texture.baseTexture.source)\n    {\n        context.globalAlpha = this.worldAlpha;\n\n        var transform = this.worldTransform;\n\n        // allow for trimming\n       \n        if (renderSession.roundPixels)\n        {\n            context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx || 0, transform.ty || 0);\n        }\n        else\n        {\n            context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);\n        }\n\n\n        //if smoothingEnabled is supported and we need to change the smoothing property for this texture\n        if(renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode) {\n            renderSession.scaleMode = this.texture.baseTexture.scaleMode;\n            context[renderSession.smoothProperty] = (renderSession.scaleMode === PIXI.scaleModes.LINEAR);\n        }\n\n        if(this.tint !== 0xFFFFFF)\n        {\n            \n            if(this.cachedTint !== this.tint)\n            {\n                // no point tinting an image that has not loaded yet!\n                if(!texture.baseTexture.hasLoaded)return;\n\n                this.cachedTint = this.tint;\n                \n                //TODO clean up caching - how to clean up the caches?\n                this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);\n                \n            }\n\n            context.drawImage(this.tintedTexture,\n                               0,\n                               0,\n                               frame.width,\n                               frame.height,\n                               (this.anchor.x) * -frame.width,\n                               (this.anchor.y) * -frame.height,\n                               frame.width,\n                               frame.height);\n        }\n        else\n        {\n\n           \n\n            if(texture.trim)\n            {\n                var trim =  texture.trim;\n\n                context.drawImage(this.texture.baseTexture.source,\n                               frame.x,\n                               frame.y,\n                               frame.width,\n                               frame.height,\n                               trim.x - this.anchor.x * trim.width,\n                               trim.y - this.anchor.y * trim.height,\n                               frame.width,\n                               frame.height);\n            }\n            else\n            {\n               \n                context.drawImage(this.texture.baseTexture.source,\n                               frame.x,\n                               frame.y,\n                               frame.width,\n                               frame.height,\n                               (this.anchor.x) * -frame.width,\n                               (this.anchor.y) * -frame.height,\n                               frame.width,\n                               frame.height);\n            }\n            \n        }\n    }\n\n    // OVERWRITE\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child._renderCanvas(renderSession);\n    }\n\n    if(this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession.context);\n    }\n};\n\n\n// some helper functions..\n\n/**\n *\n * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @method fromFrame\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId\n */\nPIXI.Sprite.fromFrame = function(frameId)\n{\n    var texture = PIXI.TextureCache[frameId];\n    if(!texture) throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache' + this);\n    return new PIXI.Sprite(texture);\n};\n\n/**\n *\n * Helper function that creates a sprite that will contain a texture based on an image url\n * If the image is not in the texture cache it will be loaded\n *\n * @method fromImage\n * @static\n * @param imageId {String} The image url of the texture\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id\n */\nPIXI.Sprite.fromImage = function(imageId, crossorigin, scaleMode)\n{\n    var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode);\n    return new PIXI.Sprite(texture);\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * The SpriteBatch class is a really fast version of the DisplayObjectContainer \n * built solely for speed, so use when you need a lot of sprites or particles.\n * And it's extremely easy to use : \n\n    var container = new PIXI.SpriteBatch();\n \n    stage.addChild(container);\n \n    for(var i  = 0; i < 100; i++)\n    {\n        var sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n        container.addChild(sprite);\n    }\n * And here you have a hundred sprites that will be renderer at the speed of light\n *\n * @class SpriteBatch\n * @constructor\n * @param texture {Texture}\n */\nPIXI.SpriteBatch = function(texture)\n{\n    PIXI.DisplayObjectContainer.call( this);\n\n    this.textureThing = texture;\n\n    this.ready = false;\n};\n\nPIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.SpriteBatch.constructor = PIXI.SpriteBatch;\n\n/*\n * Initialises the spriteBatch\n *\n * @method initWebGL\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.SpriteBatch.prototype.initWebGL = function(gl)\n{\n    // TODO only one needed for the whole engine really?\n    this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl);\n\n    this.ready = true;\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.SpriteBatch.prototype.updateTransform = function()\n{\n   // TODO dont need to!\n    PIXI.DisplayObject.prototype.updateTransform.call( this );\n  //  PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.SpriteBatch.prototype._renderWebGL = function(renderSession)\n{\n    if(!this.visible || this.alpha <= 0 || !this.children.length)return;\n\n    if(!this.ready)this.initWebGL( renderSession.gl );\n    \n    renderSession.spriteBatch.stop();\n    \n    renderSession.shaderManager.activateShader(renderSession.shaderManager.fastShader);\n    \n    this.fastSpriteBatch.begin(this, renderSession);\n    this.fastSpriteBatch.render(this);\n\n    renderSession.shaderManager.activateShader(renderSession.shaderManager.defaultShader);\n\n    renderSession.spriteBatch.start();\n \n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.SpriteBatch.prototype._renderCanvas = function(renderSession)\n{\n    var context = renderSession.context;\n    context.globalAlpha = this.worldAlpha;\n\n    var transform = this.worldTransform;\n\n    // alow for trimming\n       \n    if (renderSession.roundPixels)\n    {\n        context.setTransform(transform.a, transform.c, transform.b, transform.d, Math.floor(transform.tx), Math.floor(transform.ty));\n    }\n    else\n    {\n        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);\n    }\n\n    context.save();\n\n    for (var i = 0; i < this.children.length; i++) {\n       \n        var child = this.children[i];\n        var texture = child.texture;\n        var frame = texture.frame;\n\n        context.globalAlpha = this.worldAlpha * child.alpha;\n\n        if(child.rotation % (Math.PI * 2) === 0)\n        {\n          \n          // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n            context.drawImage(texture.baseTexture.source,\n                                 frame.x,\n                                 frame.y,\n                                 frame.width,\n                                 frame.height,\n                                 ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5) | 0,\n                                 ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5) | 0,\n                                 frame.width * child.scale.x,\n                                 frame.height * child.scale.y);\n        }\n        else\n        {\n            PIXI.DisplayObject.prototype.updateTransform.call(child);\n           \n            transform = child.localTransform;\n\n            if(this.rotation !== this.rotationCache)\n            {\n                this.rotationCache = this.rotation;\n                this._sr =  Math.sin(this.rotation);\n                this._cr =  Math.cos(this.rotation);\n            }\n\n            var a = child._cr * child.scale.x,\n                b = -child._sr * child.scale.y,\n                c = child._sr * child.scale.x,\n                d = child._cr * child.scale.y;\n                \n            context.setTransform(a, c, b, d, child.position.x, child.position.y);\n            \n            context.drawImage(texture.baseTexture.source,\n                                 frame.x,\n                                 frame.y,\n                                 frame.width,\n                                 frame.height,\n                                 ((child.anchor.x) * (-frame.width) + 0.5) | 0,\n                                 ((child.anchor.y) * (-frame.height) + 0.5) | 0,\n                                 frame.width,\n                                 frame.height);\n\n        }\n    }\n\n    context.restore();\n};\n\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A MovieClip is a simple way to display an animation depicted by a list of textures.\n *\n * @class MovieClip\n * @extends Sprite\n * @constructor\n * @param textures {Array<Texture>} an array of {Texture} objects that make up the animation\n */\nPIXI.MovieClip = function(textures)\n{\n    PIXI.Sprite.call(this, textures[0]);\n\n    /**\n     * The array of textures that make up the animation\n     *\n     * @property textures\n     * @type Array\n     */\n    this.textures = textures;\n\n    /**\n     * The speed that the MovieClip will play at. Higher is faster, lower is slower\n     *\n     * @property animationSpeed\n     * @type Number\n     * @default 1\n     */\n    this.animationSpeed = 1;\n\n    /**\n     * Whether or not the movie clip repeats after playing.\n     *\n     * @property loop\n     * @type Boolean\n     * @default true\n     */\n    this.loop = true;\n\n    /**\n     * Function to call when a MovieClip finishes playing\n     *\n     * @property onComplete\n     * @type Function\n     */\n    this.onComplete = null;\n\n    /**\n     * [read-only] The MovieClips current frame index (this may not have to be a whole number)\n     *\n     * @property currentFrame\n     * @type Number\n     * @default 0\n     * @readOnly\n     */\n    this.currentFrame = 0;\n\n    /**\n     * [read-only] Indicates if the MovieClip is currently playing\n     *\n     * @property playing\n     * @type Boolean\n     * @readOnly\n     */\n    this.playing = false;\n};\n\n// constructor\nPIXI.MovieClip.prototype = Object.create( PIXI.Sprite.prototype );\nPIXI.MovieClip.prototype.constructor = PIXI.MovieClip;\n\n/**\n* [read-only] totalFrames is the total number of frames in the MovieClip. This is the same as number of textures\n* assigned to the MovieClip.\n*\n* @property totalFrames\n* @type Number\n* @default 0\n* @readOnly\n*/\nObject.defineProperty( PIXI.MovieClip.prototype, 'totalFrames', {\n\tget: function() {\n\n\t\treturn this.textures.length;\n\t}\n});\n\n\n/**\n * Stops the MovieClip\n *\n * @method stop\n */\nPIXI.MovieClip.prototype.stop = function()\n{\n    this.playing = false;\n};\n\n/**\n * Plays the MovieClip\n *\n * @method play\n */\nPIXI.MovieClip.prototype.play = function()\n{\n    this.playing = true;\n};\n\n/**\n * Stops the MovieClip and goes to a specific frame\n *\n * @method gotoAndStop\n * @param frameNumber {Number} frame index to stop at\n */\nPIXI.MovieClip.prototype.gotoAndStop = function(frameNumber)\n{\n    this.playing = false;\n    this.currentFrame = frameNumber;\n    var round = (this.currentFrame + 0.5) | 0;\n    this.setTexture(this.textures[round % this.textures.length]);\n};\n\n/**\n * Goes to a specific frame and begins playing the MovieClip\n *\n * @method gotoAndPlay\n * @param frameNumber {Number} frame index to start at\n */\nPIXI.MovieClip.prototype.gotoAndPlay = function(frameNumber)\n{\n    this.currentFrame = frameNumber;\n    this.playing = true;\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.MovieClip.prototype.updateTransform = function()\n{\n    PIXI.Sprite.prototype.updateTransform.call(this);\n\n    if(!this.playing)return;\n\n    this.currentFrame += this.animationSpeed;\n\n    var round = (this.currentFrame + 0.5) | 0;\n\n    if(this.loop || round < this.textures.length)\n    {\n        this.setTexture(this.textures[round % this.textures.length]);\n    }\n    else if(round >= this.textures.length)\n    {\n        this.gotoAndStop(this.textures.length - 1);\n        if(this.onComplete)\n        {\n            this.onComplete();\n        }\n    }\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\nPIXI.FilterBlock = function()\n{\n    this.visible = true;\n    this.renderable = true;\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Text Object will create a line(s) of text. To split a line you can use '\\n' \n * or add a wordWrap property set to true and and wordWrapWidth property with a value\n * in the style object\n *\n * @class Text\n * @extends Sprite\n * @constructor\n * @param text {String} The copy that you would like the text to display\n * @param [style] {Object} The style parameters\n * @param [style.font] {String} default 'bold 20px Arial' The style and size of the font\n * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'\n * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap, it needs wordWrap to be set to true\n */\nPIXI.Text = function(text, style)\n{\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     */\n    this.canvas = document.createElement('canvas');\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @property context\n     * @type HTMLCanvasElement 2d Context\n     */\n    this.context = this.canvas.getContext('2d');\n\n    PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas));\n\n    this.setText(text);\n    this.setStyle(style);\n\n    this.updateText();\n    this.dirty = false;\n};\n\n// constructor\nPIXI.Text.prototype = Object.create(PIXI.Sprite.prototype);\nPIXI.Text.prototype.constructor = PIXI.Text;\n\n/**\n * Set the style of the text\n *\n * @method setStyle\n * @param [style] {Object} The style parameters\n * @param [style.font='bold 20pt Arial'] {String} The style and size of the font\n * @param [style.fill='black'] {Object} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'\n * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke='black'] {String} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap\n */\nPIXI.Text.prototype.setStyle = function(style)\n{\n    style = style || {};\n    style.font = style.font || 'bold 20pt Arial';\n    style.fill = style.fill || 'black';\n    style.align = style.align || 'left';\n    style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136\n    style.strokeThickness = style.strokeThickness || 0;\n    style.wordWrap = style.wordWrap || false;\n    style.wordWrapWidth = style.wordWrapWidth || 100;\n    this.style = style;\n    this.dirty = true;\n};\n\n/**\n * Set the copy for the text object. To split a line you can use '\\n'\n *\n * @method setText\n * @param {String} text The copy that you would like the text to display\n */\nPIXI.Text.prototype.setText = function(text)\n{\n    this.text = text.toString() || ' ';\n    this.dirty = true;\n\n};\n\n/**\n * Renders text and updates it when needed\n *\n * @method updateText\n * @private\n */\nPIXI.Text.prototype.updateText = function()\n{\n    this.context.font = this.style.font;\n\n    var outputText = this.text;\n\n    // word wrap\n    // preserve original text\n    if(this.style.wordWrap)outputText = this.wordWrap(this.text);\n\n    //split text into lines\n    var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n    //calculate text width\n    var lineWidths = [];\n    var maxLineWidth = 0;\n    for (var i = 0; i < lines.length; i++)\n    {\n        var lineWidth = this.context.measureText(lines[i]).width;\n        lineWidths[i] = lineWidth;\n        maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    this.canvas.width = maxLineWidth + this.style.strokeThickness;\n\n    //calculate text height\n    var lineHeight = this.determineFontHeight('font: ' + this.style.font  + ';') + this.style.strokeThickness;\n    this.canvas.height = lineHeight * lines.length;\n\n    if(navigator.isCocoonJS) this.context.clearRect(0,0,this.canvas.width,this.canvas.height);\n    \n    //set canvas text styles\n    this.context.fillStyle = this.style.fill;\n    this.context.font = this.style.font;\n\n    this.context.strokeStyle = this.style.stroke;\n    this.context.lineWidth = this.style.strokeThickness;\n\n    this.context.textBaseline = 'top';\n\n    //draw lines line by line\n    for (i = 0; i < lines.length; i++)\n    {\n        var linePosition = new PIXI.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + i * lineHeight);\n\n        if(this.style.align === 'right')\n        {\n            linePosition.x += maxLineWidth - lineWidths[i];\n        }\n        else if(this.style.align === 'center')\n        {\n            linePosition.x += (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        if(this.style.stroke && this.style.strokeThickness)\n        {\n            this.context.strokeText(lines[i], linePosition.x, linePosition.y);\n        }\n\n        if(this.style.fill)\n        {\n            this.context.fillText(lines[i], linePosition.x, linePosition.y);\n        }\n    }\n\n    this.updateTexture();\n};\n\n/**\n * Updates texture size based on canvas size\n *\n * @method updateTexture\n * @private\n */\nPIXI.Text.prototype.updateTexture = function()\n{\n    this.texture.baseTexture.width = this.canvas.width;\n    this.texture.baseTexture.height = this.canvas.height;\n    this.texture.frame.width = this.canvas.width;\n    this.texture.frame.height = this.canvas.height;\n\n    this._width = this.canvas.width;\n    this._height = this.canvas.height;\n\n    this.requiresUpdate =  true;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Text.prototype._renderWebGL = function(renderSession)\n{\n    if(this.requiresUpdate)\n    {\n        this.requiresUpdate = false;\n        PIXI.updateWebGLTexture(this.texture.baseTexture, renderSession.gl);\n    }\n\n    PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);\n};\n\n/**\n * Updates the transform of this object\n *\n * @method updateTransform\n * @private\n */\nPIXI.Text.prototype.updateTransform = function()\n{\n    if(this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n\n    PIXI.Sprite.prototype.updateTransform.call(this);\n};\n\n/*\n * http://stackoverflow.com/users/34441/ellisbben\n * great solution to the problem!\n * returns the height of the given font\n *\n * @method determineFontHeight\n * @param fontStyle {Object}\n * @private\n */\nPIXI.Text.prototype.determineFontHeight = function(fontStyle)\n{\n    // build a little reference dictionary so if the font style has been used return a\n    // cached version...\n    var result = PIXI.Text.heightCache[fontStyle];\n\n    if(!result)\n    {\n        var body = document.getElementsByTagName('body')[0];\n        var dummy = document.createElement('div');\n        var dummyText = document.createTextNode('M');\n        dummy.appendChild(dummyText);\n        dummy.setAttribute('style', fontStyle + ';position:absolute;top:0;left:0');\n        body.appendChild(dummy);\n\n        result = dummy.offsetHeight;\n        PIXI.Text.heightCache[fontStyle] = result;\n\n        body.removeChild(dummy);\n    }\n\n    return result;\n};\n\n/**\n * Applies newlines to a string to have it optimally fit into the horizontal\n * bounds set by the Text object's wordWrapWidth property.\n *\n * @method wordWrap\n * @param text {String}\n * @private\n */\nPIXI.Text.prototype.wordWrap = function(text)\n{\n    // Greedy wrapping algorithm that will wrap words as the line grows longer\n    // than its horizontal bounds.\n    var result = '';\n    var lines = text.split('\\n');\n    for (var i = 0; i < lines.length; i++)\n    {\n        var spaceLeft = this.style.wordWrapWidth;\n        var words = lines[i].split(' ');\n        for (var j = 0; j < words.length; j++)\n        {\n            var wordWidth = this.context.measureText(words[j]).width;\n            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n            if(wordWidthWithSpace > spaceLeft)\n            {\n                // Skip printing the newline if it's the first word of the line that is\n                // greater than the word wrap width.\n                if(j > 0)\n                {\n                    result += '\\n';\n                }\n                result += words[j] + ' ';\n                spaceLeft = this.style.wordWrapWidth - wordWidth;\n            }\n            else\n            {\n                spaceLeft -= wordWidthWithSpace;\n                result += words[j] + ' ';\n            }\n        }\n\n        if (i < lines.length-1)\n        {\n            result += '\\n';\n        }\n    }\n    return result;\n};\n\n/**\n * Destroys this text object\n *\n * @method destroy\n * @param destroyTexture {Boolean}\n */\nPIXI.Text.prototype.destroy = function(destroyTexture)\n{\n    if(destroyTexture)\n    {\n        this.texture.destroy();\n    }\n\n};\n\nPIXI.Text.heightCache = {};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Text Object will create a line(s) of text using bitmap font. To split a line you can use '\\n', '\\r' or '\\r\\n'\n * You can generate the fnt files using\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class BitmapText\n * @extends DisplayObjectContainer\n * @constructor\n * @param text {String} The copy that you would like the text to display\n * @param style {Object} The style parameters\n * @param style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)\n * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n */\nPIXI.BitmapText = function(text, style)\n{\n    PIXI.DisplayObjectContainer.call(this);\n\n    this._pool = [];\n\n    this.setText(text);\n    this.setStyle(style);\n    this.updateText();\n    this.dirty = false;\n};\n\n// constructor\nPIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.BitmapText.prototype.constructor = PIXI.BitmapText;\n\n/**\n * Set the copy for the text object\n *\n * @method setText\n * @param text {String} The copy that you would like the text to display\n */\nPIXI.BitmapText.prototype.setText = function(text)\n{\n    this.text = text || ' ';\n    this.dirty = true;\n};\n\n/**\n * Set the style of the text\n * style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)\n * [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n *\n * @method setStyle\n * @param style {Object} The style parameters, contained as properties of an object\n */\nPIXI.BitmapText.prototype.setStyle = function(style)\n{\n    style = style || {};\n    style.align = style.align || 'left';\n    this.style = style;\n\n    var font = style.font.split(' ');\n    this.fontName = font[font.length - 1];\n    this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size;\n\n    this.dirty = true;\n    this.tint = style.tint;\n};\n\n/**\n * Renders text and updates it when needed\n *\n * @method updateText\n * @private\n */\nPIXI.BitmapText.prototype.updateText = function()\n{\n    var data = PIXI.BitmapText.fonts[this.fontName];\n    var pos = new PIXI.Point();\n    var prevCharCode = null;\n    var chars = [];\n    var maxLineWidth = 0;\n    var lineWidths = [];\n    var line = 0;\n    var scale = this.fontSize / data.size;\n    \n\n    for(var i = 0; i < this.text.length; i++)\n    {\n        var charCode = this.text.charCodeAt(i);\n        if(/(?:\\r\\n|\\r|\\n)/.test(this.text.charAt(i)))\n        {\n            lineWidths.push(pos.x);\n            maxLineWidth = Math.max(maxLineWidth, pos.x);\n            line++;\n\n            pos.x = 0;\n            pos.y += data.lineHeight;\n            prevCharCode = null;\n            continue;\n        }\n\n        var charData = data.chars[charCode];\n        if(!charData) continue;\n\n        if(prevCharCode && charData[prevCharCode])\n        {\n            pos.x += charData.kerning[prevCharCode];\n        }\n        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});\n        pos.x += charData.xAdvance;\n\n        prevCharCode = charCode;\n    }\n\n    lineWidths.push(pos.x);\n    maxLineWidth = Math.max(maxLineWidth, pos.x);\n\n    var lineAlignOffsets = [];\n    for(i = 0; i <= line; i++)\n    {\n        var alignOffset = 0;\n        if(this.style.align === 'right')\n        {\n            alignOffset = maxLineWidth - lineWidths[i];\n        }\n        else if(this.style.align === 'center')\n        {\n            alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n        }\n        lineAlignOffsets.push(alignOffset);\n    }\n\n    var lenChildren = this.children.length;\n    var lenChars = chars.length;\n    var tint = this.tint || 0xFFFFFF;\n    for(i = 0; i < lenChars; i++)\n    {\n        var c = i < lenChildren ? this.children[i] : this._pool.pop(); // get old child if have. if not - take from pool.\n\n        if (c) c.setTexture(chars[i].texture); // check if got one before.\n        else c = new PIXI.Sprite(chars[i].texture); // if no create new one.\n\n        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n        c.position.y = chars[i].position.y * scale;\n        c.scale.x = c.scale.y = scale;\n        c.tint = tint;\n        if (!c.parent) this.addChild(c);\n    }\n\n    // remove unnecessary children.\n    // and put their into the pool.\n    while(this.children.length > lenChars)\n    {\n        var child = this.getChildAt(this.children.length - 1);\n        this._pool.push(child);\n        this.removeChild(child);\n    }\n\n\n    /**\n     * [read-only] The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @property textWidth\n     * @type Number\n     */\n    this.textWidth = maxLineWidth * scale;\n\n    /**\n     * [read-only] The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @property textHeight\n     * @type Number\n     */\n    this.textHeight = (pos.y + data.lineHeight) * scale;\n};\n\n/**\n * Updates the transform of this object\n *\n * @method updateTransform\n * @private\n */\nPIXI.BitmapText.prototype.updateTransform = function()\n{\n    if(this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n\n    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);\n};\n\nPIXI.BitmapText.fonts = {};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n \n/**\n * Holds all information related to an Interaction event\n *\n * @class InteractionData\n * @constructor\n */\nPIXI.InteractionData = function()\n{\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @property global\n     * @type Point\n     */\n    this.global = new PIXI.Point();\n\n    // this is here for legacy... but will remove\n    this.local = new PIXI.Point();\n\n    /**\n     * The target Sprite that was interacted with\n     *\n     * @property target\n     * @type Sprite\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @property originalEvent\n     * @type Event\n     */\n    this.originalEvent = null;\n};\n\n/**\n * This will return the local coordinates of the specified displayObject for this InteractionData\n *\n * @method getLocalPosition\n * @param displayObject {DisplayObject} The DisplayObject that you would like the local coords off\n * @return {Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject\n */\nPIXI.InteractionData.prototype.getLocalPosition = function(displayObject)\n{\n    var worldTransform = displayObject.worldTransform;\n    var global = this.global;\n\n    // do a cheeky transform to get the mouse coords;\n    var a00 = worldTransform.a, a01 = worldTransform.b, a02 = worldTransform.tx,\n        a10 = worldTransform.c, a11 = worldTransform.d, a12 = worldTransform.ty,\n        id = 1 / (a00 * a11 + a01 * -a10);\n    // set the mouse coords...\n    return new PIXI.Point(a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id,\n                               a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id);\n};\n\n// constructor\nPIXI.InteractionData.prototype.constructor = PIXI.InteractionData;\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n /**\n * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * @class InteractionManager\n * @constructor\n * @param stage {Stage} The stage to handle interactions\n */\nPIXI.InteractionManager = function(stage)\n{\n    /**\n     * a reference to the stage\n     *\n     * @property stage\n     * @type Stage\n     */\n    this.stage = stage;\n\n    /**\n     * the mouse data\n     *\n     * @property mouse\n     * @type InteractionData\n     */\n    this.mouse = new PIXI.InteractionData();\n\n    /**\n     * an object that stores current touches (InteractionData) by id reference\n     *\n     * @property touchs\n     * @type Object\n     */\n    this.touchs = {};\n\n    // helpers\n    this.tempPoint = new PIXI.Point();\n\n    /**\n     * \n     * @property mouseoverEnabled\n     * @type Boolean\n     * @default\n     */\n    this.mouseoverEnabled = true;\n\n    /**\n     * tiny little interactiveData pool !\n     * \n     * @property pool\n     * @type Array\n     */\n    this.pool = [];\n\n    /**\n     * An array containing all the iterative items from the our interactive tree\n     * @property interactiveItems\n     * @type Array\n     * @private\n     *\n     */\n    this.interactiveItems = [];\n\n    /**\n     * Our canvas\n     * @property interactionDOMElement\n     * @type HTMLCanvasElement\n     * @private\n     */\n    this.interactionDOMElement = null;\n\n    //this will make it so that you dont have to call bind all the time\n    this.onMouseMove = this.onMouseMove.bind( this );\n    this.onMouseDown = this.onMouseDown.bind(this);\n    this.onMouseOut = this.onMouseOut.bind(this);\n    this.onMouseUp = this.onMouseUp.bind(this);\n\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.onTouchMove = this.onTouchMove.bind(this);\n\n    this.last = 0;\n\n    /**\n     * The css style of the cursor that is being used\n     * @property currentCursorStyle\n     * @type String\n     *\n     */\n    this.currentCursorStyle = 'inherit';\n\n    /**\n     * Is set to true when the mouse is moved out of the canvas\n     * @property mouseOut\n     * @type Boolean\n     *\n     */\n    this.mouseOut = false;\n};\n\n// constructor\nPIXI.InteractionManager.prototype.constructor = PIXI.InteractionManager;\n\n/**\n * Collects an interactive sprite recursively to have their interactions managed\n *\n * @method collectInteractiveSprite\n * @param displayObject {DisplayObject} the displayObject to collect\n * @param iParent {DisplayObject} the display object's parent\n * @private\n */\nPIXI.InteractionManager.prototype.collectInteractiveSprite = function(displayObject, iParent)\n{\n    var children = displayObject.children;\n    var length = children.length;\n\n    // make an interaction tree... {item.__interactiveParent}\n    for (var i = length-1; i >= 0; i--)\n    {\n        var child = children[i];\n\n        // push all interactive bits\n        if(child.interactive)\n        {\n            iParent.interactiveChildren = true;\n            //child.__iParent = iParent;\n            this.interactiveItems.push(child);\n\n            if(child.children.length > 0)\n            {\n                this.collectInteractiveSprite(child, child);\n            }\n        }\n        else\n        {\n            child.__iParent = null;\n\n            if(child.children.length > 0)\n            {\n                this.collectInteractiveSprite(child, iParent);\n            }\n        }\n\n    }\n};\n\n/**\n * Sets the target for event delegation\n *\n * @method setTarget\n * @param target {WebGLRenderer|CanvasRenderer} the renderer to bind events to\n * @private\n */\nPIXI.InteractionManager.prototype.setTarget = function(target)\n{\n    this.target = target;\n\n    //check if the dom element has been set. If it has don't do anything\n    if( this.interactionDOMElement === null ) {\n\n        this.setTargetDomElement( target.view );\n    }\n\n    \n};\n\n\n/**\n * Sets the DOM element which will receive mouse/touch events. This is useful for when you have other DOM\n * elements on top of the renderers Canvas element. With this you'll be able to delegate another DOM element\n * to receive those events\n *\n * @method setTargetDomElement\n * @param domElement {DOMElement} the DOM element which will receive mouse and touch events\n * @private\n */\nPIXI.InteractionManager.prototype.setTargetDomElement = function(domElement)\n{\n\n    this.removeEvents();\n\n\n    if (window.navigator.msPointerEnabled)\n    {\n        // time to remove some of that zoom in ja..\n        domElement.style['-ms-content-zooming'] = 'none';\n        domElement.style['-ms-touch-action'] = 'none';\n\n        // DO some window specific touch!\n    }\n\n    this.interactionDOMElement = domElement;\n\n    domElement.addEventListener('mousemove',  this.onMouseMove, true);\n    domElement.addEventListener('mousedown',  this.onMouseDown, true);\n    domElement.addEventListener('mouseout',   this.onMouseOut, true);\n\n    // aint no multi touch just yet!\n    domElement.addEventListener('touchstart', this.onTouchStart, true);\n    domElement.addEventListener('touchend', this.onTouchEnd, true);\n    domElement.addEventListener('touchmove', this.onTouchMove, true);\n\n    document.body.addEventListener('mouseup',  this.onMouseUp, true);\n};\n\n\nPIXI.InteractionManager.prototype.removeEvents = function()\n{\n    if(!this.interactionDOMElement)return;\n\n    this.interactionDOMElement.style['-ms-content-zooming'] = '';\n    this.interactionDOMElement.style['-ms-touch-action'] = '';\n\n    this.interactionDOMElement.removeEventListener('mousemove',  this.onMouseMove, true);\n    this.interactionDOMElement.removeEventListener('mousedown',  this.onMouseDown, true);\n    this.interactionDOMElement.removeEventListener('mouseout',   this.onMouseOut, true);\n\n    // aint no multi touch just yet!\n    this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);\n    this.interactionDOMElement.removeEventListener('touchend', this.onTouchEnd, true);\n    this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);\n\n    this.interactionDOMElement = null;\n\n    document.body.removeEventListener('mouseup',  this.onMouseUp, true);\n};\n\n/**\n * updates the state of interactive objects\n *\n * @method update\n * @private\n */\nPIXI.InteractionManager.prototype.update = function()\n{\n    if(!this.target)return;\n\n    // frequency of 30fps??\n    var now = Date.now();\n    var diff = now - this.last;\n    diff = (diff * PIXI.INTERACTION_FREQUENCY ) / 1000;\n    if(diff < 1)return;\n    this.last = now;\n\n    var i = 0;\n\n    // ok.. so mouse events??\n    // yes for now :)\n    // OPTIMISE - how often to check??\n    if(this.dirty)\n    {\n        this.dirty = false;\n\n        var len = this.interactiveItems.length;\n\n        for (i = 0; i < len; i++) {\n            this.interactiveItems[i].interactiveChildren = false;\n        }\n\n        this.interactiveItems = [];\n\n        if(this.stage.interactive)this.interactiveItems.push(this.stage);\n        // go through and collect all the objects that are interactive..\n        this.collectInteractiveSprite(this.stage, this.stage);\n    }\n\n    // loop through interactive objects!\n    var length = this.interactiveItems.length;\n    var cursor = 'inherit';\n    var over = false;\n\n    for (i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n\n        // OPTIMISATION - only calculate every time if the mousemove function exists..\n        // OK so.. does the object have any other interactive functions?\n        // hit-test the clip!\n       // if(item.mouseover || item.mouseout || item.buttonMode)\n       // {\n        // ok so there are some functions so lets hit test it..\n        item.__hit = this.hitTest(item, this.mouse);\n        this.mouse.target = item;\n        // ok so deal with interactions..\n        // looks like there was a hit!\n        if(item.__hit && !over)\n        {\n            if(item.buttonMode) cursor = item.defaultCursor;\n\n            if(!item.interactiveChildren)over = true;\n\n            if(!item.__isOver)\n            {\n                if(item.mouseover)item.mouseover(this.mouse);\n                item.__isOver = true;\n            }\n        }\n        else\n        {\n            if(item.__isOver)\n            {\n                // roll out!\n                if(item.mouseout)item.mouseout(this.mouse);\n                item.__isOver = false;\n            }\n        }\n    }\n\n    if( this.currentCursorStyle !== cursor )\n    {\n        this.currentCursorStyle = cursor;\n        this.interactionDOMElement.style.cursor = cursor;\n    }\n};\n\n/**\n * Is called when the mouse moves across the renderer element\n *\n * @method onMouseMove\n * @param event {Event} The DOM event of the mouse moving\n * @private\n */\nPIXI.InteractionManager.prototype.onMouseMove = function(event)\n{\n    this.mouse.originalEvent = event || window.event; //IE uses window.event\n    // TODO optimize by not check EVERY TIME! maybe half as often? //\n    var rect = this.interactionDOMElement.getBoundingClientRect();\n\n    this.mouse.global.x = (event.clientX - rect.left) * (this.target.width / rect.width);\n    this.mouse.global.y = (event.clientY - rect.top) * ( this.target.height / rect.height);\n\n    var length = this.interactiveItems.length;\n\n    for (var i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n\n        if(item.mousemove)\n        {\n            //call the function!\n            item.mousemove(this.mouse);\n        }\n    }\n};\n\n/**\n * Is called when the mouse button is pressed down on the renderer element\n *\n * @method onMouseDown\n * @param event {Event} The DOM event of a mouse button being pressed down\n * @private\n */\nPIXI.InteractionManager.prototype.onMouseDown = function(event)\n{\n    this.mouse.originalEvent = event || window.event; //IE uses window.event\n\n    if(PIXI.AUTO_PREVENT_DEFAULT)this.mouse.originalEvent.preventDefault();\n\n    // loop through interaction tree...\n    // hit test each item! ->\n    // get interactive items under point??\n    //stage.__i\n    var length = this.interactiveItems.length;\n\n    // while\n    // hit test\n    for (var i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n\n        if(item.mousedown || item.click)\n        {\n            item.__mouseIsDown = true;\n            item.__hit = this.hitTest(item, this.mouse);\n\n            if(item.__hit)\n            {\n                //call the function!\n                if(item.mousedown)item.mousedown(this.mouse);\n                item.__isDown = true;\n\n                // just the one!\n                if(!item.interactiveChildren)break;\n            }\n        }\n    }\n};\n\n/**\n * Is called when the mouse button is moved out of the renderer element\n *\n * @method onMouseOut\n * @param event {Event} The DOM event of a mouse button being moved out\n * @private \n */\nPIXI.InteractionManager.prototype.onMouseOut = function()\n{\n    var length = this.interactiveItems.length;\n\n    this.interactionDOMElement.style.cursor = 'inherit';\n\n    for (var i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n        if(item.__isOver)\n        {\n            this.mouse.target = item;\n            if(item.mouseout)item.mouseout(this.mouse);\n            item.__isOver = false;\n        }\n    }\n\n    this.mouseOut = true;\n\n    // move the mouse to an impossible position\n    this.mouse.global.x = -10000;\n    this.mouse.global.y = -10000;\n};\n\n/**\n * Is called when the mouse button is released on the renderer element\n *\n * @method onMouseUp\n * @param event {Event} The DOM event of a mouse button being released\n * @private\n */\nPIXI.InteractionManager.prototype.onMouseUp = function(event)\n{\n\n    this.mouse.originalEvent = event || window.event; //IE uses window.event\n\n    var length = this.interactiveItems.length;\n    var up = false;\n\n    for (var i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n\n        item.__hit = this.hitTest(item, this.mouse);\n\n        if(item.__hit && !up)\n        {\n            //call the function!\n            if(item.mouseup)\n            {\n                item.mouseup(this.mouse);\n            }\n            if(item.__isDown)\n            {\n                if(item.click)item.click(this.mouse);\n            }\n\n            if(!item.interactiveChildren)up = true;\n        }\n        else\n        {\n            if(item.__isDown)\n            {\n                if(item.mouseupoutside)item.mouseupoutside(this.mouse);\n            }\n        }\n\n        item.__isDown = false;\n        //}\n    }\n};\n\n/**\n * Tests if the current mouse coordinates hit a sprite\n *\n * @method hitTest\n * @param item {DisplayObject} The displayObject to test for a hit\n * @param interactionData {InteractionData} The interactionData object to update in the case there is a hit\n * @private\n */\nPIXI.InteractionManager.prototype.hitTest = function(item, interactionData)\n{\n    var global = interactionData.global;\n\n    if( !item.worldVisible )return false;\n\n    // temp fix for if the element is in a non visible\n   \n    var isSprite = (item instanceof PIXI.Sprite),\n        worldTransform = item.worldTransform,\n        a00 = worldTransform.a, a01 = worldTransform.b, a02 = worldTransform.tx,\n        a10 = worldTransform.c, a11 = worldTransform.d, a12 = worldTransform.ty,\n        id = 1 / (a00 * a11 + a01 * -a10),\n        x = a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id,\n        y = a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id;\n\n    interactionData.target = item;\n\n    //a sprite or display object with a hit area defined\n    if(item.hitArea && item.hitArea.contains) {\n        if(item.hitArea.contains(x, y)) {\n            //if(isSprite)\n            interactionData.target = item;\n\n            return true;\n        }\n\n        return false;\n    }\n    // a sprite with no hitarea defined\n    else if(isSprite)\n    {\n        var width = item.texture.frame.width,\n            height = item.texture.frame.height,\n            x1 = -width * item.anchor.x,\n            y1;\n\n        if(x > x1 && x < x1 + width)\n        {\n            y1 = -height * item.anchor.y;\n\n            if(y > y1 && y < y1 + height)\n            {\n                // set the target property if a hit is true!\n                interactionData.target = item;\n                return true;\n            }\n        }\n    }\n\n    var length = item.children.length;\n\n    for (var i = 0; i < length; i++)\n    {\n        var tempItem = item.children[i];\n        var hit = this.hitTest(tempItem, interactionData);\n        if(hit)\n        {\n            // hmm.. TODO SET CORRECT TARGET?\n            interactionData.target = item;\n            return true;\n        }\n    }\n\n    return false;\n};\n\n/**\n * Is called when a touch is moved across the renderer element\n *\n * @method onTouchMove\n * @param event {Event} The DOM event of a touch moving across the renderer view\n * @private\n */\nPIXI.InteractionManager.prototype.onTouchMove = function(event)\n{\n    var rect = this.interactionDOMElement.getBoundingClientRect();\n    var changedTouches = event.changedTouches;\n    var touchData;\n    var i = 0;\n\n    for (i = 0; i < changedTouches.length; i++)\n    {\n        var touchEvent = changedTouches[i];\n        touchData = this.touchs[touchEvent.identifier];\n        touchData.originalEvent =  event || window.event;\n\n        // update the touch position\n        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);\n        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);\n        if(navigator.isCocoonJS) {\n            touchData.global.x = touchEvent.clientX;\n            touchData.global.y = touchEvent.clientY;\n        }\n    }\n\n    var length = this.interactiveItems.length;\n    for (i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n        if(item.touchmove)\n            item.touchmove(touchData);\n    }\n};\n\n/**\n * Is called when a touch is started on the renderer element\n *\n * @method onTouchStart\n * @param event {Event} The DOM event of a touch starting on the renderer view\n * @private\n */\nPIXI.InteractionManager.prototype.onTouchStart = function(event)\n{\n    var rect = this.interactionDOMElement.getBoundingClientRect();\n\n    if(PIXI.AUTO_PREVENT_DEFAULT)event.preventDefault();\n    \n    var changedTouches = event.changedTouches;\n    for (var i=0; i < changedTouches.length; i++)\n    {\n        var touchEvent = changedTouches[i];\n\n        var touchData = this.pool.pop();\n        if(!touchData)touchData = new PIXI.InteractionData();\n\n        touchData.originalEvent =  event || window.event;\n\n        this.touchs[touchEvent.identifier] = touchData;\n        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);\n        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);\n        if(navigator.isCocoonJS) {\n            touchData.global.x = touchEvent.clientX;\n            touchData.global.y = touchEvent.clientY;\n        }\n\n        var length = this.interactiveItems.length;\n\n        for (var j = 0; j < length; j++)\n        {\n            var item = this.interactiveItems[j];\n\n            if(item.touchstart || item.tap)\n            {\n                item.__hit = this.hitTest(item, touchData);\n\n                if(item.__hit)\n                {\n                    //call the function!\n                    if(item.touchstart)item.touchstart(touchData);\n                    item.__isDown = true;\n                    item.__touchData = touchData;\n\n                    if(!item.interactiveChildren)break;\n                }\n            }\n        }\n    }\n};\n\n/**\n * Is called when a touch is ended on the renderer element\n *\n * @method onTouchEnd\n * @param event {Event} The DOM event of a touch ending on the renderer view\n * @private\n */\nPIXI.InteractionManager.prototype.onTouchEnd = function(event)\n{\n    //this.mouse.originalEvent = event || window.event; //IE uses window.event\n    var rect = this.interactionDOMElement.getBoundingClientRect();\n    var changedTouches = event.changedTouches;\n\n    for (var i=0; i < changedTouches.length; i++)\n    {\n        var touchEvent = changedTouches[i];\n        var touchData = this.touchs[touchEvent.identifier];\n        var up = false;\n        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);\n        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);\n        if(navigator.isCocoonJS) {\n            touchData.global.x = touchEvent.clientX;\n            touchData.global.y = touchEvent.clientY;\n        }\n\n        var length = this.interactiveItems.length;\n        for (var j = 0; j < length; j++)\n        {\n            var item = this.interactiveItems[j];\n            var itemTouchData = item.__touchData; // <-- Here!\n            item.__hit = this.hitTest(item, touchData);\n\n            if(itemTouchData === touchData)\n            {\n                // so this one WAS down...\n                touchData.originalEvent = event || window.event;\n                // hitTest??\n\n                if(item.touchend || item.tap)\n                {\n                    if(item.__hit && !up)\n                    {\n                        if(item.touchend)item.touchend(touchData);\n                        if(item.__isDown)\n                        {\n                            if(item.tap)item.tap(touchData);\n                        }\n\n                        if(!item.interactiveChildren)up = true;\n                    }\n                    else\n                    {\n                        if(item.__isDown)\n                        {\n                            if(item.touchendoutside)item.touchendoutside(touchData);\n                        }\n                    }\n\n                    item.__isDown = false;\n                }\n\n                item.__touchData = null;\n\n            }\n            /*\n            else\n            {\n\n            }\n            */\n        }\n        // remove the touch..\n        this.pool.push(touchData);\n        this.touchs[touchEvent.identifier] = null;\n    }\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Stage represents the root of the display tree. Everything connected to the stage is rendered\n *\n * @class Stage\n * @extends DisplayObjectContainer\n * @constructor\n * @param backgroundColor {Number} the background color of the stage, you have to pass this in is in hex format\n *      like: 0xFFFFFF for white\n * \n * Creating a stage is a mandatory process when you use Pixi, which is as simple as this : \n * var stage = new PIXI.Stage(0xFFFFFF);\n * where the parameter given is the background colour of the stage, in hex\n * you will use this stage instance to add your sprites to it and therefore to the renderer\n * Here is how to add a sprite to the stage : \n * stage.addChild(sprite);\n */\nPIXI.Stage = function(backgroundColor)\n{\n    PIXI.DisplayObjectContainer.call( this );\n\n    /**\n     * [read-only] Current transform of the object based on world (parent) factors\n     *\n     * @property worldTransform\n     * @type Mat3\n     * @readOnly\n     * @private\n     */\n    this.worldTransform = new PIXI.Matrix();\n\n    /**\n     * Whether or not the stage is interactive\n     *\n     * @property interactive\n     * @type Boolean\n     */\n    this.interactive = true;\n\n    /**\n     * The interaction manage for this stage, manages all interactive activity on the stage\n     *\n     * @property interactive\n     * @type InteractionManager\n     */\n    this.interactionManager = new PIXI.InteractionManager(this);\n\n    /**\n     * Whether the stage is dirty and needs to have interactions updated\n     *\n     * @property dirty\n     * @type Boolean\n     * @private\n     */\n    this.dirty = true;\n\n    //the stage is its own stage\n    this.stage = this;\n\n    //optimize hit detection a bit\n    this.stage.hitArea = new PIXI.Rectangle(0,0,100000, 100000);\n\n    this.setBackgroundColor(backgroundColor);\n};\n\n// constructor\nPIXI.Stage.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Stage.prototype.constructor = PIXI.Stage;\n\n/**\n * Sets another DOM element which can receive mouse/touch interactions instead of the default Canvas element.\n * This is useful for when you have other DOM elements on top of the Canvas element.\n *\n * @method setInteractionDelegate\n * @param domElement {DOMElement} This new domElement which will receive mouse/touch events\n */\nPIXI.Stage.prototype.setInteractionDelegate = function(domElement)\n{\n    this.interactionManager.setTargetDomElement( domElement );\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.Stage.prototype.updateTransform = function()\n{\n    this.worldAlpha = 1;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n    if(this.dirty)\n    {\n        this.dirty = false;\n        // update interactive!\n        this.interactionManager.dirty = true;\n    }\n\n    if(this.interactive)this.interactionManager.update();\n};\n\n/**\n * Sets the background color for the stage\n *\n * @method setBackgroundColor\n * @param backgroundColor {Number} the color of the background, easiest way to pass this in is in hex format\n *      like: 0xFFFFFF for white\n */\nPIXI.Stage.prototype.setBackgroundColor = function(backgroundColor)\n{\n    this.backgroundColor = backgroundColor || 0x000000;\n    this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);\n    var hex = this.backgroundColor.toString(16);\n    hex = '000000'.substr(0, 6 - hex.length) + hex;\n    this.backgroundColorString = '#' + hex;\n};\n\n/**\n * This will return the point containing global coords of the mouse.\n *\n * @method getMousePosition\n * @return {Point} The point containing the coords of the global InteractionData position.\n */\nPIXI.Stage.prototype.getMousePosition = function()\n{\n    return this.interactionManager.mouse.global;\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n \n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n/**\n * A polyfill for requestAnimationFrame\n * You can actually use both requestAnimationFrame and requestAnimFrame, \n * you will still benefit from the polyfill\n *\n * @method requestAnimationFrame\n */\n/**\n * A polyfill for cancelAnimationFrame\n *\n * @method cancelAnimationFrame\n */\nvar lastTime = 0;\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\nfor(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n        window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback) {\n        var currTime = new Date().getTime();\n        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n          timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n    };\n}\n\nif (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n        clearTimeout(id);\n    };\n}\n\nwindow.requestAnimFrame = window.requestAnimationFrame;\n\n/**\n * Converts a hex color number to an [R, G, B] array\n *\n * @method hex2rgb\n * @param hex {Number}\n */\nPIXI.hex2rgb = function(hex) {\n    return [(hex >> 16 & 0xFF) / 255, ( hex >> 8 & 0xFF) / 255, (hex & 0xFF)/ 255];\n};\n\n/**\n * Converts a color as an [R, G, B] array to a hex number\n *\n * @method rgb2hex\n * @param rgb {Array}\n */\nPIXI.rgb2hex = function(rgb) {\n    return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);\n};\n\n/**\n * A polyfill for Function.prototype.bind\n *\n * @method bind\n */\nif (typeof Function.prototype.bind !== 'function') {\n    Function.prototype.bind = (function () {\n        var slice = Array.prototype.slice;\n        return function (thisArg) {\n            var target = this, boundArgs = slice.call(arguments, 1);\n\n            if (typeof target !== 'function') throw new TypeError();\n\n            function bound() {\n                var args = boundArgs.concat(slice.call(arguments));\n                target.apply(this instanceof bound ? this : thisArg, args);\n            }\n\n            bound.prototype = (function F(proto) {\n                if (proto) F.prototype = proto;\n                if (!(this instanceof F)) return new F();\n            })(target.prototype);\n\n            return bound;\n        };\n    })();\n}\n\n/**\n * A wrapper for ajax requests to be handled cross browser\n *\n * @class AjaxRequest\n * @constructor\n */\nPIXI.AjaxRequest = function()\n{\n    var activexmodes = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP']; //activeX versions to check for in IE\n\n    if (window.ActiveXObject)\n    { //Test for support for ActiveXObject in IE first (as XMLHttpRequest in IE7 is broken)\n        for (var i=0; i<activexmodes.length; i++)\n        {\n            try{\n                return new window.ActiveXObject(activexmodes[i]);\n            }\n            catch(e) {\n                //suppress error\n            }\n        }\n    }\n    else if (window.XMLHttpRequest) // if Mozilla, Safari etc\n    {\n        return new window.XMLHttpRequest();\n    }\n    else\n    {\n        return false;\n    }\n};\n/*\nPIXI.packColorRGBA = function(r, g, b, a)//r, g, b, a)\n{\n  //  console.log(r, b, c, d)\n  return (Math.floor((r)*63) << 18) | (Math.floor((g)*63) << 12) | (Math.floor((b)*63) << 6);// | (Math.floor((a)*63))\n  //  i = i | (Math.floor((a)*63));\n   // return i;\n   // var r = (i / 262144.0 ) / 64;\n   // var g = (i / 4096.0)%64 / 64;\n  //  var b = (i / 64.0)%64 / 64;\n  //  var a = (i)%64 / 64;\n     \n  //  console.log(r, g, b, a);\n  //  return i;\n\n};\n*/\n/*\nPIXI.packColorRGB = function(r, g, b)//r, g, b, a)\n{\n    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));\n};\n\nPIXI.unpackColorRGB = function(r, g, b)//r, g, b, a)\n{\n    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));\n};\n*/\n\n/**\n * Checks whether the Canvas BlendModes are supported by the current browser\n *\n * @method canUseNewCanvasBlendModes\n * @return {Boolean} whether they are supported\n */\nPIXI.canUseNewCanvasBlendModes = function()\n{\n    var canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = 1;\n    var context = canvas.getContext('2d');\n    context.fillStyle = '#000';\n    context.fillRect(0,0,1,1);\n    context.globalCompositeOperation = 'multiply';\n    context.fillStyle = '#fff';\n    context.fillRect(0,0,1,1);\n    return context.getImageData(0,0,1,1).data[0] === 0;\n};\n\n/**\n * Given a number, this function returns the closest number that is a power of two\n * this function is taken from Starling Framework as its pretty neat ;)\n *\n * @method getNextPowerOfTwo\n * @param number {Number}\n * @return {Number} the closest number that is a power of two\n */\nPIXI.getNextPowerOfTwo = function(number)\n{\n    if (number > 0 && (number & (number - 1)) === 0) // see: http://goo.gl/D9kPj\n        return number;\n    else\n    {\n        var result = 1;\n        while (result < number) result <<= 1;\n        return result;\n    }\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n \n/**\n * https://github.com/mrdoob/eventtarget.js/\n * THankS mr DOob!\n */\n\n/**\n * Adds event emitter functionality to a class\n *\n * @class EventTarget\n * @example\n *      function MyEmitter() {\n *          PIXI.EventTarget.call(this); //mixes in event target stuff\n *      }\n *\n *      var em = new MyEmitter();\n *      em.emit({ type: 'eventName', data: 'some data' });\n */\nPIXI.EventTarget = function () {\n\n    /**\n     * Holds all the listeners\n     *\n     * @property listeneners\n     * @type Object\n     */\n    var listeners = {};\n\n    /**\n     * Adds a listener for a specific event\n     *\n     * @method addEventListener\n     * @param type {string} A string representing the event type to listen for.\n     * @param listener {function} The callback function that will be fired when the event occurs\n     */\n    this.addEventListener = this.on = function ( type, listener ) {\n\n\n        if ( listeners[ type ] === undefined ) {\n\n            listeners[ type ] = [];\n\n        }\n\n        if ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n            listeners[ type ].push( listener );\n        }\n\n    };\n\n    /**\n     * Fires the event, ie pretends that the event has happened\n     *\n     * @method dispatchEvent\n     * @param event {Event} the event object\n     */\n    this.dispatchEvent = this.emit = function ( event ) {\n\n        if ( !listeners[ event.type ] || !listeners[ event.type ].length ) {\n\n            return;\n\n        }\n\n        for(var i = 0, l = listeners[ event.type ].length; i < l; i++) {\n\n            listeners[ event.type ][ i ]( event );\n\n        }\n\n    };\n\n    /**\n     * Removes the specified listener that was assigned to the specified event type\n     *\n     * @method removeEventListener\n     * @param type {string} A string representing the event type which will have its listener removed\n     * @param listener {function} The callback function that was be fired when the event occured\n     */\n    this.removeEventListener = this.off = function ( type, listener ) {\n\n        var index = listeners[ type ].indexOf( listener );\n\n        if ( index !== - 1 ) {\n\n            listeners[ type ].splice( index, 1 );\n\n        }\n\n    };\n\n    /**\n     * Removes all the listeners that were active for the specified event type\n     *\n     * @method removeAllEventListeners\n     * @param type {string} A string representing the event type which will have all its listeners removed\n     */\n\tthis.removeAllEventListeners = function( type ) {\n\t\tvar a = listeners[type];\n\t\tif (a)\n\t\t\ta.length = 0;\n\t};\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This helper function will automatically detect which renderer you should be using.\n * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by\n * the browser then this function will return a canvas renderer\n * @class autoDetectRenderer\n * @static\n * @param width=800 {Number} the width of the renderers view\n * @param height=600 {Number} the height of the renderers view\n * @param [view] {Canvas} the canvas to use as a view, optional \n * @param [transparent=false] {Boolean} the transparency of the render view, default false\n * @param [antialias=false] {Boolean} sets antialias (only applicable in webGL chrome at the moment)\n *\n */\nPIXI.autoDetectRenderer = function(width, height, view, transparent, antialias)\n{\n    if(!width)width = 800;\n    if(!height)height = 600;\n\n    // BORROWED from Mr Doob (mrdoob.com)\n    var webgl = ( function () { try {\n                                    var canvas = document.createElement( 'canvas' );\n                                    return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );\n                                } catch( e ) {\n                                    return false;\n                                }\n                            } )();\n\n\n    if( webgl )\n    {\n        return new PIXI.WebGLRenderer(width, height, view, transparent, antialias);\n    }\n\n    return  new PIXI.CanvasRenderer(width, height, view, transparent);\n};\n\r\n/*\n    PolyK library\n    url: http://polyk.ivank.net\n    Released under MIT licence.\n\n    Copyright (c) 2012 Ivan Kuckir\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\n    This is an amazing lib!\n\n    slightly modified by Mat Groves (matgroves.com);\n*/\n\n/**\n * Based on the Polyk library http://polyk.ivank.net released under MIT licence.\n * This is an amazing lib!\n * slightly modified by Mat Groves (matgroves.com);\n * @class PolyK\n *\n */\nPIXI.PolyK = {};\n\n/**\n * Triangulates shapes for webGL graphic fills\n *\n * @method Triangulate\n * \n */\nPIXI.PolyK.Triangulate = function(p)\n{\n    var sign = true;\n\n    var n = p.length >> 1;\n    if(n < 3) return [];\n\n    var tgs = [];\n    var avl = [];\n    for(var i = 0; i < n; i++) avl.push(i);\n\n    i = 0;\n    var al = n;\n    while(al > 3)\n    {\n        var i0 = avl[(i+0)%al];\n        var i1 = avl[(i+1)%al];\n        var i2 = avl[(i+2)%al];\n\n        var ax = p[2*i0],  ay = p[2*i0+1];\n        var bx = p[2*i1],  by = p[2*i1+1];\n        var cx = p[2*i2],  cy = p[2*i2+1];\n\n        var earFound = false;\n        if(PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign))\n        {\n            earFound = true;\n            for(var j = 0; j < al; j++)\n            {\n                var vi = avl[j];\n                if(vi === i0 || vi === i1 || vi === i2) continue;\n\n                if(PIXI.PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {\n                    earFound = false;\n                    break;\n                }\n            }\n        }\n\n        if(earFound)\n        {\n            tgs.push(i0, i1, i2);\n            avl.splice((i+1)%al, 1);\n            al--;\n            i = 0;\n        }\n        else if(i++ > 3*al)\n        {\n            // need to flip flip reverse it!\n            // reset!\n            if(sign)\n            {\n                tgs = [];\n                avl = [];\n                for(i = 0; i < n; i++) avl.push(i);\n\n                i = 0;\n                al = n;\n\n                sign = false;\n            }\n            else\n            {\n                window.console.log(\"PIXI Warning: shape too complex to fill\");\n                return [];\n            }\n        }\n    }\n\n    tgs.push(avl[0], avl[1], avl[2]);\n    return tgs;\n};\n\n/**\n * Checks whether a point is within a triangle\n *\n * @method _PointInTriangle\n * @param px {Number} x coordinate of the point to test\n * @param py {Number} y coordinate of the point to test\n * @param ax {Number} x coordinate of the a point of the triangle\n * @param ay {Number} y coordinate of the a point of the triangle\n * @param bx {Number} x coordinate of the b point of the triangle\n * @param by {Number} y coordinate of the b point of the triangle\n * @param cx {Number} x coordinate of the c point of the triangle\n * @param cy {Number} y coordinate of the c point of the triangle\n * @private\n */\nPIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)\n{\n    var v0x = cx-ax;\n    var v0y = cy-ay;\n    var v1x = bx-ax;\n    var v1y = by-ay;\n    var v2x = px-ax;\n    var v2y = py-ay;\n\n    var dot00 = v0x*v0x+v0y*v0y;\n    var dot01 = v0x*v1x+v0y*v1y;\n    var dot02 = v0x*v2x+v0y*v2y;\n    var dot11 = v1x*v1x+v1y*v1y;\n    var dot12 = v1x*v2x+v1y*v2y;\n\n    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // Check if point is in triangle\n    return (u >= 0) && (v >= 0) && (u + v < 1);\n};\n\n/**\n * Checks whether a shape is convex\n *\n * @method _convex\n * \n * @private\n */\nPIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign)\n{\n    return ((ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0) === sign;\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n// TODO Alvin and Mat\n// Should we eventually create a Utils class ? \n// Or just move this file to the pixi.js file ?\nPIXI.initDefaultShaders = function()\n{\n   \n  //  PIXI.stripShader = new PIXI.StripShader();\n//    PIXI.stripShader.init();\n\n};\n\nPIXI.CompileVertexShader = function(gl, shaderSrc)\n{\n    return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);\n};\n\nPIXI.CompileFragmentShader = function(gl, shaderSrc)\n{\n    return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);\n};\n\nPIXI._CompileShader = function(gl, shaderSrc, shaderType)\n{\n    var src = shaderSrc.join(\"\\n\");\n    var shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        window.console.log(gl.getShaderInfoLog(shader));\n        return null;\n    }\n\n    return shader;\n};\n\nPIXI.compileProgram = function(gl, vertexSrc, fragmentSrc)\n{\n    var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);\n    var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);\n\n    var shaderProgram = gl.createProgram();\n\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n        window.console.log(\"Could not initialise shaders\");\n    }\n\n    return shaderProgram;\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * @author Richard Davey http://www.photonstorm.com @photonstorm\n */\n\n/**\n* @class PixiShader\n* @constructor\n*/\nPIXI.PixiShader = function(gl)\n{\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n    * @property {any} program - The WebGL program.\n    */\n    this.program = null;\n\n    /**\n    * @property {array} fragmentSrc - The fragment shader.\n    */\n    this.fragmentSrc = [\n        'precision lowp float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D uSampler;',\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n        '}'\n    ];\n\n\n    /**\n    * @property {number} textureCount - A local texture counter for multi-texture shaders.\n    */\n    this.textureCount = 0;\n\n    this.attributes = [];\n\n    this.init();\n};\n\n/**\n* Initialises the shader\n* @method init\n*\n*/\nPIXI.PixiShader.prototype.init = function()\n{\n\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);\n    \n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n\n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its something to do with the current state of the gl context.\n    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if(this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];\n\n    // End worst hack eva //\n\n    // add those custom shaders!\n    for (var key in this.uniforms)\n    {\n        // get the uniform locations..\n        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);\n    }\n\n    this.initUniforms();\n\n    this.program = program;\n};\n\n/**\n* Initialises the shader uniform values.\n* Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\n* http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n*\n* @method initUniforms\n*/\nPIXI.PixiShader.prototype.initUniforms = function()\n{\n    this.textureCount = 1;\n    var gl = this.gl;\n    var uniform;\n\n    for (var key in this.uniforms)\n    {\n        uniform = this.uniforms[key];\n\n        var type = uniform.type;\n\n        if (type === 'sampler2D')\n        {\n            uniform._init = false;\n\n            if (uniform.value !== null)\n            {\n                this.initSampler2D(uniform);\n            }\n        }\n        else if (type === 'mat2' || type === 'mat3' || type === 'mat4')\n        {\n            //  These require special handling\n            uniform.glMatrix = true;\n            uniform.glValueLength = 1;\n\n            if (type === 'mat2')\n            {\n                uniform.glFunc = gl.uniformMatrix2fv;\n            }\n            else if (type === 'mat3')\n            {\n                uniform.glFunc = gl.uniformMatrix3fv;\n            }\n            else if (type === 'mat4')\n            {\n                uniform.glFunc = gl.uniformMatrix4fv;\n            }\n        }\n        else\n        {\n            //  GL function reference\n            uniform.glFunc = gl['uniform' + type];\n\n            if (type === '2f' || type === '2i')\n            {\n                uniform.glValueLength = 2;\n            }\n            else if (type === '3f' || type === '3i')\n            {\n                uniform.glValueLength = 3;\n            }\n            else if (type === '4f' || type === '4i')\n            {\n                uniform.glValueLength = 4;\n            }\n            else\n            {\n                uniform.glValueLength = 1;\n            }\n        }\n    }\n\n};\n\n/**\n* Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)\n*\n* @method initSampler2D\n*/\nPIXI.PixiShader.prototype.initSampler2D = function(uniform)\n{\n    if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n\n    gl.activeTexture(gl['TEXTURE' + this.textureCount]);\n    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTexture);\n\n    //  Extended texture data\n    if (uniform.textureData)\n    {\n        var data = uniform.textureData;\n\n        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);\n        // GLTextureLinear = mag/min linear, wrap clamp\n        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat\n        // GLTextureNearest = mag/min nearest, wrap clamp\n        // AudioTexture = whatever + luminance + width 512, height 2, border 0\n        // KeyTexture = whatever + luminance + width 256, height 2, border 0\n\n        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\n        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\n\n        var magFilter = (data.magFilter) ? data.magFilter : gl.LINEAR;\n        var minFilter = (data.minFilter) ? data.minFilter : gl.LINEAR;\n        var wrapS = (data.wrapS) ? data.wrapS : gl.CLAMP_TO_EDGE;\n        var wrapT = (data.wrapT) ? data.wrapT : gl.CLAMP_TO_EDGE;\n        var format = (data.luminance) ? gl.LUMINANCE : gl.RGBA;\n\n        if (data.repeat)\n        {\n            wrapS = gl.REPEAT;\n            wrapT = gl.REPEAT;\n        }\n\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\n\n        if (data.width)\n        {\n            var width = (data.width) ? data.width : 512;\n            var height = (data.height) ? data.height : 2;\n            var border = (data.border) ? data.border : 0;\n\n            // void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\n        }\n        else\n        {\n            //  void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels);\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);\n        }\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n    }\n\n    gl.uniform1i(uniform.uniformLocation, this.textureCount);\n\n    uniform._init = true;\n\n    this.textureCount++;\n\n};\n\n/**\n* Updates the shader uniform values.\n*\n* @method syncUniforms\n*/\nPIXI.PixiShader.prototype.syncUniforms = function()\n{\n    this.textureCount = 1;\n    var uniform;\n    var gl = this.gl;\n\n    //  This would probably be faster in an array and it would guarantee key order\n    for (var key in this.uniforms)\n    {\n\n        uniform = this.uniforms[key];\n\n        if (uniform.glValueLength === 1)\n        {\n            if (uniform.glMatrix === true)\n            {\n                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);\n            }\n            else\n            {\n                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);\n            }\n        }\n        else if (uniform.glValueLength === 2)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);\n        }\n        else if (uniform.glValueLength === 3)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);\n        }\n        else if (uniform.glValueLength === 4)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);\n        }\n        else if (uniform.type === 'sampler2D')\n        {\n            if (uniform._init)\n            {\n                gl.activeTexture(gl['TEXTURE' + this.textureCount]);\n                gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture( uniform.value.baseTexture, gl));\n                gl.uniform1i(uniform.uniformLocation, this.textureCount);\n                this.textureCount++;\n            }\n            else\n            {\n                this.initSampler2D(uniform);\n            }\n        }\n    }\n\n};\n\n/**\n* Destroys the shader\n* @method destroy\n*\n*/\nPIXI.PixiShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n*\n* @property defaultVertexSrc\n* @type String\n*/\nPIXI.PixiShader.defaultVertexSrc = [\n    'attribute vec2 aVertexPosition;',\n    'attribute vec2 aTextureCoord;',\n    'attribute vec2 aColor;',\n\n    'uniform vec2 projectionVector;',\n    'uniform vec2 offsetVector;',\n\n    'varying vec2 vTextureCoord;',\n    'varying vec4 vColor;',\n\n    'const vec2 center = vec2(-1.0, 1.0);',\n\n    'void main(void) {',\n    '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);',\n    '   vTextureCoord = aTextureCoord;',\n    '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',\n    '   vColor = vec4(color * aColor.x, aColor.x);',\n    '}'\n];\n\n\n\n\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * @author Richard Davey http://www.photonstorm.com @photonstorm\n */\n\n/**\n* @class PixiFastShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PixiFastShader = function(gl)\n{\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * @property {any} program - The WebGL program.\n     */\n    this.program = null;\n\n    /**\n     * @property {array} fragmentSrc - The fragment shader.\n     */\n    this.fragmentSrc = [\n        'precision lowp float;',\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n        'uniform sampler2D uSampler;',\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n        '}'\n    ];\n\n    /**\n    * @property {array} vertexSrc - The vertex shader\n    */\n    this.vertexSrc = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aPositionCoord;',\n        'attribute vec2 aScale;',\n        'attribute float aRotation;',\n        'attribute vec2 aTextureCoord;',\n        'attribute float aColor;',\n\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        'uniform mat3 uMatrix;',\n\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n\n        'const vec2 center = vec2(-1.0, 1.0);',\n\n        'void main(void) {',\n        '   vec2 v;',\n        '   vec2 sv = aVertexPosition * aScale;',\n        '   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);',\n        '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);',\n        '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;',\n        '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);',\n        '   vTextureCoord = aTextureCoord;',\n      //  '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',\n        '   vColor = aColor;',\n        '}'\n    ];\n\n\n    /**\n    * @property {number} textureCount - A local texture counter for multi-texture shaders.\n    */\n    this.textureCount = 0;\n\n    \n    this.init();\n};\n\n/**\n* Initialises the shader\n* @method init\n*\n*/\nPIXI.PixiFastShader.prototype.init = function()\n{\n\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    \n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n    this.uMatrix = gl.getUniformLocation(program, 'uMatrix');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aPositionCoord = gl.getAttribLocation(program, 'aPositionCoord');\n\n    this.aScale = gl.getAttribLocation(program, 'aScale');\n    this.aRotation = gl.getAttribLocation(program, 'aRotation');\n\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n   \n\n   \n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its somthing to do with the current state of the gl context.\n    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if(this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [this.aVertexPosition, this.aPositionCoord,  this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute];\n    \n    // End worst hack eva //\n\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader\n* @method destroy\n*\n*/\nPIXI.PixiFastShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\nPIXI.StripShader = function()\n{\n    /**\n    * @property {any} program - The WebGL program.\n    */\n    this.program = null;\n\n    /**\n     * @property {array} fragmentSrc - The fragment shader.\n     */\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n        'uniform float alpha;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));',\n        '   gl_FragColor = gl_FragColor * alpha;',\n        '}'\n    ];\n\n    /**\n    * @property {array} fragmentSrc - The fragment shader.\n    */\n    this.vertexSrc = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aTextureCoord;',\n        'attribute float aColor;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'varying vec2 vTextureCoord;',\n        'uniform vec2 offsetVector;',\n        'varying float vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / projectionVector.y + 1.0 , 0.0, 1.0);',\n        '   vTextureCoord = aTextureCoord;',\n        '   vColor = aColor;',\n        '}'\n    ];\n};\n\n/**\n* Initialises the shader\n* @method init\n*\n*/\nPIXI.StripShader.prototype.init = function()\n{\n\n    var gl = PIXI.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n    //this.dimensions = gl.getUniformLocation(this.program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PrimitiveShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PrimitiveShader = function(gl)\n{\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n    * @property {any} program - The WebGL program.\n    */\n    this.program = null;\n\n    /**\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   gl_FragColor = vColor;',\n        '}'\n    ];\n\n    /**\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc  = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec4 aColor;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        'uniform float alpha;',\n        'uniform vec3 tint;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',\n        '   vColor = aColor * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\n/**\n* Initialises the shader\n* @method init\n*\n*/\nPIXI.PrimitiveShader.prototype.init = function()\n{\n\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.tintColor = gl.getUniformLocation(program, 'tint');\n\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    this.attributes = [this.aVertexPosition, this.colorAttribute];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader\n* @method destroy\n*\n*/\nPIXI.PrimitiveShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attribute = null;\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A set of functions used by the webGL renderer to draw the primitive graphics data\n *\n * @class WebGLGraphics\n * @private\n * @static\n */\nPIXI.WebGLGraphics = function()\n{\n\n};\n\n/**\n * Renders the graphics object\n *\n * @static\n * @private\n * @method renderGraphics\n * @param graphics {Graphics}\n * @param renderSession {Object}\n */\nPIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession)//projection, offset)\n{\n    var gl = renderSession.gl;\n    var projection = renderSession.projection,\n        offset = renderSession.offset,\n        shader = renderSession.shaderManager.primitiveShader;\n\n    if(!graphics._webGL[gl.id])graphics._webGL[gl.id] = {points:[], indices:[], lastIndex:0,\n                                           buffer:gl.createBuffer(),\n                                           indexBuffer:gl.createBuffer()};\n\n    var webGL = graphics._webGL[gl.id];\n\n    if(graphics.dirty)\n    {\n        graphics.dirty = false;\n\n        if(graphics.clearDirty)\n        {\n            graphics.clearDirty = false;\n\n            webGL.lastIndex = 0;\n            webGL.points = [];\n            webGL.indices = [];\n\n        }\n\n        PIXI.WebGLGraphics.updateGraphics(graphics, gl);\n    }\n\n    renderSession.shaderManager.activatePrimitiveShader();\n\n    // This  could be speeded up for sure!\n\n    // set the matrix transform\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n    gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));\n\n    gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n    gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n\n    gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));\n\n    gl.uniform1f(shader.alpha, graphics.worldAlpha);\n    gl.bindBuffer(gl.ARRAY_BUFFER, webGL.buffer);\n\n    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);\n    gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);\n\n    // set the index buffer!\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGL.indexBuffer);\n\n    gl.drawElements(gl.TRIANGLE_STRIP,  webGL.indices.length, gl.UNSIGNED_SHORT, 0 );\n\n    renderSession.shaderManager.deactivatePrimitiveShader();\n\n    // return to default shader...\n//  PIXI.activateShader(PIXI.defaultShader);\n};\n\n/**\n * Updates the graphics object\n *\n * @static\n * @private\n * @method updateGraphics\n * @param graphicsData {Graphics} The graphics object to update\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLGraphics.updateGraphics = function(graphics, gl)\n{\n    var webGL = graphics._webGL[gl.id];\n    \n    for (var i = webGL.lastIndex; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n\n        if(data.type === PIXI.Graphics.POLY)\n        {\n            if(data.fill)\n            {\n                if(data.points.length>3)\n                    PIXI.WebGLGraphics.buildPoly(data, webGL);\n            }\n\n            if(data.lineWidth > 0)\n            {\n                PIXI.WebGLGraphics.buildLine(data, webGL);\n            }\n        }\n        else if(data.type === PIXI.Graphics.RECT)\n        {\n            PIXI.WebGLGraphics.buildRectangle(data, webGL);\n        }\n        else if(data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP)\n        {\n            PIXI.WebGLGraphics.buildCircle(data, webGL);\n        }\n    }\n\n    webGL.lastIndex = graphics.graphicsData.length;\n\n   \n\n    webGL.glPoints = new Float32Array(webGL.points);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, webGL.buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, webGL.glPoints, gl.STATIC_DRAW);\n\n    webGL.glIndicies = new Uint16Array(webGL.indices);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGL.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, webGL.glIndicies, gl.STATIC_DRAW);\n};\n\n/**\n * Builds a rectangle to draw\n *\n * @static\n * @private\n * @method buildRectangle\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData)\n{\n    // --- //\n    // need to convert points to a nice regular data\n    //\n    var rectData = graphicsData.points;\n    var x = rectData[0];\n    var y = rectData[1];\n    var width = rectData[2];\n    var height = rectData[3];\n\n\n    if(graphicsData.fill)\n    {\n        var color = PIXI.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vertPos = verts.length/6;\n\n        // start\n        verts.push(x, y);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x + width, y);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x , y + height);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x + width, y + height);\n        verts.push(r, g, b, alpha);\n\n        // insert 2 dead triangles..\n        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);\n    }\n\n    if(graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = [x, y,\n                  x + width, y,\n                  x + width, y + height,\n                  x, y + height,\n                  x, y];\n\n\n        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Builds a circle to draw\n *\n * @static\n * @private\n * @method buildCircle\n * @param graphicsData {Graphics} The graphics object to draw\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData)\n{\n    \n    // need to convert points to a nice regular data\n    var rectData = graphicsData.points;\n    var x = rectData[0];\n    var y = rectData[1];\n    var width = rectData[2];\n    var height = rectData[3];\n\n    var totalSegs = 40;\n    var seg = (Math.PI * 2) / totalSegs ;\n\n    var i = 0;\n\n    if(graphicsData.fill)\n    {\n        var color = PIXI.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vecPos = verts.length/6;\n\n        indices.push(vecPos);\n\n        for (i = 0; i < totalSegs + 1 ; i++)\n        {\n            verts.push(x,y, r, g, b, alpha);\n\n            verts.push(x + Math.sin(seg * i) * width,\n                       y + Math.cos(seg * i) * height,\n                       r, g, b, alpha);\n\n            indices.push(vecPos++, vecPos++);\n        }\n\n        indices.push(vecPos-1);\n    }\n\n    if(graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = [];\n\n        for (i = 0; i < totalSegs + 1; i++)\n        {\n            graphicsData.points.push(x + Math.sin(seg * i) * width,\n                                     y + Math.cos(seg * i) * height);\n        }\n\n        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Builds a line to draw\n *\n * @static\n * @private\n * @method buildLine\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData)\n{\n    // TODO OPTIMISE!\n    var i = 0;\n\n    var points = graphicsData.points;\n    if(points.length === 0)return;\n\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    if(graphicsData.lineWidth%2)\n    {\n        for (i = 0; i < points.length; i++) {\n            points[i] += 0.5;\n        }\n    }\n\n    // get first and last point.. figure out the middle!\n    var firstPoint = new PIXI.Point( points[0], points[1] );\n    var lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );\n\n    // if the first point is the last point - gonna have issues :)\n    if(firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)\n    {\n        points.pop();\n        points.pop();\n\n        lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );\n\n        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;\n        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n    var length = points.length / 2;\n    var indexCount = points.length;\n    var indexStart = verts.length/6;\n\n    // DRAW the Line\n    var width = graphicsData.lineWidth / 2;\n\n    // sort color\n    var color = PIXI.hex2rgb(graphicsData.lineColor);\n    var alpha = graphicsData.lineAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n\n    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;\n    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;\n    var a1, b1, c1, a2, b2, c2;\n    var denom, pdist, dist;\n\n    p1x = points[0];\n    p1y = points[1];\n\n    p2x = points[2];\n    p2y = points[3];\n\n    perpx = -(p1y - p2y);\n    perpy =  p1x - p2x;\n\n    dist = Math.sqrt(perpx*perpx + perpy*perpy);\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    // start\n    verts.push(p1x - perpx , p1y - perpy,\n                r, g, b, alpha);\n\n    verts.push(p1x + perpx , p1y + perpy,\n                r, g, b, alpha);\n\n    for (i = 1; i < length-1; i++)\n    {\n        p1x = points[(i-1)*2];\n        p1y = points[(i-1)*2 + 1];\n\n        p2x = points[(i)*2];\n        p2y = points[(i)*2 + 1];\n\n        p3x = points[(i+1)*2];\n        p3y = points[(i+1)*2 + 1];\n\n        perpx = -(p1y - p2y);\n        perpy = p1x - p2x;\n\n        dist = Math.sqrt(perpx*perpx + perpy*perpy);\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp2x = -(p2y - p3y);\n        perp2y = p2x - p3x;\n\n        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);\n        perp2x /= dist;\n        perp2y /= dist;\n        perp2x *= width;\n        perp2y *= width;\n\n        a1 = (-perpy + p1y) - (-perpy + p2y);\n        b1 = (-perpx + p2x) - (-perpx + p1x);\n        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);\n        a2 = (-perp2y + p3y) - (-perp2y + p2y);\n        b2 = (-perp2x + p2x) - (-perp2x + p3x);\n        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);\n\n        denom = a1*b2 - a2*b1;\n\n        if(Math.abs(denom) < 0.1 )\n        {\n\n            denom+=10.1;\n            verts.push(p2x - perpx , p2y - perpy,\n                r, g, b, alpha);\n\n            verts.push(p2x + perpx , p2y + perpy,\n                r, g, b, alpha);\n\n            continue;\n        }\n\n        px = (b1*c2 - b2*c1)/denom;\n        py = (a2*c1 - a1*c2)/denom;\n\n\n        pdist = (px -p2x) * (px -p2x) + (py -p2y) + (py -p2y);\n\n\n        if(pdist > 140 * 140)\n        {\n            perp3x = perpx - perp2x;\n            perp3y = perpy - perp2y;\n\n            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);\n            perp3x /= dist;\n            perp3y /= dist;\n            perp3x *= width;\n            perp3y *= width;\n\n            verts.push(p2x - perp3x, p2y -perp3y);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x + perp3x, p2y +perp3y);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x - perp3x, p2y -perp3y);\n            verts.push(r, g, b, alpha);\n\n            indexCount++;\n        }\n        else\n        {\n\n            verts.push(px , py);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x - (px-p2x), p2y - (py - p2y));\n            verts.push(r, g, b, alpha);\n        }\n    }\n\n    p1x = points[(length-2)*2];\n    p1y = points[(length-2)*2 + 1];\n\n    p2x = points[(length-1)*2];\n    p2y = points[(length-1)*2 + 1];\n\n    perpx = -(p1y - p2y);\n    perpy = p1x - p2x;\n\n    dist = Math.sqrt(perpx*perpx + perpy*perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(p2x - perpx , p2y - perpy);\n    verts.push(r, g, b, alpha);\n\n    verts.push(p2x + perpx , p2y + perpy);\n    verts.push(r, g, b, alpha);\n\n    indices.push(indexStart);\n\n    for (i = 0; i < indexCount; i++)\n    {\n        indices.push(indexStart++);\n    }\n\n    indices.push(indexStart-1);\n};\n\n/**\n * Builds a polygon to draw\n *\n * @static\n * @private\n * @method buildPoly\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData)\n{\n    var points = graphicsData.points;\n    if(points.length < 6)return;\n\n    // get first and last point.. figure out the middle!\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n\n    var length = points.length / 2;\n\n    // sort color\n    var color = PIXI.hex2rgb(graphicsData.fillColor);\n    var alpha = graphicsData.fillAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n\n    var triangles = PIXI.PolyK.Triangulate(points);\n\n    var vertPos = verts.length / 6;\n\n    var i = 0;\n\n    for (i = 0; i < triangles.length; i+=3)\n    {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i+1] + vertPos);\n        indices.push(triangles[i+2] +vertPos);\n        indices.push(triangles[i+2] + vertPos);\n    }\n\n    for (i = 0; i < length; i++)\n    {\n        verts.push(points[i * 2], points[i * 2 + 1],\n                   r, g, b, alpha);\n    }\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.glContexts = []; // this is where we store the webGL contexts for easy access.\n\n/**\n * the WebGLRenderer draws the stage and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatch's.\n * So no need for Sprite Batch's or Sprite Cloud's\n * Dont forget to add the view to your DOM or you will not see anything :)\n *\n * @class WebGLRenderer\n * @constructor\n * @param width=0 {Number} the width of the canvas view\n * @param height=0 {Number} the height of the canvas view\n * @param view {HTMLCanvasElement} the canvas to use as a view, optional\n * @param transparent=false {Boolean} If the render view is transparent, default false\n * @param antialias=false {Boolean} sets antialias (only applicable in chrome at the moment)\n *\n */\nPIXI.WebGLRenderer = function(width, height, view, transparent, antialias)\n{\n    if(!PIXI.defaultRenderer)PIXI.defaultRenderer = this;\n\n    this.type = PIXI.WEBGL_RENDERER;\n\n    // do a catch.. only 1 webGL renderer..\n    /**\n     * Whether the render view is transparent\n     *\n     * @property transparent\n     * @type Boolean\n     */\n    this.transparent = !!transparent;\n\n    /**\n     * The width of the canvas view\n     *\n     * @property width\n     * @type Number\n     * @default 800\n     */\n    this.width = width || 800;\n\n    /**\n     * The height of the canvas view\n     *\n     * @property height\n     * @type Number\n     * @default 600\n     */\n    this.height = height || 600;\n\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @property view\n     * @type HTMLCanvasElement\n     */\n    this.view = view || document.createElement( 'canvas' );\n    this.view.width = this.width;\n    this.view.height = this.height;\n\n    // deal with losing context..\n    this.contextLost = this.handleContextLost.bind(this);\n    this.contextRestoredLost = this.handleContextRestored.bind(this);\n    \n    this.view.addEventListener('webglcontextlost', this.contextLost, false);\n    this.view.addEventListener('webglcontextrestored', this.contextRestoredLost, false);\n\n    this.options = {\n        alpha: this.transparent,\n        antialias:!!antialias, // SPEED UP??\n        premultipliedAlpha:!!transparent,\n        stencil:true\n    };\n\n    //try 'experimental-webgl'\n    try {\n        this.gl = this.view.getContext('experimental-webgl',  this.options);\n    } catch (e) {\n        //try 'webgl'\n        try {\n            this.gl = this.view.getContext('webgl',  this.options);\n        } catch (e2) {\n            // fail, not able to get a context\n            throw new Error(' This browser does not support webGL. Try using the canvas renderer' + this);\n        }\n    }\n\n    var gl = this.gl;\n    this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId ++;\n\n    PIXI.glContexts[this.glContextId] = gl;\n\n    if(!PIXI.blendModesWebGL)\n    {\n        PIXI.blendModesWebGL = [];\n\n        PIXI.blendModesWebGL[PIXI.blendModes.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];\n        PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n    }\n\n\n\n\n    this.projection = new PIXI.Point();\n    this.projection.x =  this.width/2;\n    this.projection.y =  -this.height/2;\n\n    this.offset = new PIXI.Point(0, 0);\n\n    this.resize(this.width, this.height);\n    this.contextLost = false;\n\n    // time to create the render managers! each one focuses on managine a state in webGL\n    this.shaderManager = new PIXI.WebGLShaderManager(gl);                   // deals with managing the shader programs and their attribs\n    this.spriteBatch = new PIXI.WebGLSpriteBatch(gl);                       // manages the rendering of sprites\n    this.maskManager = new PIXI.WebGLMaskManager(gl);                       // manages the masks using the stencil buffer\n    this.filterManager = new PIXI.WebGLFilterManager(gl, this.transparent); // manages the filters\n\n    this.renderSession = {};\n    this.renderSession.gl = this.gl;\n    this.renderSession.drawCount = 0;\n    this.renderSession.shaderManager = this.shaderManager;\n    this.renderSession.maskManager = this.maskManager;\n    this.renderSession.filterManager = this.filterManager;\n    this.renderSession.spriteBatch = this.spriteBatch;\n\n\n    gl.useProgram(this.shaderManager.defaultShader.program);\n\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n\n    gl.enable(gl.BLEND);\n    gl.colorMask(true, true, true, this.transparent);\n};\n\n// constructor\nPIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;\n\n/**\n * Renders the stage to its webGL view\n *\n * @method render\n * @param stage {Stage} the Stage element to be rendered\n */\nPIXI.WebGLRenderer.prototype.render = function(stage)\n{\n    if(this.contextLost)return;\n\n\n    // if rendering a new stage clear the batches..\n    if(this.__stage !== stage)\n    {\n        if(stage.interactive)stage.interactionManager.removeEvents();\n\n        // TODO make this work\n        // dont think this is needed any more?\n        this.__stage = stage;\n    }\n\n    // update any textures this includes uvs and uploading them to the gpu\n    PIXI.WebGLRenderer.updateTextures();\n\n    // update the scene graph\n    stage.updateTransform();\n\n    var gl = this.gl;\n\n    // -- Does this need to be set every frame? -- //\n    //gl.colorMask(true, true, true, this.transparent);\n    gl.viewport(0, 0, this.width, this.height);\n\n    // make sure we are bound to the main frame buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    if(this.transparent)\n    {\n        gl.clearColor(0, 0, 0, 0);\n    }\n    else\n    {\n        gl.clearColor(stage.backgroundColorSplit[0],stage.backgroundColorSplit[1],stage.backgroundColorSplit[2], 1);\n    }\n\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    this.renderDisplayObject( stage, this.projection );\n\n    // interaction\n    if(stage.interactive)\n    {\n        //need to add some events!\n        if(!stage._interactiveEventsAdded)\n        {\n            stage._interactiveEventsAdded = true;\n            stage.interactionManager.setTarget(this);\n        }\n    }\n    else\n    {\n        if(stage._interactiveEventsAdded)\n        {\n            stage._interactiveEventsAdded = false;\n            stage.interactionManager.setTarget(this);\n        }\n    }\n\n    /*\n    //can simulate context loss in Chrome like so:\n     this.view.onmousedown = function(ev) {\n     console.dir(this.gl.getSupportedExtensions());\n        var ext = (\n            gl.getExtension(\"WEBGL_scompressed_texture_s3tc\")\n       // gl.getExtension(\"WEBGL_compressed_texture_s3tc\") ||\n       // gl.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") ||\n       // gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\")\n     );\n     console.dir(ext);\n     var loseCtx = this.gl.getExtension(\"WEBGL_lose_context\");\n      console.log(\"killing context\");\n      loseCtx.loseContext();\n     setTimeout(function() {\n          console.log(\"restoring context...\");\n          loseCtx.restoreContext();\n      }.bind(this), 1000);\n     }.bind(this);\n     */\n};\n\n/**\n * Renders a display Object\n *\n * @method renderDIsplayObject\n * @param displayObject {DisplayObject} The DisplayObject to render\n * @param projection {Point} The projection\n * @param buffer {Array} a standard WebGL buffer \n */\nPIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer)\n{\n    // reset the render session data..\n    this.renderSession.drawCount = 0;\n    this.renderSession.currentBlendMode = 9999;\n\n    this.renderSession.projection = projection;\n    this.renderSession.offset = this.offset;\n\n    // start the sprite batch\n    this.spriteBatch.begin(this.renderSession);\n\n    // start the filter manager\n    this.filterManager.begin(this.renderSession, buffer);\n\n    // render the scene!\n    displayObject._renderWebGL(this.renderSession);\n\n    // finish the sprite batch\n    this.spriteBatch.end();\n};\n\n/**\n * Updates the textures loaded into this webgl renderer\n *\n * @static\n * @method updateTextures\n * @private\n */\nPIXI.WebGLRenderer.updateTextures = function()\n{\n    var i = 0;\n\n    //TODO break this out into a texture manager...\n    //for (i = 0; i < PIXI.texturesToUpdate.length; i++)\n    //    PIXI.WebGLRenderer.updateTexture(PIXI.texturesToUpdate[i]);\n\n\n    for (i=0; i < PIXI.Texture.frameUpdates.length; i++)\n        PIXI.WebGLRenderer.updateTextureFrame(PIXI.Texture.frameUpdates[i]);\n\n    for (i = 0; i < PIXI.texturesToDestroy.length; i++)\n        PIXI.WebGLRenderer.destroyTexture(PIXI.texturesToDestroy[i]);\n\n    PIXI.texturesToUpdate.length = 0;\n    PIXI.texturesToDestroy.length = 0;\n    PIXI.Texture.frameUpdates.length = 0;\n};\n\n/**\n * Destroys a loaded webgl texture\n *\n * @method destroyTexture\n * @param texture {Texture} The texture to update\n * @private\n */\nPIXI.WebGLRenderer.destroyTexture = function(texture)\n{\n    //TODO break this out into a texture manager...\n\n    for (var i = texture._glTextures.length - 1; i >= 0; i--)\n    {\n        var glTexture = texture._glTextures[i];\n        var gl = PIXI.glContexts[i];\n\n        if(gl && glTexture)\n        {\n            gl.deleteTexture(glTexture);\n        }\n    }\n\n    texture._glTextures.length = 0;\n};\n\n/**\n *\n * @method updateTextureFrame\n * @param texture {Texture} The texture to update the frame from\n * @private\n */\nPIXI.WebGLRenderer.updateTextureFrame = function(texture)\n{\n    texture.updateFrame = false;\n\n    // now set the uvs. Figured that the uv data sits with a texture rather than a sprite.\n    // so uv data is stored on the texture itself\n    texture._updateWebGLuvs();\n};\n\n/**\n * resizes the webGL view to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the webGL view\n * @param height {Number} the new height of the webGL view\n */\nPIXI.WebGLRenderer.prototype.resize = function(width, height)\n{\n    this.width = width;\n    this.height = height;\n\n    this.view.width = width;\n    this.view.height = height;\n\n    this.gl.viewport(0, 0, this.width, this.height);\n\n    this.projection.x =  this.width/2;\n    this.projection.y =  -this.height/2;\n};\n\n/**\n * Creates a WebGL texture\n *\n * @method createWebGLTexture\n * @param texture {Texture} the texture to render\n * @param gl {webglContext} the WebGL context\n * @static\n */\nPIXI.createWebGLTexture = function(texture, gl)\n{\n\n\n    if(texture.hasLoaded)\n    {\n        texture._glTextures[gl.id] = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n\n        // reguler...\n\n        if(!texture._powerOf2)\n        {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        }\n        else\n        {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n        }\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    return  texture._glTextures[gl.id];\n};\n\n/**\n * Updates a WebGL texture\n *\n * @method updateWebGLTexture\n * @param texture {Texture} the texture to update\n * @param gl {webglContext} the WebGL context\n * @private\n */\nPIXI.updateWebGLTexture = function(texture, gl)\n{\n    if( texture._glTextures[gl.id] )\n    {\n        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n\n        // reguler...\n\n        if(!texture._powerOf2)\n        {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        }\n        else\n        {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n        }\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n    \n};\n\n/**\n * Handles a lost webgl context\n *\n * @method handleContextLost\n * @param event {Event}\n * @private\n */\nPIXI.WebGLRenderer.prototype.handleContextLost = function(event)\n{\n    event.preventDefault();\n    this.contextLost = true;\n};\n\n/**\n * Handles a restored webgl context\n *\n * @method handleContextRestored\n * @param event {Event}\n * @private\n */\nPIXI.WebGLRenderer.prototype.handleContextRestored = function()\n{\n\n    //try 'experimental-webgl'\n    try {\n        this.gl = this.view.getContext('experimental-webgl',  this.options);\n    } catch (e) {\n        //try 'webgl'\n        try {\n            this.gl = this.view.getContext('webgl',  this.options);\n        } catch (e2) {\n            // fail, not able to get a context\n            throw new Error(' This browser does not support webGL. Try using the canvas renderer' + this);\n        }\n    }\n\n    var gl = this.gl;\n    gl.id = PIXI.WebGLRenderer.glContextId ++;\n\n\n\n    // need to set the context...\n    this.shaderManager.setContext(gl);\n    this.spriteBatch.setContext(gl);\n    this.maskManager.setContext(gl);\n    this.filterManager.setContext(gl);\n\n\n    this.renderSession.gl = this.gl;\n\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n\n    gl.enable(gl.BLEND);\n    gl.colorMask(true, true, true, this.transparent);\n\n    this.gl.viewport(0, 0, this.width, this.height);\n\n    for(var key in PIXI.TextureCache)\n    {\n        var texture = PIXI.TextureCache[key].baseTexture;\n        texture._glTextures = [];\n    }\n\n    /**\n     * Whether the context was lost \n     * @property contextLost\n     * @type Boolean\n     */\n    this.contextLost = false;\n\n};\n\n/**\n * Removes everything from the renderer (event listeners, spritebatch, etc...)\n *\n * @method destroy\n */\nPIXI.WebGLRenderer.prototype.destroy = function()\n{\n\n    // deal with losing context..\n    \n    // remove listeners\n    this.view.removeEventListener('webglcontextlost', this.contextLost);\n    this.view.removeEventListener('webglcontextrestored', this.contextRestoredLost);\n\n    PIXI.glContexts[this.glContextId] = null;\n\n    this.projection = null;\n    this.offset = null;\n\n    // time to create the render managers! each one focuses on managine a state in webGL\n    this.shaderManager.destroy();\n    this.spriteBatch.destroy();\n    this.maskManager.destroy();\n    this.filterManager.destroy();\n\n    this.shaderManager = null;\n    this.spriteBatch = null;\n    this.maskManager = null;\n    this.filterManager = null;\n    \n    this.gl = null;\n    //\n    this.renderSession = null;\n};\n\n\nPIXI.WebGLRenderer.glContextId = 0;\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n \n\n/**\n* @class WebGLMaskManager\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @private\n*/\nPIXI.WebGLMaskManager = function(gl)\n{\n    this.maskStack = [];\n    this.maskPosition = 0;\n\n    this.setContext(gl);\n};\n\n/**\n* Sets the drawing context to the one given in parameter\n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLMaskManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Applies the Mask and adds it to the current filter stack\n* @method pushMask\n* @param maskData {Array}\n* @param renderSession {RenderSession}\n*/\nPIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession)\n{\n    var gl = this.gl;\n\n    if(this.maskStack.length === 0)\n    {\n        gl.enable(gl.STENCIL_TEST);\n        gl.stencilFunc(gl.ALWAYS,1,1);\n    }\n    \n  //  maskData.visible = false;\n\n    this.maskStack.push(maskData);\n    \n    gl.colorMask(false, false, false, true);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n\n    PIXI.WebGLGraphics.renderGraphics(maskData, renderSession);\n\n    gl.colorMask(true, true, true, true);\n    gl.stencilFunc(gl.NOTEQUAL,0, this.maskStack.length);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n};\n\n/**\n* Removes the last filter from the filter stack and doesn't return it\n* @method popMask\n*\n* @param renderSession {RenderSession} an object containing all the useful parameters\n*/\nPIXI.WebGLMaskManager.prototype.popMask = function(renderSession)\n{\n    var gl = this.gl;\n\n    var maskData = this.maskStack.pop();\n\n    if(maskData)\n    {\n        gl.colorMask(false, false, false, false);\n\n        //gl.stencilFunc(gl.ALWAYS,1,1);\n        gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n\n        PIXI.WebGLGraphics.renderGraphics(maskData, renderSession);\n\n        gl.colorMask(true, true, true, true);\n        gl.stencilFunc(gl.NOTEQUAL,0,this.maskStack.length);\n        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n    }\n   \n    if(this.maskStack.length === 0)gl.disable(gl.STENCIL_TEST);\n};\n\n/**\n* Destroys the mask stack\n* @method destroy\n*/\nPIXI.WebGLMaskManager.prototype.destroy = function()\n{\n    this.maskStack = null;\n    this.gl = null;\n};\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLShaderManager\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @private\n*/\nPIXI.WebGLShaderManager = function(gl)\n{\n\n    this.maxAttibs = 10;\n    this.attribState = [];\n    this.tempAttribState = [];\n\n    for (var i = 0; i < this.maxAttibs; i++) {\n        this.attribState[i] = false;\n    }\n\n    this.setContext(gl);\n    // the final one is used for the rendering strips\n    //this.stripShader = new PIXI.StripShader(gl);\n};\n\n\n/**\n* Initialises the context and the properties\n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n* @param transparent {Boolean} Whether or not the drawing context should be transparent\n*/\nPIXI.WebGLShaderManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n    \n    // the next one is used for rendering primatives\n    this.primitiveShader = new PIXI.PrimitiveShader(gl);\n\n    // this shader is used for the default sprite rendering\n    this.defaultShader = new PIXI.PixiShader(gl);\n\n    // this shader is used for the fast sprite rendering\n    this.fastShader = new PIXI.PixiFastShader(gl);\n\n\n    this.activateShader(this.defaultShader);\n};\n\n\n/**\n* Takes the attributes given in parameters \n* @method setAttribs\n* @param attribs {Array} attribs \n*/\nPIXI.WebGLShaderManager.prototype.setAttribs = function(attribs)\n{\n    // reset temp state\n\n    var i;\n\n    for (i = 0; i < this.tempAttribState.length; i++)\n    {\n        this.tempAttribState[i] = false;\n    }\n\n    // set the new attribs\n    for (i = 0; i < attribs.length; i++)\n    {\n        var attribId = attribs[i];\n        this.tempAttribState[attribId] = true;\n    }\n\n    var gl = this.gl;\n\n    for (i = 0; i < this.attribState.length; i++)\n    {\n\n        if(this.attribState[i] !== this.tempAttribState[i])\n        {\n            this.attribState[i] = this.tempAttribState[i];\n\n            if(this.tempAttribState[i])\n            {\n                gl.enableVertexAttribArray(i);\n            }\n            else\n            {\n                gl.disableVertexAttribArray(i);\n            }\n        }\n    }\n};\n\n/**\n* Sets-up the given shader \n*\n* @method activateShader\n* @param shader {Object} the shader that is going to be activated\n*/\nPIXI.WebGLShaderManager.prototype.activateShader = function(shader)\n{\n    //if(this.currentShader == shader)return;\n\n    this.currentShader = shader;\n\n    this.gl.useProgram(shader.program);\n    this.setAttribs(shader.attributes);\n  \n};\n\n/**\n* Triggers the primitive shader\n* @method activatePrimitiveShader\n*/\nPIXI.WebGLShaderManager.prototype.activatePrimitiveShader = function()\n{\n    var gl = this.gl;\n\n    gl.useProgram(this.primitiveShader.program);\n\n    this.setAttribs(this.primitiveShader.attributes);\n    \n};\n\n/**\n* Disable the primitive shader\n* @method deactivatePrimitiveShader\n*/\nPIXI.WebGLShaderManager.prototype.deactivatePrimitiveShader = function()\n{\n    var gl = this.gl;\n\n    gl.useProgram(this.defaultShader.program);\n\n    this.setAttribs(this.defaultShader.attributes);\n};\n\n/**\n* Destroys\n* @method destroy\n*/\nPIXI.WebGLShaderManager.prototype.destroy = function()\n{\n    this.attribState = null;\n\n    this.tempAttribState = null;\n\n    this.primitiveShader.destroy();\n\n    this.defaultShader.destroy();\n\n    this.fastShader.destroy();\n\n    this.gl = null;\n};\n\n\r\n/**\n * @author Mat Groves\n * \n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n *\n * Heavily inspired by LibGDX's WebGLSpriteBatch:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java\n */\n\n /**\n *\n * @class WebGLSpriteBatch\n * @private\n * @constructor\n * @param gl {WebGLContext} the current WebGL drawing context\n *\n */\nPIXI.WebGLSpriteBatch = function(gl)\n{\n\n    /**\n     * \n     *\n     * @property vertSize\n     * @type Number\n     */\n    this.vertSize = 6;\n\n    /**\n     * The number of images in the SpriteBatch before it flushes\n     * @property size\n     * @type Number\n     */\n    this.size = 10000;//Math.pow(2, 16) /  this.vertSize;\n\n    //the total number of floats in our batch\n    var numVerts = this.size * 4 *  this.vertSize;\n    //the total number of indices in our batch\n    var numIndices = this.size * 6;\n\n    //vertex data\n\n    /**\n    * Holds the vertices\n    *\n    * @property vertices\n    * @type Float32Array\n    */\n    this.vertices = new Float32Array(numVerts);\n\n    //index data\n    /**\n     * Holds the indices\n     *\n     * @property indices\n     * @type Uint16Array\n     */\n    this.indices = new Uint16Array(numIndices);\n    \n    this.lastIndexCount = 0;\n\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n\n    this.drawing = false;\n    this.currentBatchSize = 0;\n    this.currentBaseTexture = null;\n    \n    this.setContext(gl);\n};\n\n/**\n* \n* @method setContext\n*\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLSpriteBatch.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n\n    this.currentBlendMode = 99999;\n};\n\n/**\n* \n* @method begin\n*\n* @param renderSession {RenderSession} the RenderSession\n*/\nPIXI.WebGLSpriteBatch.prototype.begin = function(renderSession)\n{\n    this.renderSession = renderSession;\n    this.shader = this.renderSession.shaderManager.defaultShader;\n\n    this.start();\n};\n\n/**\n* \n* @method end\n*\n*/\nPIXI.WebGLSpriteBatch.prototype.end = function()\n{\n    this.flush();\n};\n\n/**\n* \n* @method render\n* \n* @param sprite {Sprite} the sprite to render when using this spritebatch\n*/\nPIXI.WebGLSpriteBatch.prototype.render = function(sprite)\n{\n    // check texture..\n    if(sprite.texture.baseTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size)\n    {\n        this.flush();\n        this.currentBaseTexture = sprite.texture.baseTexture;\n    }\n\n\n    // check blend mode\n    if(sprite.blendMode !== this.currentBlendMode)\n    {\n        this.setBlendMode(sprite.blendMode);\n    }\n\n    // get the uvs for the texture\n    var uvs = sprite._uvs || sprite.texture._uvs;\n    // if the uvs have not updated then no point rendering just yet!\n    if(!uvs)return;\n\n    // get the sprites current alpha\n    var alpha = sprite.worldAlpha;\n    var tint = sprite.tint;\n\n    var verticies = this.vertices;\n\n    var width = sprite.texture.frame.width;\n    var height = sprite.texture.frame.height;\n\n    // TODO trim??\n    var aX = sprite.anchor.x;\n    var aY = sprite.anchor.y;\n\n    var w0, w1, h0, h1;\n        \n    if (sprite.texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n        var trim = sprite.texture.trim;\n\n        w1 = trim.x - aX * trim.width;\n        w0 = w1 + width;\n\n        h1 = trim.y - aY * trim.height;\n        h0 = h1 + height;\n    }\n    else\n    {\n        w0 = (width ) * (1-aX);\n        w1 = (width ) * -aX;\n\n        h0 = height * (1-aY);\n        h1 = height * -aY;\n    }\n\n    var index = this.currentBatchSize * 4 * this.vertSize;\n\n    var worldTransform = sprite.worldTransform;//.toArray();\n\n    var a = worldTransform.a;//[0];\n    var b = worldTransform.c;//[3];\n    var c = worldTransform.b;//[1];\n    var d = worldTransform.d;//[4];\n    var tx = worldTransform.tx;//[2];\n    var ty = worldTransform.ty;///[5];\n\n    // xy\n    verticies[index++] = a * w1 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x0;\n    verticies[index++] = uvs.y0;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w0 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x1;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w0 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x2;\n    verticies[index++] = uvs.y2;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w1 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x3;\n    verticies[index++] = uvs.y3;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n    \n    // increment the batchsize\n    this.currentBatchSize++;\n\n\n};\n\n/**\n* Renders a tilingSprite using the spriteBatch\n* @method renderTilingSprite\n* \n* @param sprite {TilingSprite} the tilingSprite to render\n*/\nPIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(tilingSprite)\n{\n    var texture = tilingSprite.tilingTexture;\n\n    if(texture.baseTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size)\n    {\n        this.flush();\n        this.currentBaseTexture = texture.baseTexture;\n    }\n\n     // check blend mode\n    if(tilingSprite.blendMode !== this.currentBlendMode)\n    {\n        this.setBlendMode(tilingSprite.blendMode);\n    }\n\n     // set the textures uvs temporarily\n    // TODO create a separate texture so that we can tile part of a texture\n\n    if(!tilingSprite._uvs)tilingSprite._uvs = new PIXI.TextureUvs();\n\n    var uvs = tilingSprite._uvs;\n\n    tilingSprite.tilePosition.x %= texture.baseTexture.width;\n    tilingSprite.tilePosition.y %= texture.baseTexture.height;\n\n    var offsetX =  tilingSprite.tilePosition.x/texture.baseTexture.width;\n    var offsetY =  tilingSprite.tilePosition.y/texture.baseTexture.height;\n\n    var scaleX =  (tilingSprite.width / texture.baseTexture.width)  / (tilingSprite.tileScale.x * tilingSprite.tileScaleOffset.x);\n    var scaleY =  (tilingSprite.height / texture.baseTexture.height) / (tilingSprite.tileScale.y * tilingSprite.tileScaleOffset.y);\n\n    uvs.x0 = 0 - offsetX;\n    uvs.y0 = 0 - offsetY;\n\n    uvs.x1 = (1 * scaleX) - offsetX;\n    uvs.y1 = 0 - offsetY;\n\n    uvs.x2 = (1 * scaleX) - offsetX;\n    uvs.y2 = (1 * scaleY) - offsetY;\n\n    uvs.x3 = 0 - offsetX;\n    uvs.y3 = (1 *scaleY) - offsetY;\n\n    // get the tilingSprites current alpha\n    var alpha = tilingSprite.worldAlpha;\n    var tint = tilingSprite.tint;\n\n    var  verticies = this.vertices;\n\n    var width = tilingSprite.width;\n    var height = tilingSprite.height;\n\n    // TODO trim??\n    var aX = tilingSprite.anchor.x; // - tilingSprite.texture.trim.x\n    var aY = tilingSprite.anchor.y; //- tilingSprite.texture.trim.y\n    var w0 = width * (1-aX);\n    var w1 = width * -aX;\n\n    var h0 = height * (1-aY);\n    var h1 = height * -aY;\n\n    var index = this.currentBatchSize * 4 * this.vertSize;\n\n    var worldTransform = tilingSprite.worldTransform;\n\n    var a = worldTransform.a;//[0];\n    var b = worldTransform.c;//[3];\n    var c = worldTransform.b;//[1];\n    var d = worldTransform.d;//[4];\n    var tx = worldTransform.tx;//[2];\n    var ty = worldTransform.ty;///[5];\n\n    // xy\n    verticies[index++] = a * w1 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x0;\n    verticies[index++] = uvs.y0;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w0 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x1;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n    \n    // xy\n    verticies[index++] = a * w0 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x2;\n    verticies[index++] = uvs.y2;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w1 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x3;\n    verticies[index++] = uvs.y3;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // increment the batchs\n    this.currentBatchSize++;\n};\n\n\n/**\n* Renders the content and empties the current batch\n*\n* @method flush\n* \n*/\nPIXI.WebGLSpriteBatch.prototype.flush = function()\n{\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize===0)return;\n\n    var gl = this.gl;\n    \n    // bind the current texture\n    gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.currentBaseTexture, gl));\n\n    // upload the verts to the buffer\n    \n    if(this.currentBatchSize > ( this.size * 0.5 ) )\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n\n   // var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n    //gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    \n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);\n   \n    // then reset the batch!\n    this.currentBatchSize = 0;\n\n    // increment the draw count\n    this.renderSession.drawCount++;\n};\n\n/**\n* \n* @method stop\n*\n*/\nPIXI.WebGLSpriteBatch.prototype.stop = function()\n{\n    this.flush();\n};\n\n/**\n* \n* @method start\n*\n*/\nPIXI.WebGLSpriteBatch.prototype.start = function()\n{\n    var gl = this.gl;\n\n    // bind the main texture\n    gl.activeTexture(gl.TEXTURE0);\n\n    // bind the buffers\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // set the projection\n    var projection = this.renderSession.projection;\n    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);\n\n    // set the pointers\n    var stride =  this.vertSize * 4;\n    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n    gl.vertexAttribPointer(this.shader.colorAttribute, 2, gl.FLOAT, false, stride, 4 * 4);\n\n    // set the blend mode..\n    if(this.currentBlendMode !== PIXI.blendModes.NORMAL)\n    {\n        this.setBlendMode(PIXI.blendModes.NORMAL);\n    }\n};\n\n/**\n* Sets-up the given blendMode from WebGL's point of view\n* @method setBlendMode \n*\n* @param blendMode {Number} the blendMode, should be a Pixi const, such as PIXI.BlendModes.ADD\n*/\nPIXI.WebGLSpriteBatch.prototype.setBlendMode = function(blendMode)\n{\n    this.flush();\n\n    this.currentBlendMode = blendMode;\n    \n    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];\n    this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n};\n\n/**\n* Destroys the SpriteBatch\n* @method destroy\n*/\nPIXI.WebGLSpriteBatch.prototype.destroy = function()\n{\n\n    this.vertices = null;\n    this.indices = null;\n    \n    this.gl.deleteBuffer( this.vertexBuffer );\n    this.gl.deleteBuffer( this.indexBuffer );\n    \n    this.currentBaseTexture = null;\n    \n    this.gl = null;\n};\n\n\r\n/**\n * @author Mat Groves\n * \n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n *\n * Heavily inspired by LibGDX's WebGLSpriteBatch:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java\n */\n\nPIXI.WebGLFastSpriteBatch = function(gl)\n{\n   \n\n    this.vertSize = 10;\n    this.maxSize = 6000;//Math.pow(2, 16) /  this.vertSize;\n    this.size = this.maxSize;\n\n    //the total number of floats in our batch\n    var numVerts = this.size * 4 *  this.vertSize;\n    //the total number of indices in our batch\n    var numIndices = this.maxSize * 6;\n\n     //vertex data\n    this.vertices = new Float32Array(numVerts);\n    //index data\n    this.indices = new Uint16Array(numIndices);\n    \n    this.vertexBuffer = null;\n    this.indexBuffer = null;\n\n    this.lastIndexCount = 0;\n\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    this.drawing = false;\n    this.currentBatchSize = 0;\n    this.currentBaseTexture = null;\n   \n    this.currentBlendMode = 0;\n    this.renderSession = null;\n    \n\n    this.shader = null;\n\n    this.matrix = null;\n\n    this.setContext(gl);\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n\n    this.currentBlendMode = 99999;\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession)\n{\n    this.renderSession = renderSession;\n    this.shader = this.renderSession.shaderManager.fastShader;\n\n    this.matrix = spriteBatch.worldTransform.toArray(true);\n\n    this.start();\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.end = function()\n{\n    this.flush();\n};\n\n\nPIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch)\n{\n\n    var children = spriteBatch.children;\n    var sprite = children[0];\n\n    // if the uvs have not updated then no point rendering just yet!\n    \n    // check texture.\n    if(!sprite.texture._uvs)return;\n   \n    this.currentBaseTexture = sprite.texture.baseTexture;\n    // check blend mode\n    if(sprite.blendMode !== this.currentBlendMode)\n    {\n        this.setBlendMode(sprite.blendMode);\n    }\n    \n    for(var i=0,j= children.length; i<j; i++)\n    {\n        this.renderSprite(children[i]);\n    }\n\n    this.flush();\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite)\n{\n    //sprite = children[i];\n    \n    // TODO trim??\n    if(sprite.texture.baseTexture !== this.currentBaseTexture)\n    {\n        this.flush();\n        this.currentBaseTexture = sprite.texture.baseTexture;\n        \n        if(!sprite.texture._uvs)return;\n    }\n\n    var uvs, verticies = this.vertices, width, height, w0, w1, h0, h1, index;\n\n    uvs = sprite.texture._uvs;\n\n\n    width = sprite.texture.frame.width;\n    height = sprite.texture.frame.height;\n\n    if (sprite.texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n        var trim = sprite.texture.trim;\n\n        w1 = trim.x - sprite.anchor.x * trim.width;\n        w0 = w1 + sprite.texture.frame.width;\n\n        h1 = trim.y - sprite.anchor.y * trim.height;\n        h0 = h1 + sprite.texture.frame.height;\n    }\n    else\n    {\n        w0 = (sprite.texture.frame.width ) * (1-sprite.anchor.x);\n        w1 = (sprite.texture.frame.width ) * -sprite.anchor.x;\n\n        h0 = sprite.texture.frame.height * (1-sprite.anchor.y);\n        h1 = sprite.texture.frame.height * -sprite.anchor.y;\n    }\n\n    index = this.currentBatchSize * 4 * this.vertSize;\n\n    // xy\n    verticies[index++] = w1;\n    verticies[index++] = h1;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n    //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x0;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = sprite.alpha;\n \n\n    // xy\n    verticies[index++] = w0;\n    verticies[index++] = h1;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n     //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x1;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = sprite.alpha;\n  \n\n    // xy\n    verticies[index++] = w0;\n    verticies[index++] = h0;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n     //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x2;\n    verticies[index++] = uvs.y2;\n    // color\n    verticies[index++] = sprite.alpha;\n \n\n\n\n    // xy\n    verticies[index++] = w1;\n    verticies[index++] = h0;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n     //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x3;\n    verticies[index++] = uvs.y3;\n    // color\n    verticies[index++] = sprite.alpha;\n\n    // increment the batchs\n    this.currentBatchSize++;\n\n    if(this.currentBatchSize >= this.size)\n    {\n        this.flush();\n    }\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.flush = function()\n{\n\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize===0)return;\n\n    var gl = this.gl;\n    \n    // bind the current texture\n\n    if(!this.currentBaseTexture._glTextures[gl.id])PIXI.createWebGLTexture(this.currentBaseTexture, gl);\n\n    gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);// || PIXI.createWebGLTexture(this.currentBaseTexture, gl));\n\n    // upload the verts to the buffer\n\n   \n    if(this.currentBatchSize > ( this.size * 0.5 ) )\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n    \n    \n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);\n   \n    // then reset the batch!\n    this.currentBatchSize = 0;\n\n    // increment the draw count\n    this.renderSession.drawCount++;\n};\n\n\nPIXI.WebGLFastSpriteBatch.prototype.stop = function()\n{\n    this.flush();\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.start = function()\n{\n    var gl = this.gl;\n\n    // bind the main texture\n    gl.activeTexture(gl.TEXTURE0);\n\n    // bind the buffers\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // set the projection\n    var projection = this.renderSession.projection;\n    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);\n\n    // set the matrix\n    gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);\n\n    // set the pointers\n    var stride =  this.vertSize * 4;\n\n    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n    gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n    gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);\n    gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);\n    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);\n    gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);\n\n    // set the blend mode..\n    if(this.currentBlendMode !== PIXI.blendModes.NORMAL)\n    {\n        this.setBlendMode(PIXI.blendModes.NORMAL);\n    }\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.setBlendMode = function(blendMode)\n{\n    this.flush();\n\n    this.currentBlendMode = blendMode;\n    \n    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];\n    this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n};\n\n\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLFilterManager\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param transparent {Boolean} Whether or not the drawing context should be transparent\n* @private\n*/\nPIXI.WebGLFilterManager = function(gl, transparent)\n{\n    this.transparent = transparent;\n\n    this.filterStack = [];\n    \n    this.offsetX = 0;\n    this.offsetY = 0;\n\n    this.setContext(gl);\n};\n\n// API\n/**\n* Initialises the context and the properties\n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLFilterManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n    this.texturePool = [];\n\n    this.initShaderBuffers();\n};\n\n/**\n* \n* @method begin\n* @param renderSession {RenderSession} \n* @param buffer {ArrayBuffer} \n*/\nPIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer)\n{\n    this.renderSession = renderSession;\n    this.defaultShader = renderSession.shaderManager.defaultShader;\n\n    var projection = this.renderSession.projection;\n\n    this.width = projection.x * 2;\n    this.height = -projection.y * 2;\n    this.buffer = buffer;\n};\n\n/**\n* Applies the filter and adds it to the current filter stack\n* @method pushFilter\n* @param filterBlock {Object} the filter that will be pushed to the current filter stack\n*/\nPIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock)\n{\n    var gl = this.gl;\n\n    var projection = this.renderSession.projection;\n    var offset = this.renderSession.offset;\n\n\n    // filter program\n    // OPTIMISATION - the first filter is free if its a simple color change?\n    this.filterStack.push(filterBlock);\n\n    var filter = filterBlock.filterPasses[0];\n\n    this.offsetX += filterBlock.target.filterArea.x;\n    this.offsetY += filterBlock.target.filterArea.y;\n\n    var texture = this.texturePool.pop();\n    if(!texture)\n    {\n        texture = new PIXI.FilterTexture(this.gl, this.width, this.height);\n    }\n    else\n    {\n        texture.resize(this.width, this.height);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D,  texture.texture);\n\n    filterBlock.target.filterArea = filterBlock.target.getBounds();\n\n    var filterArea = filterBlock.target.filterArea;\n\n    var padidng = filter.padding;\n    filterArea.x -= padidng;\n    filterArea.y -= padidng;\n    filterArea.width += padidng * 2;\n    filterArea.height += padidng * 2;\n\n    // cap filter to screen size..\n    if(filterArea.x < 0)filterArea.x = 0;\n    if(filterArea.width > this.width)filterArea.width = this.width;\n    if(filterArea.y < 0)filterArea.y = 0;\n    if(filterArea.height > this.height)filterArea.height = this.height;\n\n    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  filterArea.width, filterArea.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);\n\n    // set view port\n    gl.viewport(0, 0, filterArea.width, filterArea.height);\n\n    projection.x = filterArea.width/2;\n    projection.y = -filterArea.height/2;\n\n    offset.x = -filterArea.x;\n    offset.y = -filterArea.y;\n\n    // update projection\n    gl.uniform2f(this.defaultShader.projectionVector, filterArea.width/2, -filterArea.height/2);\n    gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);\n\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0,0,0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    filterBlock._glFilterTexture = texture;\n\n};\n\n\n/**\n* Removes the last filter from the filter stack and doesn't return it\n* @method popFilter\n*/\nPIXI.WebGLFilterManager.prototype.popFilter = function()\n{\n    var gl = this.gl;\n    var filterBlock = this.filterStack.pop();\n    var filterArea = filterBlock.target.filterArea;\n    var texture = filterBlock._glFilterTexture;\n    var projection = this.renderSession.projection;\n    var offset = this.renderSession.offset;\n\n    if(filterBlock.filterPasses.length > 1)\n    {\n        gl.viewport(0, 0, filterArea.width, filterArea.height);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n        this.vertexArray[0] = 0;\n        this.vertexArray[1] = filterArea.height;\n\n        this.vertexArray[2] = filterArea.width;\n        this.vertexArray[3] = filterArea.height;\n\n        this.vertexArray[4] = 0;\n        this.vertexArray[5] = 0;\n\n        this.vertexArray[6] = filterArea.width;\n        this.vertexArray[7] = 0;\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n        // now set the uvs..\n        this.uvArray[2] = filterArea.width/this.width;\n        this.uvArray[5] = filterArea.height/this.height;\n        this.uvArray[6] = filterArea.width/this.width;\n        this.uvArray[7] = filterArea.height/this.height;\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);\n\n        var inputTexture = texture;\n        var outputTexture = this.texturePool.pop();\n        if(!outputTexture)outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height);\n\n        // need to clear this FBO as it may have some left over elements from a previous filter.\n        gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        gl.disable(gl.BLEND);\n\n        for (var i = 0; i < filterBlock.filterPasses.length-1; i++)\n        {\n            var filterPass = filterBlock.filterPasses[i];\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );\n\n            // set texture\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);\n\n            // draw texture..\n            //filterPass.applyFilterPass(filterArea.width, filterArea.height);\n            this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);\n\n            // swap the textures..\n            var temp = inputTexture;\n            inputTexture = outputTexture;\n            outputTexture = temp;\n        }\n\n        gl.enable(gl.BLEND);\n\n        texture = inputTexture;\n        this.texturePool.push(outputTexture);\n    }\n\n    var filter = filterBlock.filterPasses[filterBlock.filterPasses.length-1];\n\n    this.offsetX -= filterArea.x;\n    this.offsetY -= filterArea.y;\n\n\n    var sizeX = this.width;\n    var sizeY = this.height;\n\n    var offsetX = 0;\n    var offsetY = 0;\n\n    var buffer = this.buffer;\n\n    // time to render the filters texture to the previous scene\n    if(this.filterStack.length === 0)\n    {\n        gl.colorMask(true, true, true, this.transparent);\n    }\n    else\n    {\n        var currentFilter = this.filterStack[this.filterStack.length-1];\n        filterArea = currentFilter.target.filterArea;\n\n        sizeX = filterArea.width;\n        sizeY = filterArea.height;\n\n        offsetX = filterArea.x;\n        offsetY = filterArea.y;\n\n        buffer =  currentFilter._glFilterTexture.frameBuffer;\n    }\n\n\n\n    // TODO need toremove thease global elements..\n    projection.x = sizeX/2;\n    projection.y = -sizeY/2;\n\n    offset.x = offsetX;\n    offset.y = offsetY;\n\n    filterArea = filterBlock.target.filterArea;\n\n    var x = filterArea.x-offsetX;\n    var y = filterArea.y-offsetY;\n\n    // update the buffers..\n    // make sure to flip the y!\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n    this.vertexArray[0] = x;\n    this.vertexArray[1] = y + filterArea.height;\n\n    this.vertexArray[2] = x + filterArea.width;\n    this.vertexArray[3] = y + filterArea.height;\n\n    this.vertexArray[4] = x;\n    this.vertexArray[5] = y;\n\n    this.vertexArray[6] = x + filterArea.width;\n    this.vertexArray[7] = y;\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n\n    this.uvArray[2] = filterArea.width/this.width;\n    this.uvArray[5] = filterArea.height/this.height;\n    this.uvArray[6] = filterArea.width/this.width;\n    this.uvArray[7] = filterArea.height/this.height;\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);\n\n    gl.viewport(0, 0, sizeX, sizeY);\n    // bind the buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer );\n\n    // set the blend mode! \n    //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\n\n    // set texture\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture.texture);\n\n    // apply!\n    this.applyFilterPass(filter, filterArea, sizeX, sizeY);\n\n    // now restore the regular shader..\n    gl.useProgram(this.defaultShader.program);\n    gl.uniform2f(this.defaultShader.projectionVector, sizeX/2, -sizeY/2);\n    gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);\n\n    // return the texture to the pool\n    this.texturePool.push(texture);\n    filterBlock._glFilterTexture = null;\n};\n\n\n/**\n* Applies the filter to the specified area\n* @method applyFilterPass\n* @param filter {AbstractFilter} the filter that needs to be applied\n* @param filterArea {texture} TODO - might need an update\n* @param width {Number} the horizontal range of the filter\n* @param height {Number} the vertical range of the filter\n*/\nPIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height)\n{\n    // use program\n    var gl = this.gl;\n    var shader = filter.shaders[gl.id];\n\n    if(!shader)\n    {\n        shader = new PIXI.PixiShader(gl);\n\n        shader.fragmentSrc = filter.fragmentSrc;\n        shader.uniforms = filter.uniforms;\n        shader.init();\n\n        filter.shaders[gl.id] = shader;\n    }\n\n    // set the shader\n    gl.useProgram(shader.program);\n\n    gl.uniform2f(shader.projectionVector, width/2, -height/2);\n    gl.uniform2f(shader.offsetVector, 0,0);\n\n    if(filter.uniforms.dimensions)\n    {\n        filter.uniforms.dimensions.value[0] = this.width;//width;\n        filter.uniforms.dimensions.value[1] = this.height;//height;\n        filter.uniforms.dimensions.value[2] = this.vertexArray[0];\n        filter.uniforms.dimensions.value[3] = this.vertexArray[5];//filterArea.height;\n    }\n\n    shader.syncUniforms();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n    gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n    gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // draw the filter...\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n    this.renderSession.drawCount++;\n};\n\n/**\n* Initialises the shader buffers\n* @method initShaderBuffers\n*/\nPIXI.WebGLFilterManager.prototype.initShaderBuffers = function()\n{\n    var gl = this.gl;\n\n    // create some buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.uvBuffer = gl.createBuffer();\n    this.colorBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n\n    // bind and upload the vertexs..\n    // keep a reference to the vertexFloatData..\n    this.vertexArray = new Float32Array([0.0, 0.0,\n                                         1.0, 0.0,\n                                         0.0, 1.0,\n                                         1.0, 1.0]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(\n    gl.ARRAY_BUFFER,\n    this.vertexArray,\n    gl.STATIC_DRAW);\n\n\n    // bind and upload the uv buffer\n    this.uvArray = new Float32Array([0.0, 0.0,\n                                     1.0, 0.0,\n                                     0.0, 1.0,\n                                     1.0, 1.0]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n    gl.bufferData(\n    gl.ARRAY_BUFFER,\n    this.uvArray,\n    gl.STATIC_DRAW);\n\n    this.colorArray = new Float32Array([1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n    gl.bufferData(\n    gl.ARRAY_BUFFER,\n    this.colorArray,\n    gl.STATIC_DRAW);\n\n    // bind and upload the index\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(\n    gl.ELEMENT_ARRAY_BUFFER,\n    new Uint16Array([0, 1, 2, 1, 3, 2]),\n    gl.STATIC_DRAW);\n};\n\n/**\n* Destroys the filter and removes it from the filter stack\n* @method destroy\n*/\nPIXI.WebGLFilterManager.prototype.destroy = function()\n{\n    var gl = this.gl;\n\n    this.filterStack = null;\n    \n    this.offsetX = 0;\n    this.offsetY = 0;\n\n    // destroy textures\n    for (var i = 0; i < this.texturePool.length; i++) {\n        this.texturePool.destroy();\n    }\n    \n    this.texturePool = null;\n\n    //destroy buffers..\n    gl.deleteBuffer(this.vertexBuffer);\n    gl.deleteBuffer(this.uvBuffer);\n    gl.deleteBuffer(this.colorBuffer);\n    gl.deleteBuffer(this.indexBuffer);\n};\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class FilterTexture\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param width {Number} the horizontal range of the filter\n* @param height {Number} the vertical range of the filter\n* @private\n*/\nPIXI.FilterTexture = function(gl, width, height)\n{\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    // next time to create a frame buffer and texture\n    this.frameBuffer = gl.createFramebuffer();\n    this.texture = gl.createTexture();\n\n    gl.bindTexture(gl.TEXTURE_2D,  this.texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer );\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\n\n    this.resize(width, height);\n};\n\n\n/**\n* Clears the filter texture\n* @method clear\n*/\nPIXI.FilterTexture.prototype.clear = function()\n{\n    var gl = this.gl;\n    \n    gl.clearColor(0,0,0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n};\n\n/**\n * Resizes the texture to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the texture\n * @param height {Number} the new height of the texture\n */\nPIXI.FilterTexture.prototype.resize = function(width, height)\n{\n    if(this.width === width && this.height === height) return;\n\n    this.width = width;\n    this.height = height;\n\n    var gl = this.gl;\n\n    gl.bindTexture(gl.TEXTURE_2D,  this.texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n};\n\n/**\n* Destroys the filter texture\n* @method destroy\n*/\nPIXI.FilterTexture.prototype.destroy = function()\n{\n    var gl = this.gl;\n    gl.deleteFramebuffer( this.frameBuffer );\n    gl.deleteTexture( this.texture );\n\n    this.frameBuffer = null;\n    this.texture = null;\n};\n\r\n/**\n * @author Mat Groves\n * \n * \n */\n/**\n * A set of functions used to handle masking\n *\n * @class CanvasMaskManager\n */\nPIXI.CanvasMaskManager = function()\n{\n    \n};\n\n/**\n * This method adds it to the current stack of masks\n *\n * @method pushMask\n * @param maskData the maskData that will be pushed\n * @param context {Context2D} the 2d drawing method of the canvas\n */\nPIXI.CanvasMaskManager.prototype.pushMask = function(maskData, context)\n{\n    context.save();\n    \n    var cacheAlpha = maskData.alpha;\n    var transform = maskData.worldTransform;\n\n    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);\n\n    PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);\n\n    context.clip();\n\n    maskData.worldAlpha = cacheAlpha;\n};\n\n/**\n * Restores the current drawing context to the state it was before the mask was applied\n *\n * @method popMask\n * @param context {Context2D} the 2d drawing method of the canvas\n */\nPIXI.CanvasMaskManager.prototype.popMask = function(context)\n{\n    context.restore();\n};\r\n\n/**\n * @author Mat Groves\n * \n * \n */\n\n/**\n * @class CanvasTinter\n * @constructor\n * @static\n */\nPIXI.CanvasTinter = function()\n{\n    /// this.textureCach\n};\n\n//PIXI.CanvasTinter.cachTint = true;\n    \n\n/**\n * Basically this method just needs a sprite and a color and tints the sprite \n * with the given color\n * \n * @method getTintedTexture \n * @param sprite {Sprite} the sprite to tint\n * @param color {Number} the color to use to tint the sprite with\n */\nPIXI.CanvasTinter.getTintedTexture = function(sprite, color)\n{\n\n    var texture = sprite.texture;\n\n    color = PIXI.CanvasTinter.roundColor(color);\n\n    var stringColor = \"#\" + (\"00000\" + ( color | 0).toString(16)).substr(-6);\n   \n    texture.tintCache = texture.tintCache || {};\n\n    if(texture.tintCache[stringColor]) return texture.tintCache[stringColor];\n\n     // clone texture..\n    var canvas = PIXI.CanvasTinter.canvas || document.createElement(\"canvas\");\n    \n    //PIXI.CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);\n\n    \n    PIXI.CanvasTinter.tintMethod(texture, color, canvas);\n\n    if(PIXI.CanvasTinter.convertTintToImage)\n    {\n        // is this better?\n        var tintImage = new Image();\n        tintImage.src = canvas.toDataURL();\n\n        texture.tintCache[stringColor] = tintImage;\n    }\n    else\n    {\n      \n        texture.tintCache[stringColor] = canvas;\n        // if we are not converting the texture to an image then we need to lose the reference to the canvas\n        PIXI.CanvasTinter.canvas = null;\n\n    }\n\n    return canvas;\n};\n\n/**\n * Tint a texture using the \"multiply\" operation\n * @method tintWithMultiply\n * @param texture {texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas)\n{\n    var context = canvas.getContext( \"2d\" );\n\n    var frame = texture.frame;\n\n    canvas.width = frame.width;\n    canvas.height = frame.height;\n\n    context.fillStyle = \"#\" + (\"00000\" + ( color | 0).toString(16)).substr(-6);\n    \n    context.fillRect(0, 0, frame.width, frame.height);\n    \n    context.globalCompositeOperation = \"multiply\";\n\n    context.drawImage(texture.baseTexture.source,\n                           frame.x,\n                           frame.y,\n                           frame.width,\n                           frame.height,\n                           0,\n                           0,\n                           frame.width,\n                           frame.height);\n\n    context.globalCompositeOperation = \"destination-atop\";\n    \n    context.drawImage(texture.baseTexture.source,\n                           frame.x,\n                           frame.y,\n                           frame.width,\n                           frame.height,\n                           0,\n                           0,\n                           frame.width,\n                           frame.height);\n};\n\n/**\n * Tint a texture using the \"overlay\" operation\n * @method tintWithOverlay\n * @param texture {texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithOverlay = function(texture, color, canvas)\n{\n    var context = canvas.getContext( \"2d\" );\n\n    var frame = texture.frame;\n\n    canvas.width = frame.width;\n    canvas.height = frame.height;\n\n    \n    \n    context.globalCompositeOperation = \"copy\";\n    context.fillStyle = \"#\" + (\"00000\" + ( color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, frame.width, frame.height);\n\n    context.globalCompositeOperation = \"destination-atop\";\n    context.drawImage(texture.baseTexture.source,\n                           frame.x,\n                           frame.y,\n                           frame.width,\n                           frame.height,\n                           0,\n                           0,\n                           frame.width,\n                           frame.height);\n\n    \n    //context.globalCompositeOperation = \"copy\";\n\n};\n\n/**\n * Tint a texture pixel per pixel\n * @method tintPerPixel\n * @param texture {texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas)\n{\n    var context = canvas.getContext( \"2d\" );\n\n    var frame = texture.frame;\n\n    canvas.width = frame.width;\n    canvas.height = frame.height;\n  \n    context.globalCompositeOperation = \"copy\";\n    context.drawImage(texture.baseTexture.source,\n                           frame.x,\n                           frame.y,\n                           frame.width,\n                           frame.height,\n                           0,\n                           0,\n                           frame.width,\n                           frame.height);\n\n    var rgbValues = PIXI.hex2rgb(color);\n    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];\n\n    var pixelData = context.getImageData(0, 0, frame.width, frame.height);\n\n    var pixels = pixelData.data;\n\n    for (var i = 0; i < pixels.length; i += 4)\n    {\n        pixels[i+0] *= r;\n        pixels[i+1] *= g;\n        pixels[i+2] *= b;\n    }\n\n    context.putImageData(pixelData, 0, 0);\n};\n\n/**\n * Rounds the specified color according to the PIXI.CanvasTinter.cacheStepsPerColorChannel\n * @method roundColor\n * @param color {number} the color to round, should be a hex color\n */\nPIXI.CanvasTinter.roundColor = function(color)\n{\n    var step = PIXI.CanvasTinter.cacheStepsPerColorChannel;\n\n    var rgbValues = PIXI.hex2rgb(color);\n\n    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);\n    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);\n    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);\n\n    return PIXI.rgb2hex(rgbValues);\n};\n\n/**\n * \n * Number of steps which will be used as a cap when rounding colors\n *\n * @property cacheStepsPerColorChannel\n * @type Number\n */\nPIXI.CanvasTinter.cacheStepsPerColorChannel = 8;\n/**\n * \n * Number of steps which will be used as a cap when rounding colors\n *\n * @property convertTintToImage\n * @type Boolean\n */\nPIXI.CanvasTinter.convertTintToImage = false;\n\n/**\n * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method\n *\n * @property canUseMultiply\n * @type Boolean\n */\nPIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes();\n\nPIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply :  PIXI.CanvasTinter.tintWithPerPixel;\n\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * the CanvasRenderer draws the stage and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.\n * Dont forget to add the view to your DOM or you will not see anything :)\n *\n * @class CanvasRenderer\n * @constructor\n * @param width=800 {Number} the width of the canvas view\n * @param height=600 {Number} the height of the canvas view\n * @param [view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [transparent=false] {Boolean} the transparency of the render view, default false\n */\nPIXI.CanvasRenderer = function(width, height, view, transparent)\n{\n    PIXI.defaultRenderer = PIXI.defaultRenderer || this;\n\n    this.type = PIXI.CANVAS_RENDERER;\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the Stage is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.\n     * If the Stage is transparent Pixi will use clearRect to clear the canvas every frame.\n     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.\n     *\n     * @property clearBeforeRender\n     * @type Boolean\n     * @default\n     */\n    this.clearBeforeRender = true;\n\n    /**\n     * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Handy for crisp pixel art and speed on legacy devices.\n     *\n     * @property roundPixels\n     * @type Boolean\n     * @default\n     */\n    this.roundPixels = false;\n\n    /**\n     * Whether the render view is transparent\n     *\n     * @property transparent\n     * @type Boolean\n     */\n    this.transparent = !!transparent;\n\n    if(!PIXI.blendModesCanvas)\n    {\n        PIXI.blendModesCanvas = [];\n        \n        if(PIXI.canUseNewCanvasBlendModes())\n        {\n            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = \"lighter\"; //IS THIS OK???\n            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = \"multiply\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = \"screen\";\n            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = \"overlay\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = \"darken\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = \"lighten\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = \"color-dodge\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = \"color-burn\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = \"hard-light\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = \"soft-light\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = \"difference\";\n            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = \"exclusion\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = \"hue\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = \"saturation\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = \"color\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = \"luminosity\";\n        }\n        else\n        {\n            // this means that the browser does not support the cool new blend modes in canvas \"cough\" ie \"cough\"\n            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = \"lighter\"; //IS THIS OK???\n            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = \"source-over\";\n        }\n    }\n\n    /**\n     * The width of the canvas view\n     *\n     * @property width\n     * @type Number\n     * @default 800\n     */\n    this.width = width || 800;\n\n    /**\n     * The height of the canvas view\n     *\n     * @property height\n     * @type Number\n     * @default 600\n     */\n    this.height = height || 600;\n\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @property view\n     * @type HTMLCanvasElement\n     */\n    this.view = view || document.createElement( \"canvas\" );\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @property context\n     * @type HTMLCanvasElement 2d Context\n     */\n    this.context = this.view.getContext( \"2d\", { alpha: this.transparent } );\n\n    this.refresh = true;\n    // hack to enable some hardware acceleration!\n    //this.view.style[\"transform\"] = \"translatez(0)\";\n\n    this.view.width = this.width;\n    this.view.height = this.height;\n    this.count = 0;\n\n    /**\n     * Instance of a PIXI.CanvasMaskManager, handles masking when using the canvas renderer\n     * @property CanvasMaskManager\n     * @type CanvasMaskManager\n     */\n    this.maskManager = new PIXI.CanvasMaskManager();\n\n    /**\n     * The render session is just a bunch of parameter used for rendering\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = {\n        context: this.context,\n        maskManager: this.maskManager,\n        scaleMode: null,\n        smoothProperty: null\n    };\n\n    if(\"imageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"imageSmoothingEnabled\";\n    else if(\"webkitImageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"webkitImageSmoothingEnabled\";\n    else if(\"mozImageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"mozImageSmoothingEnabled\";\n    else if(\"oImageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"oImageSmoothingEnabled\";\n};\n\n// constructor\nPIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;\n\n/**\n * Renders the stage to its canvas view\n *\n * @method render\n * @param stage {Stage} the Stage element to be rendered\n */\nPIXI.CanvasRenderer.prototype.render = function(stage)\n{\n    // update textures if need be\n    PIXI.texturesToUpdate.length = 0;\n    PIXI.texturesToDestroy.length = 0;\n\n    stage.updateTransform();\n\n    this.context.setTransform(1,0,0,1,0,0);\n    this.context.globalAlpha = 1;\n\n    if (!this.transparent && this.clearBeforeRender)\n    {\n        this.context.fillStyle = stage.backgroundColorString;\n        this.context.fillRect(0, 0, this.width, this.height);\n    }\n    else if (this.transparent && this.clearBeforeRender)\n    {\n        this.context.clearRect(0, 0, this.width, this.height);\n    }\n\n    this.renderDisplayObject(stage);\n\n    // run interaction!\n    if(stage.interactive)\n    {\n        //need to add some events!\n        if(!stage._interactiveEventsAdded)\n        {\n            stage._interactiveEventsAdded = true;\n            stage.interactionManager.setTarget(this);\n        }\n    }\n\n    // remove frame updates..\n    if(PIXI.Texture.frameUpdates.length > 0)\n    {\n        PIXI.Texture.frameUpdates.length = 0;\n    }\n};\n\n/**\n * Resizes the canvas view to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the canvas view\n * @param height {Number} the new height of the canvas view\n */\nPIXI.CanvasRenderer.prototype.resize = function(width, height)\n{\n    this.width = width;\n    this.height = height;\n\n    this.view.width = width;\n    this.view.height = height;\n};\n\n/**\n * Renders a display object\n *\n * @method renderDisplayObject\n * @param displayObject {DisplayObject} The displayObject to render\n * @param context {Context2D} the context 2d method of the canvas\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context)\n{\n    // no longer recursive!\n    //var transform;\n    //var context = this.context;\n\n    this.renderSession.context = context || this.context;\n    displayObject._renderCanvas(this.renderSession);\n};\n\n/**\n * Renders a flat strip\n *\n * @method renderStripFlat\n * @param strip {Strip} The Strip to render\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderStripFlat = function(strip)\n{\n    var context = this.context;\n    var verticies = strip.verticies;\n\n    var length = verticies.length/2;\n    this.count++;\n\n    context.beginPath();\n    for (var i=1; i < length-2; i++)\n    {\n        // draw some triangles!\n        var index = i*2;\n\n        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];\n        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];\n\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n    }\n\n    context.fillStyle = \"#FF0000\";\n    context.fill();\n    context.closePath();\n};\n\n/**\n * Renders a strip\n *\n * @method renderStrip\n * @param strip {Strip} The Strip to render\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderStrip = function(strip)\n{\n    var context = this.context;\n\n    // draw triangles!!\n    var verticies = strip.verticies;\n    var uvs = strip.uvs;\n\n    var length = verticies.length/2;\n    this.count++;\n\n    for (var i = 1; i < length-2; i++)\n    {\n        // draw some triangles!\n        var index = i*2;\n\n        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];\n        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];\n\n        var u0 = uvs[index] * strip.texture.width,   u1 = uvs[index+2] * strip.texture.width, u2 = uvs[index+4]* strip.texture.width;\n        var v0 = uvs[index+1]* strip.texture.height, v1 = uvs[index+3] * strip.texture.height, v2 = uvs[index+5]* strip.texture.height;\n\n        context.save();\n        context.beginPath();\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n        context.closePath();\n\n        context.clip();\n\n        // Compute matrix transform\n        var delta = u0*v1 + v0*u2 + u1*v2 - v1*u2 - v0*u1 - u0*v2;\n        var deltaA = x0*v1 + v0*x2 + x1*v2 - v1*x2 - v0*x1 - x0*v2;\n        var deltaB = u0*x1 + x0*u2 + u1*x2 - x1*u2 - x0*u1 - u0*x2;\n        var deltaC = u0*v1*x2 + v0*x1*u2 + x0*u1*v2 - x0*v1*u2 - v0*u1*x2 - u0*x1*v2;\n        var deltaD = y0*v1 + v0*y2 + y1*v2 - v1*y2 - v0*y1 - y0*v2;\n        var deltaE = u0*y1 + y0*u2 + u1*y2 - y1*u2 - y0*u1 - u0*y2;\n        var deltaF = u0*v1*y2 + v0*y1*u2 + y0*u1*v2 - y0*v1*u2 - v0*u1*y2 - u0*y1*v2;\n\n        context.transform(deltaA / delta, deltaD / delta,\n                            deltaB / delta, deltaE / delta,\n                            deltaC / delta, deltaF / delta);\n\n        context.drawImage(strip.texture.baseTexture.source, 0, 0);\n        context.restore();\n    }\n};\n\n/**\n * Creates a Canvas element of the given size\n *\n * @method CanvasBuffer\n * @param width {Number} the width for the newly created canvas\n * @param height {Number} the height for the newly created canvas\n * @static\n * @private\n */\nPIXI.CanvasBuffer = function(width, height)\n{\n    this.width = width;\n    this.height = height;\n\n    this.canvas = document.createElement( \"canvas\" );\n    this.context = this.canvas.getContext( \"2d\" );\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n};\n\n/**\n * Clears the canvas that was created by the CanvasBuffer class\n *\n * @method clear\n * @private\n */\nPIXI.CanvasBuffer.prototype.clear = function()\n{\n    this.context.clearRect(0,0, this.width, this.height);\n};\n\n/**\n * Resizes the canvas that was created by the CanvasBuffer class to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the canvas\n * @param height {Number} the new height of the canvas\n * @private\n */\n\nPIXI.CanvasBuffer.prototype.resize = function(width, height)\n{\n    this.width = this.canvas.width = width;\n    this.height = this.canvas.height = height;\n};\n\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * A set of functions used by the canvas renderer to draw the primitive graphics data\n *\n * @class CanvasGraphics\n */\nPIXI.CanvasGraphics = function()\n{\n\n};\n\n\n/*\n * Renders the graphics object\n *\n * @static\n * @private\n * @method renderGraphics\n * @param graphics {Graphics} the actual graphics object to render\n * @param context {Context2D} the 2d drawing method of the canvas\n */\nPIXI.CanvasGraphics.renderGraphics = function(graphics, context)\n{\n    var worldAlpha = graphics.worldAlpha;\n    var color = '';\n\n    for (var i = 0; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n        var points = data.points;\n\n        context.strokeStyle = color = '#' + ('00000' + ( data.lineColor | 0).toString(16)).substr(-6);\n\n        context.lineWidth = data.lineWidth;\n\n        if(data.type === PIXI.Graphics.POLY)\n        {\n            context.beginPath();\n\n            context.moveTo(points[0], points[1]);\n\n            for (var j=1; j < points.length/2; j++)\n            {\n                context.lineTo(points[j * 2], points[j * 2 + 1]);\n            }\n\n            // if the first and last point are the same close the path - much neater :)\n            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])\n            {\n                context.closePath();\n            }\n\n            if(data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.stroke();\n            }\n        }\n        else if(data.type === PIXI.Graphics.RECT)\n        {\n\n            if(data.fillColor || data.fillColor === 0)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fillRect(points[0], points[1], points[2], points[3]);\n\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeRect(points[0], points[1], points[2], points[3]);\n            }\n\n        }\n        else if(data.type === PIXI.Graphics.CIRC)\n        {\n            // TODO - need to be Undefined!\n            context.beginPath();\n            context.arc(points[0], points[1], points[2],0,2*Math.PI);\n            context.closePath();\n\n            if(data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.stroke();\n            }\n        }\n        else if(data.type === PIXI.Graphics.ELIP)\n        {\n\n            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n            var ellipseData =  data.points;\n\n            var w = ellipseData[2] * 2;\n            var h = ellipseData[3] * 2;\n\n            var x = ellipseData[0] - w/2;\n            var y = ellipseData[1] - h/2;\n\n            context.beginPath();\n\n            var kappa = 0.5522848,\n                ox = (w / 2) * kappa, // control point offset horizontal\n                oy = (h / 2) * kappa, // control point offset vertical\n                xe = x + w,           // x-end\n                ye = y + h,           // y-end\n                xm = x + w / 2,       // x-middle\n                ym = y + h / 2;       // y-middle\n\n            context.moveTo(x, ym);\n            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n            context.closePath();\n\n            if(data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.stroke();\n            }\n        }\n    }\n};\n\n/*\n * Renders a graphics mask\n *\n * @static\n * @private\n * @method renderGraphicsMask\n * @param graphics {Graphics} the graphics which will be used as a mask\n * @param context {Context2D} the context 2d method of the canvas\n */\nPIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context)\n{\n    var len = graphics.graphicsData.length;\n\n    if(len === 0) return;\n\n    if(len > 1)\n    {\n        len = 1;\n        window.console.log('Pixi.js warning: masks in canvas can only mask using the first path in the graphics object');\n    }\n\n    for (var i = 0; i < 1; i++)\n    {\n        var data = graphics.graphicsData[i];\n        var points = data.points;\n\n        if(data.type === PIXI.Graphics.POLY)\n        {\n            context.beginPath();\n            context.moveTo(points[0], points[1]);\n\n            for (var j=1; j < points.length/2; j++)\n            {\n                context.lineTo(points[j * 2], points[j * 2 + 1]);\n            }\n\n            // if the first and last point are the same close the path - much neater :)\n            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])\n            {\n                context.closePath();\n            }\n\n        }\n        else if(data.type === PIXI.Graphics.RECT)\n        {\n            context.beginPath();\n            context.rect(points[0], points[1], points[2], points[3]);\n            context.closePath();\n        }\n        else if(data.type === PIXI.Graphics.CIRC)\n        {\n            // TODO - need to be Undefined!\n            context.beginPath();\n            context.arc(points[0], points[1], points[2],0,2*Math.PI);\n            context.closePath();\n        }\n        else if(data.type === PIXI.Graphics.ELIP)\n        {\n\n            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n            var ellipseData =  data.points;\n\n            var w = ellipseData[2] * 2;\n            var h = ellipseData[3] * 2;\n\n            var x = ellipseData[0] - w/2;\n            var y = ellipseData[1] - h/2;\n\n            context.beginPath();\n\n            var kappa = 0.5522848,\n                ox = (w / 2) * kappa, // control point offset horizontal\n                oy = (h / 2) * kappa, // control point offset vertical\n                xe = x + w,           // x-end\n                ye = y + h,           // y-end\n                xm = x + w / 2,       // x-middle\n                ym = y + h / 2;       // y-middle\n\n            context.moveTo(x, ym);\n            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n            context.closePath();\n        }\n    }\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * The Graphics class contains a set of methods that you can use to create primitive shapes and lines.\n * It is important to know that with the webGL renderer only simple polygons can be filled at this stage\n * Complex polygons will not be filled. Heres an example of a complex polygon: http://www.goodboydigital.com/wp-content/uploads/2013/06/complexPolygon.png\n *\n * @class Graphics\n * @extends DisplayObjectContainer\n * @constructor\n */\nPIXI.Graphics = function()\n{\n    PIXI.DisplayObjectContainer.call( this );\n\n    this.renderable = true;\n\n    /**\n     * The alpha of the fill of this graphics object\n     *\n     * @property fillAlpha\n     * @type Number\n     */\n    this.fillAlpha = 1;\n\n    /**\n     * The width of any lines drawn\n     *\n     * @property lineWidth\n     * @type Number\n     */\n    this.lineWidth = 0;\n\n    /**\n     * The color of any lines drawn\n     *\n     * @property lineColor\n     * @type String\n     */\n    this.lineColor = \"black\";\n\n    /**\n     * Graphics data\n     *\n     * @property graphicsData\n     * @type Array\n     * @private\n     */\n    this.graphicsData = [];\n\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;// * Math.random();\n    \n    /**\n     * The blend mode to be applied to the graphic shape\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n    \n    /**\n     * Current path\n     *\n     * @property currentPath\n     * @type Object\n     * @private\n     */\n    this.currentPath = {points:[]};\n\n    /**\n     * Array containing some WebGL-related properties used by the WebGL renderer\n     *\n     * @property _webGL\n     * @type Array\n     * @private\n     */\n    this._webGL = [];\n\n    /**\n     * Whether this shape is being used as a mask\n     *\n     * @property isMask\n     * @type isMask\n     */\n    this.isMask = false;\n\n    /**\n     * The bounds of the graphic shape as rectangle object\n     *\n     * @property bounds\n     * @type Rectangle\n     */\n    this.bounds = null;\n\n    /**\n     * the bounds' padding used for bounds calculation\n     *\n     * @property bounds\n     * @type Number\n     */\n    this.boundsPadding = 10;\n};\n\n// constructor\nPIXI.Graphics.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Graphics.prototype.constructor = PIXI.Graphics;\n\n/**\n * If cacheAsBitmap is true the graphics object will then be rendered as if it was a sprite.\n * This is useful if your graphics element does not change often as it will speed up the rendering of the object\n * It is also usful as the graphics object will always be antialiased because it will be rendered using canvas\n * Not recommended if you are constanly redrawing the graphics element.\n *\n * @property cacheAsBitmap\n * @default false\n * @type Boolean\n * @private\n */\nObject.defineProperty(PIXI.Graphics.prototype, \"cacheAsBitmap\", {\n    get: function() {\n        return  this._cacheAsBitmap;\n    },\n    set: function(value) {\n        this._cacheAsBitmap = value;\n\n        if(this._cacheAsBitmap)\n        {\n            this._generateCachedSprite();\n        }\n        else\n        {\n            this.destroyCachedSprite();\n            this.dirty = true;\n        }\n\n    }\n});\n\n\n/**\n * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.\n *\n * @method lineStyle\n * @param lineWidth {Number} width of the line to draw, will update the object's stored style\n * @param color {Number} color of the line to draw, will update the object's stored style\n * @param alpha {Number} alpha of the line to draw, will update the object's stored style\n */\nPIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha)\n{\n    if (!this.currentPath.points.length) this.graphicsData.pop();\n\n    this.lineWidth = lineWidth || 0;\n    this.lineColor = color || 0;\n    this.lineAlpha = (arguments.length < 3) ? 1 : alpha;\n\n    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,\n                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};\n\n    this.graphicsData.push(this.currentPath);\n\n    return this;\n};\n\n/**\n * Moves the current drawing position to (x, y).\n *\n * @method moveTo\n * @param x {Number} the X coordinate to move to\n * @param y {Number} the Y coordinate to move to\n */\nPIXI.Graphics.prototype.moveTo = function(x, y)\n{\n    if (!this.currentPath.points.length) this.graphicsData.pop();\n\n    this.currentPath = this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,\n                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};\n\n    this.currentPath.points.push(x, y);\n\n    this.graphicsData.push(this.currentPath);\n\n    return this;\n};\n\n/**\n * Draws a line using the current line style from the current drawing position to (x, y);\n * the current drawing position is then set to (x, y).\n *\n * @method lineTo\n * @param x {Number} the X coordinate to draw to\n * @param y {Number} the Y coordinate to draw to\n */\nPIXI.Graphics.prototype.lineTo = function(x, y)\n{\n    this.currentPath.points.push(x, y);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n * (such as lineTo() or drawCircle()) use when drawing.\n *\n * @method beginFill\n * @param color {Number} the color of the fill\n * @param alpha {Number} the alpha of the fill\n */\nPIXI.Graphics.prototype.beginFill = function(color, alpha)\n{\n\n    this.filling = true;\n    this.fillColor = color || 0;\n    this.fillAlpha = (arguments.length < 2) ? 1 : alpha;\n\n    return this;\n};\n\n/**\n * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n *\n * @method endFill\n */\nPIXI.Graphics.prototype.endFill = function()\n{\n    this.filling = false;\n    this.fillColor = null;\n    this.fillAlpha = 1;\n\n    return this;\n};\n\n/**\n * @method drawRect\n *\n * @param x {Number} The X coord of the top-left of the rectangle\n * @param y {Number} The Y coord of the top-left of the rectangle\n * @param width {Number} The width of the rectangle\n * @param height {Number} The height of the rectangle\n */\nPIXI.Graphics.prototype.drawRect = function( x, y, width, height )\n{\n    if (!this.currentPath.points.length) this.graphicsData.pop();\n\n    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,\n                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,\n                        points:[x, y, width, height], type:PIXI.Graphics.RECT};\n\n    this.graphicsData.push(this.currentPath);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Draws a circle.\n *\n * @method drawCircle\n * @param x {Number} The X coordinate of the center of the circle\n * @param y {Number} The Y coordinate of the center of the circle\n * @param radius {Number} The radius of the circle\n */\nPIXI.Graphics.prototype.drawCircle = function( x, y, radius)\n{\n\n    if (!this.currentPath.points.length) this.graphicsData.pop();\n\n    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,\n                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,\n                        points:[x, y, radius, radius], type:PIXI.Graphics.CIRC};\n\n    this.graphicsData.push(this.currentPath);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Draws an ellipse.\n *\n * @method drawEllipse\n * @param x {Number} The X coordinate of the upper-left corner of the framing rectangle of this ellipse\n * @param y {Number} The Y coordinate of the upper-left corner of the framing rectangle of this ellipse\n * @param width {Number} The width of the ellipse\n * @param height {Number} The height of the ellipse\n */\nPIXI.Graphics.prototype.drawEllipse = function( x, y, width, height)\n{\n\n    if (!this.currentPath.points.length) this.graphicsData.pop();\n\n    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,\n                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,\n                        points:[x, y, width, height], type:PIXI.Graphics.ELIP};\n\n    this.graphicsData.push(this.currentPath);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n *\n * @method clear\n */\nPIXI.Graphics.prototype.clear = function()\n{\n    this.lineWidth = 0;\n    this.filling = false;\n\n    this.dirty = true;\n    this.clearDirty = true;\n    this.graphicsData = [];\n\n    this.bounds = null; //new PIXI.Rectangle();\n\n    return this;\n};\n\n/**\n * Useful function that returns a texture of the graphics object that can then be used to create sprites\n * This can be quite useful if your geometry is complicated and needs to be reused multiple times.\n *\n * @method generateTexture\n * @return {Texture} a texture of the graphics object\n */\nPIXI.Graphics.prototype.generateTexture = function()\n{\n    var bounds = this.getBounds();\n\n    var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);\n    var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);\n\n    canvasBuffer.context.translate(-bounds.x,-bounds.y);\n    \n    PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context);\n\n    return texture;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Graphics.prototype._renderWebGL = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;\n    \n    if(this._cacheAsBitmap)\n    {\n       \n        if(this.dirty)\n        {\n            this._generateCachedSprite();\n            // we will also need to update the texture on the gpu too!\n            PIXI.updateWebGLTexture(this._cachedSprite.texture.baseTexture, renderSession.gl);\n            \n            this.dirty =  false;\n        }\n\n        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);\n\n        return;\n    }\n    else\n    {\n        renderSession.spriteBatch.stop();\n\n        if(this._mask)renderSession.maskManager.pushMask(this.mask, renderSession);\n        if(this._filters)renderSession.filterManager.pushFilter(this._filterBlock);\n      \n        // check blend mode\n        if(this.blendMode !== renderSession.spriteBatch.currentBlendMode)\n        {\n            renderSession.spriteBatch.currentBlendMode = this.blendMode;\n            var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];\n            renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n        }\n     \n        PIXI.WebGLGraphics.renderGraphics(this, renderSession);\n        \n        // only render if it has children!\n        if(this.children.length)\n        {\n            renderSession.spriteBatch.start();\n\n             // simple render children!\n            for(var i=0, j=this.children.length; i<j; i++)\n            {\n                this.children[i]._renderWebGL(renderSession);\n            }\n\n            renderSession.spriteBatch.stop();\n        }\n\n        if(this._filters)renderSession.filterManager.popFilter();\n        if(this._mask)renderSession.maskManager.popMask(renderSession);\n          \n        renderSession.drawCount++;\n\n        renderSession.spriteBatch.start();\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Graphics.prototype._renderCanvas = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;\n    \n    var context = renderSession.context;\n    var transform = this.worldTransform;\n    \n    if(this.blendMode !== renderSession.currentBlendMode)\n    {\n        renderSession.currentBlendMode = this.blendMode;\n        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n    }\n\n    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);\n    PIXI.CanvasGraphics.renderGraphics(this, context);\n\n     // simple render children!\n    for(var i=0, j=this.children.length; i<j; i++)\n    {\n        this.children[i]._renderCanvas(renderSession);\n    }\n};\n\n/**\n * Retrieves the bounds of the graphic shape as a rectangle object\n *\n * @method getBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.Graphics.prototype.getBounds = function( matrix )\n{\n    if(!this.bounds)this.updateBounds();\n\n    var w0 = this.bounds.x;\n    var w1 = this.bounds.width + this.bounds.x;\n\n    var h0 = this.bounds.y;\n    var h1 = this.bounds.height + this.bounds.y;\n\n    var worldTransform = matrix || this.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.c;\n    var c = worldTransform.b;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    minX = x1 < minX ? x1 : minX;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y1 < minY ? y1 : minY;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x1 > maxX ? x1 : maxX;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y1 > maxY ? y1 : maxY;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    return bounds;\n};\n\n/**\n * Update the bounds of the object\n *\n * @method updateBounds\n */\nPIXI.Graphics.prototype.updateBounds = function()\n{\n    \n    var minX = Infinity;\n    var maxX = -Infinity;\n\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    var points, x, y, w, h;\n\n    for (var i = 0; i < this.graphicsData.length; i++) {\n        var data = this.graphicsData[i];\n        var type = data.type;\n        var lineWidth = data.lineWidth;\n\n        points = data.points;\n\n        if(type === PIXI.Graphics.RECT)\n        {\n            x = points[0] - lineWidth/2;\n            y = points[1] - lineWidth/2;\n            w = points[2] + lineWidth;\n            h = points[3] + lineWidth;\n\n            minX = x < minX ? x : minX;\n            maxX = x + w > maxX ? x + w : maxX;\n\n            minY = y < minY ? x : minY;\n            maxY = y + h > maxY ? y + h : maxY;\n        }\n        else if(type === PIXI.Graphics.CIRC || type === PIXI.Graphics.ELIP)\n        {\n            x = points[0];\n            y = points[1];\n            w = points[2] + lineWidth/2;\n            h = points[3] + lineWidth/2;\n\n            minX = x - w < minX ? x - w : minX;\n            maxX = x + w > maxX ? x + w : maxX;\n\n            minY = y - h < minY ? y - h : minY;\n            maxY = y + h > maxY ? y + h : maxY;\n        }\n        else\n        {\n            // POLY\n            for (var j = 0; j < points.length; j+=2)\n            {\n\n                x = points[j];\n                y = points[j+1];\n                minX = x-lineWidth < minX ? x-lineWidth : minX;\n                maxX = x+lineWidth > maxX ? x+lineWidth : maxX;\n\n                minY = y-lineWidth < minY ? y-lineWidth : minY;\n                maxY = y+lineWidth > maxY ? y+lineWidth : maxY;\n            }\n        }\n    }\n\n    var padding = this.boundsPadding;\n    this.bounds = new PIXI.Rectangle(minX - padding, minY - padding, (maxX - minX) + padding * 2, (maxY - minY) + padding * 2);\n};\n\n\n/**\n * Generates the cached sprite when the sprite has cacheAsBitmap = true\n *\n * @method _generateCachedSprite\n * @private\n */\nPIXI.Graphics.prototype._generateCachedSprite = function()\n{\n    var bounds = this.getLocalBounds();\n\n    if(!this._cachedSprite)\n    {\n        var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);\n        var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);\n        \n        this._cachedSprite = new PIXI.Sprite(texture);\n        this._cachedSprite.buffer = canvasBuffer;\n\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.buffer.resize(bounds.width, bounds.height);\n    }\n\n    // leverage the anchor to account for the offset of the element\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n   // this._cachedSprite.buffer.context.save();\n    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);\n    \n    PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);\n   // this._cachedSprite.buffer.context.restore();\n};\n\nPIXI.Graphics.prototype.destroyCachedSprite = function()\n{\n    this._cachedSprite.texture.destroy(true);\n\n    // let the gc collect the unused sprite\n    // TODO could be object pooled!\n    this._cachedSprite = null;\n};\n\n\n// SOME TYPES:\nPIXI.Graphics.POLY = 0;\nPIXI.Graphics.RECT = 1;\nPIXI.Graphics.CIRC = 2;\nPIXI.Graphics.ELIP = 3;\n\r\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n /**\n * \n * @class Strip\n * @extends DisplayObjectContainer\n * @constructor\n * @param texture {Texture} The texture to use\n * @param width {Number} the width \n * @param height {Number} the height\n * \n */\nPIXI.Strip = function(texture, width, height)\n{\n    PIXI.DisplayObjectContainer.call( this );\n    this.texture = texture;\n    this.blendMode = PIXI.blendModes.NORMAL;\n\n    try\n    {\n        this.uvs = new Float32Array([0, 1,\n                1, 1,\n                1, 0, 0,1]);\n\n        this.verticies = new Float32Array([0, 0,\n                          0,0,\n                          0,0, 0,\n                          0, 0]);\n\n        this.colors = new Float32Array([1, 1, 1, 1]);\n\n        this.indices = new Uint16Array([0, 1, 2, 3]);\n    }\n    catch(error)\n    {\n        this.uvs = [0, 1,\n                1, 1,\n                1, 0, 0,1];\n\n        this.verticies = [0, 0,\n                          0,0,\n                          0,0, 0,\n                          0, 0];\n\n        this.colors = [1, 1, 1, 1];\n\n        this.indices = [0, 1, 2, 3];\n    }\n\n\n    /*\n    this.uvs = new Float32Array()\n    this.verticies = new Float32Array()\n    this.colors = new Float32Array()\n    this.indices = new Uint16Array()\n    */\n    \n    this.width = width;\n    this.height = height;\n\n    // load the texture!\n    if(texture.baseTexture.hasLoaded)\n    {\n        this.width   = this.texture.frame.width;\n        this.height  = this.texture.frame.height;\n        this.updateFrame = true;\n    }\n    else\n    {\n        this.onTextureUpdateBind = this.onTextureUpdate.bind(this);\n        this.texture.addEventListener( 'update', this.onTextureUpdateBind );\n    }\n\n    this.renderable = true;\n};\n\n// constructor\nPIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.Strip.prototype.constructor = PIXI.Strip;\n\n/*\n * Sets the texture that the Strip will use \n *\n * @method setTexture\n * @param texture {Texture} the texture that will be used\n * @private\n */\nPIXI.Strip.prototype.setTexture = function(texture)\n{\n    //TODO SET THE TEXTURES\n    //TODO VISIBILITY\n\n    // stop current texture\n    this.texture = texture;\n    this.width   = texture.frame.width;\n    this.height  = texture.frame.height;\n    this.updateFrame = true;\n};\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\nPIXI.Strip.prototype.onTextureUpdate = function()\n{\n    this.updateFrame = true;\n};\r\n/* @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * \n * @class Rope\n * @constructor\n * @param texture {Texture} The texture to use\n * @param points {Array}\n * \n */\nPIXI.Rope = function(texture, points)\n{\n    PIXI.Strip.call( this, texture );\n    this.points = points;\n\n    try\n    {\n        this.verticies = new Float32Array(points.length * 4);\n        this.uvs = new Float32Array(points.length * 4);\n        this.colors = new Float32Array(points.length * 2);\n        this.indices = new Uint16Array(points.length * 2);\n    }\n    catch(error)\n    {\n        this.verticies = new Array(points.length * 4);\n        this.uvs = new Array(points.length * 4);\n        this.colors = new Array(points.length * 2);\n        this.indices = new Array(points.length * 2);\n    }\n\n    this.refresh();\n};\n\n\n// constructor\nPIXI.Rope.prototype = Object.create( PIXI.Strip.prototype );\nPIXI.Rope.prototype.constructor = PIXI.Rope;\n\n/*\n * Refreshes \n *\n * @method refresh\n */\nPIXI.Rope.prototype.refresh = function()\n{\n    var points = this.points;\n    if(points.length < 1) return;\n\n    var uvs = this.uvs;\n\n    var lastPoint = points[0];\n    var indices = this.indices;\n    var colors = this.colors;\n\n    this.count-=0.2;\n\n\n    uvs[0] = 0;\n    uvs[1] = 1;\n    uvs[2] = 0;\n    uvs[3] = 1;\n\n    colors[0] = 1;\n    colors[1] = 1;\n\n    indices[0] = 0;\n    indices[1] = 1;\n\n    var total = points.length,\n        point, index, amount;\n\n    for (var i = 1; i < total; i++)\n    {\n\n        point = points[i];\n        index = i * 4;\n        // time to do some smart drawing!\n        amount = i / (total-1);\n\n        if(i%2)\n        {\n            uvs[index] = amount;\n            uvs[index+1] = 0;\n\n            uvs[index+2] = amount;\n            uvs[index+3] = 1;\n\n        }\n        else\n        {\n            uvs[index] = amount;\n            uvs[index+1] = 0;\n\n            uvs[index+2] = amount;\n            uvs[index+3] = 1;\n        }\n\n        index = i * 2;\n        colors[index] = 1;\n        colors[index+1] = 1;\n\n        index = i * 2;\n        indices[index] = index;\n        indices[index + 1] = index + 1;\n\n        lastPoint = point;\n    }\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.Rope.prototype.updateTransform = function()\n{\n\n    var points = this.points;\n    if(points.length < 1)return;\n\n    var lastPoint = points[0];\n    var nextPoint;\n    var perp = {x:0, y:0};\n\n    this.count-=0.2;\n\n    var verticies = this.verticies;\n    verticies[0] = lastPoint.x + perp.x;\n    verticies[1] = lastPoint.y + perp.y; //+ 200\n    verticies[2] = lastPoint.x - perp.x;\n    verticies[3] = lastPoint.y - perp.y;//+200\n    // time to do some smart drawing!\n\n    var total = points.length,\n        point, index, ratio, perpLength, num;\n\n    for (var i = 1; i < total; i++)\n    {\n        point = points[i];\n        index = i * 4;\n\n        if(i < points.length-1)\n        {\n            nextPoint = points[i+1];\n        }\n        else\n        {\n            nextPoint = point;\n        }\n\n        perp.y = -(nextPoint.x - lastPoint.x);\n        perp.x = nextPoint.y - lastPoint.y;\n\n        ratio = (1 - (i / (total-1))) * 10;\n\n        if(ratio > 1) ratio = 1;\n\n        perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y);\n        num = this.texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n        perp.x /= perpLength;\n        perp.y /= perpLength;\n\n        perp.x *= num;\n        perp.y *= num;\n\n        verticies[index] = point.x + perp.x;\n        verticies[index+1] = point.y + perp.y;\n        verticies[index+2] = point.x - perp.x;\n        verticies[index+3] = point.y - perp.y;\n\n        lastPoint = point;\n    }\n\n    PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );\n};\n/*\n * Sets the texture that the Rope will use \n *\n * @method setTexture\n * @param texture {Texture} the texture that will be used\n */\nPIXI.Rope.prototype.setTexture = function(texture)\n{\n    // stop current texture\n    this.texture = texture;\n    this.updateFrame = true;\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class TilingSprite\n * @extends DisplayObjectContainer\n * @constructor\n * @param texture {Texture} the texture of the tiling sprite\n * @param width {Number}  the width of the tiling sprite\n * @param height {Number} the height of the tiling sprite\n */\nPIXI.TilingSprite = function(texture, width, height)\n{\n    PIXI.Sprite.call( this, texture);\n\n    /**\n     * The with of the tiling sprite\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = width || 100;\n    /**\n     * The height of the tiling sprite\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = height || 100;\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @property tileScale\n     * @type Point\n     */\n    this.tileScale = new PIXI.Point(1,1);\n\n    /**\n     * A point that represents the scale of the texture object\n     *\n     * @property tileScaleOffset\n     * @type Point\n     */\n    this.tileScaleOffset = new PIXI.Point(1,1);\n    \n    /**\n     * The offset position of the image that is being tiled\n     *\n     * @property tilePosition\n     * @type Point\n     */\n    this.tilePosition = new PIXI.Point(0,0);\n\n\n    /**\n     * Whether this sprite is renderable or not\n     *\n     * @property renderable\n     * @type Boolean\n     * @default true\n     */\n    this.renderable = true;\n\n    /**\n     * The tint applied to the sprite. This is a hex value\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n    \n    /**\n     * The blend mode to be applied to the sprite\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n};\n\n// constructor\nPIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype);\nPIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;\n\n\n/**\n * The width of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.TilingSprite.prototype, 'width', {\n    get: function() {\n        return this._width;\n    },\n    set: function(value) {\n        \n        this._width = value;\n    }\n});\n\n/**\n * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.TilingSprite.prototype, 'height', {\n    get: function() {\n        return  this._height;\n    },\n    set: function(value) {\n        this._height = value;\n    }\n});\n\n/**\n * When the texture is updated, this event will be fired to update the scale and frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\nPIXI.TilingSprite.prototype.onTextureUpdate = function()\n{\n    this.updateFrame = true;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.TilingSprite.prototype._renderWebGL = function(renderSession)\n{\n\n    if(this.visible === false || this.alpha === 0)return;\n    \n    var i,j;\n\n    if(this.mask || this.filters)\n    {\n        if(this.mask)\n        {\n            renderSession.spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            renderSession.spriteBatch.start();\n        }\n\n        if(this.filters)\n        {\n            renderSession.spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        if(!this.tilingTexture)this.generateTilingTexture(true);\n        else renderSession.spriteBatch.renderTilingSprite(this);\n\n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        renderSession.spriteBatch.stop();\n\n        if(this.filters)renderSession.filterManager.popFilter();\n        if(this.mask)renderSession.maskManager.popMask(renderSession);\n        \n        renderSession.spriteBatch.start();\n    }\n    else\n    {\n        if(!this.tilingTexture)this.generateTilingTexture(true);\n        else renderSession.spriteBatch.renderTilingSprite(this);\n        \n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.TilingSprite.prototype._renderCanvas = function(renderSession)\n{\n    if(this.visible === false || this.alpha === 0)return;\n    \n    var context = renderSession.context;\n\n    if(this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, context);\n    }\n\n    context.globalAlpha = this.worldAlpha;\n\n    \n    var transform = this.worldTransform;\n\n    // allow for trimming\n\n    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);\n\n\n    if(!this.__tilePattern)\n    {\n        this.generateTilingTexture(false);\n        \n        if(this.tilingTexture)\n        {\n            this.__tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, 'repeat');\n        }\n\n    }\n\n    // check blend mode\n    if(this.blendMode !== renderSession.currentBlendMode)\n    {\n        renderSession.currentBlendMode = this.blendMode;\n        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n    }\n\n    context.beginPath();\n\n    var tilePosition = this.tilePosition;\n    var tileScale = this.tileScale;\n\n    tilePosition.x %= this.tilingTexture.baseTexture.width;\n    tilePosition.y %= this.tilingTexture.baseTexture.height;\n\n    // offset\n    context.scale(tileScale.x,tileScale.y);\n    context.translate(tilePosition.x, tilePosition.y);\n\n    context.fillStyle = this.__tilePattern;\n    context.fillRect(-tilePosition.x,-tilePosition.y,this.width / tileScale.x, this.height / tileScale.y);\n\n    context.scale(1/tileScale.x, 1/tileScale.y);\n    context.translate(-tilePosition.x, -tilePosition.y);\n\n    context.closePath();\n\n    if(this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession.context);\n    }\n};\n\n\n/**\n* Returns the framing rectangle of the sprite as a PIXI.Rectangle object\n*\n* @method getBounds\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.TilingSprite.prototype.getBounds = function()\n{\n\n    var width = this._width;\n    var height = this._height;\n\n    var w0 = width * (1-this.anchor.x);\n    var w1 = width * -this.anchor.x;\n\n    var h0 = height * (1-this.anchor.y);\n    var h1 = height * -this.anchor.y;\n\n    var worldTransform = this.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.c;\n    var c = worldTransform.b;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n    \n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    minX = x1 < minX ? x1 : minX;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y1 < minY ? y1 : minY;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x1 > maxX ? x1 : maxX;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y1 > maxY ? y1 : maxY;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    this._currentBounds = bounds;\n\n    return bounds;\n};\n\n/**\n* \n* @method generateTilingTexture\n* \n* @param forcePowerOfTwo {Boolean} Whether we want to force the texture to be a power of two\n*/\nPIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo)\n{\n    var texture = this.texture;\n\n    if(!texture.baseTexture.hasLoaded)return;\n\n    var baseTexture = texture.baseTexture;\n    var frame = texture.frame;\n\n    var targetWidth, targetHeight;\n\n    // check that the frame is the same size as the base texture.\n    \n    var isFrame = frame.width !== baseTexture.width || frame.height !== baseTexture.height;\n\n    this.tilingTexture = texture;\n\n    var newTextureRequired = false;\n\n    if(!forcePowerOfTwo)\n    {\n        if(isFrame)\n        {\n            targetWidth = frame.width;\n            targetHeight = frame.height;\n            \n            newTextureRequired = true;\n        }\n    }\n    else\n    {\n        targetWidth = PIXI.getNextPowerOfTwo(texture.frame.width);\n        targetHeight = PIXI.getNextPowerOfTwo(texture.frame.height);\n\n        if(frame.width !== targetWidth && frame.height !== targetHeight)newTextureRequired = true;\n    }\n\n    if(newTextureRequired)\n    {\n        var canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight);\n        \n        canvasBuffer.context.drawImage(texture.baseTexture.source,\n                                       frame.x,\n                                       frame.y,\n                                       frame.width,\n                                       frame.height,\n                                       0,\n                                       0,\n                                       targetWidth,\n                                       targetHeight);\n\n        this.tilingTexture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);\n\n        this.tileScaleOffset.x = frame.width / targetWidth;\n        this.tileScaleOffset.y = frame.height / targetHeight;\n    }\n\n   \n    this.tilingTexture.baseTexture._powerOf2 = true;\n};\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi\n *\n * Awesome JS run time provided by EsotericSoftware\n * https://github.com/EsotericSoftware/spine-runtimes\n *\n */\n\n/*\n * Awesome JS run time provided by EsotericSoftware\n *\n * https://github.com/EsotericSoftware/spine-runtimes\n *\n */\n\n\n\nvar spine = {};\n\nspine.BoneData = function (name, parent) {\n    this.name = name;\n    this.parent = parent;\n};\nspine.BoneData.prototype = {\n    length: 0,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1\n};\n\nspine.SlotData = function (name, boneData) {\n    this.name = name;\n    this.boneData = boneData;\n};\nspine.SlotData.prototype = {\n    r: 1, g: 1, b: 1, a: 1,\n    attachmentName: null\n};\n\nspine.Bone = function (boneData, parent) {\n    this.data = boneData;\n    this.parent = parent;\n    this.setToSetupPose();\n};\nspine.Bone.yDown = false;\nspine.Bone.prototype = {\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    m00: 0, m01: 0, worldX: 0, // a b x\n    m10: 0, m11: 0, worldY: 0, // c d y\n    worldRotation: 0,\n    worldScaleX: 1, worldScaleY: 1,\n    updateWorldTransform: function (flipX, flipY) {\n        var parent = this.parent;\n        if (parent != null) {\n            this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;\n            this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;\n            this.worldScaleX = parent.worldScaleX * this.scaleX;\n            this.worldScaleY = parent.worldScaleY * this.scaleY;\n            this.worldRotation = parent.worldRotation + this.rotation;\n        } else {\n            this.worldX = this.x;\n            this.worldY = this.y;\n            this.worldScaleX = this.scaleX;\n            this.worldScaleY = this.scaleY;\n            this.worldRotation = this.rotation;\n        }\n        var radians = this.worldRotation * Math.PI / 180;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        this.m00 = cos * this.worldScaleX;\n        this.m10 = sin * this.worldScaleX;\n        this.m01 = -sin * this.worldScaleY;\n        this.m11 = cos * this.worldScaleY;\n        if (flipX) {\n            this.m00 = -this.m00;\n            this.m01 = -this.m01;\n        }\n        if (flipY) {\n            this.m10 = -this.m10;\n            this.m11 = -this.m11;\n        }\n        if (spine.Bone.yDown) {\n            this.m10 = -this.m10;\n            this.m11 = -this.m11;\n        }\n    },\n    setToSetupPose: function () {\n        var data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n    }\n};\n\nspine.Slot = function (slotData, skeleton, bone) {\n    this.data = slotData;\n    this.skeleton = skeleton;\n    this.bone = bone;\n    this.setToSetupPose();\n};\nspine.Slot.prototype = {\n    r: 1, g: 1, b: 1, a: 1,\n    _attachmentTime: 0,\n    attachment: null,\n    setAttachment: function (attachment) {\n        this.attachment = attachment;\n        this._attachmentTime = this.skeleton.time;\n    },\n    setAttachmentTime: function (time) {\n        this._attachmentTime = this.skeleton.time - time;\n    },\n    getAttachmentTime: function () {\n        return this.skeleton.time - this._attachmentTime;\n    },\n    setToSetupPose: function () {\n        var data = this.data;\n        this.r = data.r;\n        this.g = data.g;\n        this.b = data.b;\n        this.a = data.a;\n\n        var slotDatas = this.skeleton.data.slots;\n        for (var i = 0, n = slotDatas.length; i < n; i++) {\n            if (slotDatas[i] == data) {\n                this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\n                break;\n            }\n        }\n    }\n};\n\nspine.Skin = function (name) {\n    this.name = name;\n    this.attachments = {};\n};\nspine.Skin.prototype = {\n    addAttachment: function (slotIndex, name, attachment) {\n        this.attachments[slotIndex + \":\" + name] = attachment;\n    },\n    getAttachment: function (slotIndex, name) {\n        return this.attachments[slotIndex + \":\" + name];\n    },\n    _attachAll: function (skeleton, oldSkin) {\n        for (var key in oldSkin.attachments) {\n            var colon = key.indexOf(\":\");\n            var slotIndex = parseInt(key.substring(0, colon), 10);\n            var name = key.substring(colon + 1);\n            var slot = skeleton.slots[slotIndex];\n            if (slot.attachment && slot.attachment.name == name) {\n                var attachment = this.getAttachment(slotIndex, name);\n                if (attachment) slot.setAttachment(attachment);\n            }\n        }\n    }\n};\n\nspine.Animation = function (name, timelines, duration) {\n    this.name = name;\n    this.timelines = timelines;\n    this.duration = duration;\n};\nspine.Animation.prototype = {\n    apply: function (skeleton, time, loop) {\n        if (loop && this.duration) time %= this.duration;\n        var timelines = this.timelines;\n        for (var i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, time, 1);\n    },\n    mix: function (skeleton, time, loop, alpha) {\n        if (loop && this.duration) time %= this.duration;\n        var timelines = this.timelines;\n        for (var i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, time, alpha);\n    }\n};\n\nspine.binarySearch = function (values, target, step) {\n    var low = 0;\n    var high = Math.floor(values.length / step) - 2;\n    if (!high) return step;\n    var current = high >>> 1;\n    while (true) {\n        if (values[(current + 1) * step] <= target)\n            low = current + 1;\n        else\n            high = current;\n        if (low == high) return (low + 1) * step;\n        current = (low + high) >>> 1;\n    }\n};\nspine.linearSearch = function (values, target, step) {\n    for (var i = 0, last = values.length - step; i <= last; i += step)\n        if (values[i] > target) return i;\n    return -1;\n};\n\nspine.Curves = function (frameCount) {\n    this.curves = []; // dfx, dfy, ddfx, ddfy, dddfx, dddfy, ...\n    this.curves.length = (frameCount - 1) * 6;\n};\nspine.Curves.prototype = {\n    setLinear: function (frameIndex) {\n        this.curves[frameIndex * 6] = 0/*LINEAR*/;\n    },\n    setStepped: function (frameIndex) {\n        this.curves[frameIndex * 6] = -1/*STEPPED*/;\n    },\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n     * the difference between the keyframe's values. */\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2) {\n        var subdiv_step = 1 / 10/*BEZIER_SEGMENTS*/;\n        var subdiv_step2 = subdiv_step * subdiv_step;\n        var subdiv_step3 = subdiv_step2 * subdiv_step;\n        var pre1 = 3 * subdiv_step;\n        var pre2 = 3 * subdiv_step2;\n        var pre4 = 6 * subdiv_step2;\n        var pre5 = 6 * subdiv_step3;\n        var tmp1x = -cx1 * 2 + cx2;\n        var tmp1y = -cy1 * 2 + cy2;\n        var tmp2x = (cx1 - cx2) * 3 + 1;\n        var tmp2y = (cy1 - cy2) * 3 + 1;\n        var i = frameIndex * 6;\n        var curves = this.curves;\n        curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;\n        curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;\n        curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;\n        curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;\n        curves[i + 4] = tmp2x * pre5;\n        curves[i + 5] = tmp2y * pre5;\n    },\n    getCurvePercent: function (frameIndex, percent) {\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\n        var curveIndex = frameIndex * 6;\n        var curves = this.curves;\n        var dfx = curves[curveIndex];\n        if (!dfx/*LINEAR*/) return percent;\n        if (dfx == -1/*STEPPED*/) return 0;\n        var dfy = curves[curveIndex + 1];\n        var ddfx = curves[curveIndex + 2];\n        var ddfy = curves[curveIndex + 3];\n        var dddfx = curves[curveIndex + 4];\n        var dddfy = curves[curveIndex + 5];\n        var x = dfx, y = dfy;\n        var i = 10/*BEZIER_SEGMENTS*/ - 2;\n        while (true) {\n            if (x >= percent) {\n                var lastX = x - dfx;\n                var lastY = y - dfy;\n                return lastY + (y - lastY) * (percent - lastX) / (x - lastX);\n            }\n            if (!i) break;\n            i--;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n    }\n};\n\nspine.RotateTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, angle, ...\n    this.frames.length = frameCount * 2;\n};\nspine.RotateTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function () {\n        return this.frames.length / 2;\n    },\n    setFrame: function (frameIndex, time, angle) {\n        frameIndex *= 2;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = angle;\n    },\n    apply: function (skeleton, time, alpha) {\n        var frames = this.frames,\n            amount;\n\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 2]) { // Time is after last frame.\n            amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\n            while (amount > 180)\n                amount -= 360;\n            while (amount < -180)\n                amount += 360;\n            bone.rotation += amount * alpha;\n            return;\n        }\n\n        // Interpolate between the last frame and the current frame.\n        var frameIndex = spine.binarySearch(frames, time, 2);\n        var lastFrameValue = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*LAST_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\n\n        amount = frames[frameIndex + 1/*FRAME_VALUE*/] - lastFrameValue;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        bone.rotation += amount * alpha;\n    }\n};\n\nspine.TranslateTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.TranslateTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function () {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, x, y) {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function (skeleton, time, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3]) { // Time is after last frame.\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\n            return;\n        }\n\n        // Interpolate between the last frame and the current frame.\n        var frameIndex = spine.binarySearch(frames, time, 3);\n        var lastFrameX = frames[frameIndex - 2];\n        var lastFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.x) * alpha;\n        bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.y) * alpha;\n    }\n};\n\nspine.ScaleTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.ScaleTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function () {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, x, y) {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function (skeleton, time, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3]) { // Time is after last frame.\n            bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;\n            bone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;\n            return;\n        }\n\n        // Interpolate between the last frame and the current frame.\n        var frameIndex = spine.binarySearch(frames, time, 3);\n        var lastFrameX = frames[frameIndex - 2];\n        var lastFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.scaleX) * alpha;\n        bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.scaleY) * alpha;\n    }\n};\n\nspine.ColorTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, r, g, b, a, ...\n    this.frames.length = frameCount * 5;\n};\nspine.ColorTimeline.prototype = {\n    slotIndex: 0,\n    getFrameCount: function () {\n        return this.frames.length / 2;\n    },\n    setFrame: function (frameIndex, time, x, y) {\n        frameIndex *= 5;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = r;\n        this.frames[frameIndex + 2] = g;\n        this.frames[frameIndex + 3] = b;\n        this.frames[frameIndex + 4] = a;\n    },\n    apply: function (skeleton, time, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var slot = skeleton.slots[this.slotIndex];\n\n        if (time >= frames[frames.length - 5]) { // Time is after last frame.\n            var i = frames.length - 1;\n            slot.r = frames[i - 3];\n            slot.g = frames[i - 2];\n            slot.b = frames[i - 1];\n            slot.a = frames[i];\n            return;\n        }\n\n        // Interpolate between the last frame and the current frame.\n        var frameIndex = spine.binarySearch(frames, time, 5);\n        var lastFrameR = frames[frameIndex - 4];\n        var lastFrameG = frames[frameIndex - 3];\n        var lastFrameB = frames[frameIndex - 2];\n        var lastFrameA = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*LAST_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\n\n        var r = lastFrameR + (frames[frameIndex + 1/*FRAME_R*/] - lastFrameR) * percent;\n        var g = lastFrameG + (frames[frameIndex + 2/*FRAME_G*/] - lastFrameG) * percent;\n        var b = lastFrameB + (frames[frameIndex + 3/*FRAME_B*/] - lastFrameB) * percent;\n        var a = lastFrameA + (frames[frameIndex + 4/*FRAME_A*/] - lastFrameA) * percent;\n        if (alpha < 1) {\n            slot.r += (r - slot.r) * alpha;\n            slot.g += (g - slot.g) * alpha;\n            slot.b += (b - slot.b) * alpha;\n            slot.a += (a - slot.a) * alpha;\n        } else {\n            slot.r = r;\n            slot.g = g;\n            slot.b = b;\n            slot.a = a;\n        }\n    }\n};\n\nspine.AttachmentTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.attachmentNames = []; // time, ...\n    this.attachmentNames.length = frameCount;\n};\nspine.AttachmentTimeline.prototype = {\n    slotIndex: 0,\n    getFrameCount: function () {\n            return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, attachmentName) {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    },\n    apply: function (skeleton, time, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameIndex;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frameIndex = frames.length - 1;\n        else\n            frameIndex = spine.binarySearch(frames, time, 1) - 1;\n\n        var attachmentName = this.attachmentNames[frameIndex];\n        skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\n    }\n};\n\nspine.SkeletonData = function () {\n    this.bones = [];\n    this.slots = [];\n    this.skins = [];\n    this.animations = [];\n};\nspine.SkeletonData.prototype = {\n    defaultSkin: null,\n    /** @return May be null. */\n    findBone: function (boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++) {\n            if (slots[i].name == slotName) return slot[i];\n        }\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSkin: function (skinName) {\n        var skins = this.skins;\n        for (var i = 0, n = skins.length; i < n; i++)\n            if (skins[i].name == skinName) return skins[i];\n        return null;\n    },\n    /** @return May be null. */\n    findAnimation: function (animationName) {\n        var animations = this.animations;\n        for (var i = 0, n = animations.length; i < n; i++)\n            if (animations[i].name == animationName) return animations[i];\n        return null;\n    }\n};\n\nspine.Skeleton = function (skeletonData) {\n    this.data = skeletonData;\n\n    this.bones = [];\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++) {\n        var boneData = skeletonData.bones[i];\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\n        this.bones.push(new spine.Bone(boneData, parent));\n    }\n\n    this.slots = [];\n    this.drawOrder = [];\n    for (i = 0, n = skeletonData.slots.length; i < n; i++) {\n        var slotData = skeletonData.slots[i];\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\n        var slot = new spine.Slot(slotData, this, bone);\n        this.slots.push(slot);\n        this.drawOrder.push(slot);\n    }\n};\nspine.Skeleton.prototype = {\n    x: 0, y: 0,\n    skin: null,\n    r: 1, g: 1, b: 1, a: 1,\n    time: 0,\n    flipX: false, flipY: false,\n    /** Updates the world transform for each bone. */\n    updateWorldTransform: function () {\n        var flipX = this.flipX;\n        var flipY = this.flipY;\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            bones[i].updateWorldTransform(flipX, flipY);\n    },\n    /** Sets the bones and slots to their setup pose values. */\n    setToSetupPose: function () {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    },\n    setBonesToSetupPose: function () {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n    },\n    setSlotsToSetupPose: function () {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            slots[i].setToSetupPose(i);\n    },\n    /** @return May return null. */\n    getRootBone: function () {\n        return this.bones.length ? this.bones[0] : null;\n    },\n    /** @return May be null. */\n    findBone: function (boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return slots[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    },\n    setSkinByName: function (skinName) {\n        var skin = this.data.findSkin(skinName);\n        if (!skin) throw \"Skin not found: \" + skinName;\n        this.setSkin(skin);\n    },\n    /** Sets the skin used to look up attachments not found in the {@link SkeletonData#getDefaultSkin() default skin}. Attachments\n     * from the new skin are attached if the corresponding attachment from the old skin was attached.\n     * @param newSkin May be null. */\n    setSkin: function (newSkin) {\n        if (this.skin && newSkin) newSkin._attachAll(this, this.skin);\n        this.skin = newSkin;\n    },\n    /** @return May be null. */\n    getAttachmentBySlotName: function (slotName, attachmentName) {\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\n    },\n    /** @return May be null. */\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName) {\n        if (this.skin) {\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    },\n    /** @param attachmentName May be null. */\n    setAttachment: function (slotName, attachmentName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.size; i < n; i++) {\n            var slot = slots[i];\n            if (slot.data.name == slotName) {\n                var attachment = null;\n                if (attachmentName) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (attachment == null) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw \"Slot not found: \" + slotName;\n    },\n    update: function (delta) {\n        time += delta;\n    }\n};\n\nspine.AttachmentType = {\n    region: 0\n};\n\nspine.RegionAttachment = function () {\n    this.offset = [];\n    this.offset.length = 8;\n    this.uvs = [];\n    this.uvs.length = 8;\n};\nspine.RegionAttachment.prototype = {\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    width: 0, height: 0,\n    rendererObject: null,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    setUVs: function (u, v, u2, v2, rotate) {\n        var uvs = this.uvs;\n        if (rotate) {\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v2;\n            uvs[4/*X3*/] = u;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v;\n            uvs[0/*X1*/] = u2;\n            uvs[1/*Y1*/] = v2;\n        } else {\n            uvs[0/*X1*/] = u;\n            uvs[1/*Y1*/] = v2;\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v;\n            uvs[4/*X3*/] = u2;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v2;\n        }\n    },\n    updateOffset: function () {\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\n        var localX2 = localX + this.regionWidth * regionScaleX;\n        var localY2 = localY + this.regionHeight * regionScaleY;\n        var radians = this.rotation * Math.PI / 180;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var localXCos = localX * cos + this.x;\n        var localXSin = localX * sin;\n        var localYCos = localY * cos + this.y;\n        var localYSin = localY * sin;\n        var localX2Cos = localX2 * cos + this.x;\n        var localX2Sin = localX2 * sin;\n        var localY2Cos = localY2 * cos + this.y;\n        var localY2Sin = localY2 * sin;\n        var offset = this.offset;\n        offset[0/*X1*/] = localXCos - localYSin;\n        offset[1/*Y1*/] = localYCos + localXSin;\n        offset[2/*X2*/] = localXCos - localY2Sin;\n        offset[3/*Y2*/] = localY2Cos + localXSin;\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\n        offset[6/*X4*/] = localX2Cos - localYSin;\n        offset[7/*Y4*/] = localYCos + localX2Sin;\n    },\n    computeVertices: function (x, y, bone, vertices) {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.m00;\n        var m01 = bone.m01;\n        var m10 = bone.m10;\n        var m11 = bone.m11;\n        var offset = this.offset;\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\n    }\n}\n\nspine.AnimationStateData = function (skeletonData) {\n    this.skeletonData = skeletonData;\n    this.animationToMixTime = {};\n};\nspine.AnimationStateData.prototype = {\n        defaultMix: 0,\n    setMixByName: function (fromName, toName, duration) {\n        var from = this.skeletonData.findAnimation(fromName);\n        if (!from) throw \"Animation not found: \" + fromName;\n        var to = this.skeletonData.findAnimation(toName);\n        if (!to) throw \"Animation not found: \" + toName;\n        this.setMix(from, to, duration);\n    },\n    setMix: function (from, to, duration) {\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\n    },\n    getMix: function (from, to) {\n        var time = this.animationToMixTime[from.name + \":\" + to.name];\n            return time ? time : this.defaultMix;\n    }\n};\n\nspine.AnimationState = function (stateData) {\n    this.data = stateData;\n    this.queue = [];\n};\nspine.AnimationState.prototype = {\n    current: null,\n    previous: null,\n    currentTime: 0,\n    previousTime: 0,\n    currentLoop: false,\n    previousLoop: false,\n    mixTime: 0,\n    mixDuration: 0,\n    update: function (delta) {\n        this.currentTime += delta;\n        this.previousTime += delta;\n        this.mixTime += delta;\n\n        if (this.queue.length > 0) {\n            var entry = this.queue[0];\n            if (this.currentTime >= entry.delay) {\n                this._setAnimation(entry.animation, entry.loop);\n                this.queue.shift();\n            }\n        }\n    },\n    apply: function (skeleton) {\n        if (!this.current) return;\n        if (this.previous) {\n            this.previous.apply(skeleton, this.previousTime, this.previousLoop);\n            var alpha = this.mixTime / this.mixDuration;\n            if (alpha >= 1) {\n                alpha = 1;\n                this.previous = null;\n            }\n            this.current.mix(skeleton, this.currentTime, this.currentLoop, alpha);\n        } else\n            this.current.apply(skeleton, this.currentTime, this.currentLoop);\n    },\n    clearAnimation: function () {\n        this.previous = null;\n        this.current = null;\n        this.queue.length = 0;\n    },\n    _setAnimation: function (animation, loop) {\n        this.previous = null;\n        if (animation && this.current) {\n            this.mixDuration = this.data.getMix(this.current, animation);\n            if (this.mixDuration > 0) {\n                this.mixTime = 0;\n                this.previous = this.current;\n                this.previousTime = this.currentTime;\n                this.previousLoop = this.currentLoop;\n            }\n        }\n        this.current = animation;\n        this.currentLoop = loop;\n        this.currentTime = 0;\n    },\n    /** @see #setAnimation(Animation, Boolean) */\n    setAnimationByName: function (animationName, loop) {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        this.setAnimation(animation, loop);\n    },\n    /** Set the current animation. Any queued animations are cleared and the current animation time is set to 0.\n     * @param animation May be null. */\n    setAnimation: function (animation, loop) {\n        this.queue.length = 0;\n        this._setAnimation(animation, loop);\n    },\n    /** @see #addAnimation(Animation, Boolean, Number) */\n    addAnimationByName: function (animationName, loop, delay) {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        this.addAnimation(animation, loop, delay);\n    },\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\n    addAnimation: function (animation, loop, delay) {\n        var entry = {};\n        entry.animation = animation;\n        entry.loop = loop;\n\n        if (!delay || delay <= 0) {\n            var previousAnimation = this.queue.length ? this.queue[this.queue.length - 1].animation : this.current;\n            if (previousAnimation != null)\n                delay = previousAnimation.duration - this.data.getMix(previousAnimation, animation) + (delay || 0);\n            else\n                delay = 0;\n        }\n        entry.delay = delay;\n\n        this.queue.push(entry);\n    },\n    /** Returns true if no animation is set or if the current time is greater than the animation duration, regardless of looping. */\n    isComplete: function () {\n        return !this.current || this.currentTime >= this.current.duration;\n    }\n};\n\nspine.SkeletonJson = function (attachmentLoader) {\n    this.attachmentLoader = attachmentLoader;\n};\nspine.SkeletonJson.prototype = {\n    scale: 1,\n    readSkeletonData: function (root) {\n        /*jshint -W069*/\n        var skeletonData = new spine.SkeletonData(),\n            boneData;\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++) {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"]) {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\n            boneData.scaleX = boneMap[\"scaleX\"] || 1;\n            boneData.scaleY = boneMap[\"scaleY\"] || 1;\n            skeletonData.bones.push(boneData);\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (i = 0, n = slots.length; i < n; i++) {\n            var slotMap = slots[i];\n            boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color) {\n                slotData.r = spine.SkeletonJson.toColor(color, 0);\n                slotData.g = spine.SkeletonJson.toColor(color, 1);\n                slotData.b = spine.SkeletonJson.toColor(color, 2);\n                slotData.a = spine.SkeletonJson.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins) {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap) {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry) {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);\n                    if (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations) {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function (skin, name, map) {\n        /*jshint -W069*/\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n\n        if (type == spine.AttachmentType.region) {\n            var attachment = new spine.RegionAttachment();\n            attachment.x = (map[\"x\"] || 0) * this.scale;\n            attachment.y = (map[\"y\"] || 0) * this.scale;\n            attachment.scaleX = map[\"scaleX\"] || 1;\n            attachment.scaleY = map[\"scaleY\"] || 1;\n            attachment.rotation = map[\"rotation\"] || 0;\n            attachment.width = (map[\"width\"] || 32) * this.scale;\n            attachment.height = (map[\"height\"] || 32) * this.scale;\n            attachment.updateOffset();\n\n            attachment.rendererObject = {};\n            attachment.rendererObject.name = name;\n            attachment.rendererObject.scale = {};\n            attachment.rendererObject.scale.x = attachment.scaleX;\n            attachment.rendererObject.scale.y = attachment.scaleY;\n            attachment.rendererObject.rotation = -attachment.rotation * Math.PI / 180;\n            return attachment;\n        }\n\n            throw \"Unknown attachment type: \" + type;\n    },\n\n    readAnimation: function (name, map, skeletonData) {\n        /*jshint -W069*/\n        var timelines = [];\n        var duration = 0;\n        var frameIndex, timeline, timelineName, valueMap, values,\n            i, n;\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones) {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (timelineName in boneMap) {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                values = boneMap[timelineName];\n                if (timelineName == \"rotate\") {\n                    timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    frameIndex = 0;\n                    for (i = 0, n = values.length; i < n; i++) {\n                        valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n                } else if (timelineName == \"translate\" || timelineName == \"scale\") {\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\")\n                        timeline = new spine.ScaleTimeline(values.length);\n                    else {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    frameIndex = 0;\n                    for (i = 0, n = values.length; i < n; i++) {\n                        valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n                } else\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n        var slots = map[\"slots\"];\n        for (var slotName in slots) {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (timelineName in slotMap) {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                values = slotMap[timelineName];\n                if (timelineName == \"color\") {\n                    timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    frameIndex = 0;\n                    for (i = 0, n = values.length; i < n; i++) {\n                        valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = spine.SkeletonJson.toColor(color, 0);\n                        var g = spine.SkeletonJson.toColor(color, 1);\n                        var b = spine.SkeletonJson.toColor(color, 2);\n                        var a = spine.SkeletonJson.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n                } else if (timelineName == \"attachment\") {\n                    timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    frameIndex = 0;\n                    for (i = 0, n = values.length; i < n; i++) {\n                        valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n                } else\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    }\n};\nspine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) {\n    /*jshint -W069*/\n    var curve = valueMap[\"curve\"];\n    if (!curve) return;\n    if (curve == \"stepped\")\n        timeline.curves.setStepped(frameIndex);\n    else if (curve instanceof Array)\n        timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n};\nspine.SkeletonJson.toColor = function (hexString, colorIndex) {\n    if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n    return parseInt(hexString.substring(colorIndex * 2, 2), 16) / 255;\n};\n\nspine.Atlas = function (atlasText, textureLoader) {\n    this.textureLoader = textureLoader;\n    this.pages = [];\n    this.regions = [];\n\n    var reader = new spine.AtlasReader(atlasText);\n    var tuple = [];\n    tuple.length = 4;\n    var page = null;\n    while (true) {\n        var line = reader.readLine();\n        if (line == null) break;\n        line = reader.trim(line);\n        if (!line.length)\n            page = null;\n        else if (!page) {\n            page = new spine.AtlasPage();\n            page.name = line;\n\n            page.format = spine.Atlas.Format[reader.readValue()];\n\n            reader.readTuple(tuple);\n            page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\n            page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\n\n            var direction = reader.readValue();\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\n            if (direction == \"x\")\n                page.uWrap = spine.Atlas.TextureWrap.repeat;\n            else if (direction == \"y\")\n                page.vWrap = spine.Atlas.TextureWrap.repeat;\n            else if (direction == \"xy\")\n                page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\n\n            textureLoader.load(page, line);\n\n            this.pages.push(page);\n\n        } else {\n            var region = new spine.AtlasRegion();\n            region.name = line;\n            region.page = page;\n\n            region.rotate = reader.readValue() == \"true\";\n\n            reader.readTuple(tuple);\n            var x = parseInt(tuple[0], 10);\n            var y = parseInt(tuple[1], 10);\n\n            reader.readTuple(tuple);\n            var width = parseInt(tuple[0], 10);\n            var height = parseInt(tuple[1], 10);\n\n            region.u = x / page.width;\n            region.v = y / page.height;\n            if (region.rotate) {\n                region.u2 = (x + height) / page.width;\n                region.v2 = (y + width) / page.height;\n            } else {\n                region.u2 = (x + width) / page.width;\n                region.v2 = (y + height) / page.height;\n            }\n            region.x = x;\n            region.y = y;\n            region.width = Math.abs(width);\n            region.height = Math.abs(height);\n\n            if (reader.readTuple(tuple) == 4) { // split is optional\n                region.splits = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)];\n\n                if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\n                    region.pads = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)];\n\n                    reader.readTuple(tuple);\n                }\n            }\n\n            region.originalWidth = parseInt(tuple[0], 10);\n            region.originalHeight = parseInt(tuple[1], 10);\n\n            reader.readTuple(tuple);\n            region.offsetX = parseInt(tuple[0], 10);\n            region.offsetY = parseInt(tuple[1], 10);\n\n            region.index = parseInt(reader.readValue(), 10);\n\n            this.regions.push(region);\n        }\n    }\n};\nspine.Atlas.prototype = {\n    findRegion: function (name) {\n        var regions = this.regions;\n        for (var i = 0, n = regions.length; i < n; i++)\n            if (regions[i].name == name) return regions[i];\n        return null;\n    },\n    dispose: function () {\n        var pages = this.pages;\n        for (var i = 0, n = pages.length; i < n; i++)\n            this.textureLoader.unload(pages[i].rendererObject);\n    },\n    updateUVs: function (page) {\n        var regions = this.regions;\n        for (var i = 0, n = regions.length; i < n; i++) {\n            var region = regions[i];\n            if (region.page != page) continue;\n            region.u = region.x / page.width;\n            region.v = region.y / page.height;\n            if (region.rotate) {\n                region.u2 = (region.x + region.height) / page.width;\n                region.v2 = (region.y + region.width) / page.height;\n            } else {\n                region.u2 = (region.x + region.width) / page.width;\n                region.v2 = (region.y + region.height) / page.height;\n            }\n        }\n    }\n};\n\nspine.Atlas.Format = {\n    alpha: 0,\n    intensity: 1,\n    luminanceAlpha: 2,\n    rgb565: 3,\n    rgba4444: 4,\n    rgb888: 5,\n    rgba8888: 6\n};\n\nspine.Atlas.TextureFilter = {\n    nearest: 0,\n    linear: 1,\n    mipMap: 2,\n    mipMapNearestNearest: 3,\n    mipMapLinearNearest: 4,\n    mipMapNearestLinear: 5,\n    mipMapLinearLinear: 6\n};\n\nspine.Atlas.TextureWrap = {\n    mirroredRepeat: 0,\n    clampToEdge: 1,\n    repeat: 2\n};\n\nspine.AtlasPage = function () {};\nspine.AtlasPage.prototype = {\n    name: null,\n    format: null,\n    minFilter: null,\n    magFilter: null,\n    uWrap: null,\n    vWrap: null,\n    rendererObject: null,\n    width: 0,\n    height: 0\n};\n\nspine.AtlasRegion = function () {};\nspine.AtlasRegion.prototype = {\n    page: null,\n    name: null,\n    x: 0, y: 0,\n    width: 0, height: 0,\n    u: 0, v: 0, u2: 0, v2: 0,\n    offsetX: 0, offsetY: 0,\n    originalWidth: 0, originalHeight: 0,\n    index: 0,\n    rotate: false,\n    splits: null,\n    pads: null,\n};\n\nspine.AtlasReader = function (text) {\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\n};\nspine.AtlasReader.prototype = {\n    index: 0,\n    trim: function (value) {\n        return value.replace(/^\\s+|\\s+$/g, \"\");\n    },\n    readLine: function () {\n        if (this.index >= this.lines.length) return null;\n        return this.lines[this.index++];\n    },\n    readValue: function () {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw \"Invalid line: \" + line;\n        return this.trim(line.substring(colon + 1));\n    },\n    /** Returns the number of tuple values read (2 or 4). */\n    readTuple: function (tuple) {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw \"Invalid line: \" + line;\n        var i = 0, lastMatch= colon + 1;\n        for (; i < 3; i++) {\n            var comma = line.indexOf(\",\", lastMatch);\n            if (comma == -1) {\n                if (!i) throw \"Invalid line: \" + line;\n                break;\n            }\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\n            lastMatch = comma + 1;\n        }\n        tuple[i] = this.trim(line.substring(lastMatch));\n        return i + 1;\n    }\n}\n\nspine.AtlasAttachmentLoader = function (atlas) {\n    this.atlas = atlas;\n}\nspine.AtlasAttachmentLoader.prototype = {\n    newAttachment: function (skin, type, name) {\n        switch (type) {\n        case spine.AttachmentType.region:\n            var region = this.atlas.findRegion(name);\n            if (!region) throw \"Region not found in atlas: \" + name + \" (\" + type + \")\";\n            var attachment = new spine.RegionAttachment(name);\n            attachment.rendererObject = region;\n            attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\n            attachment.regionOffsetX = region.offsetX;\n            attachment.regionOffsetY = region.offsetY;\n            attachment.regionWidth = region.width;\n            attachment.regionHeight = region.height;\n            attachment.regionOriginalWidth = region.originalWidth;\n            attachment.regionOriginalHeight = region.originalHeight;\n            return attachment;\n        }\n        throw \"Unknown attachment type: \" + type;\n    }\n}\n\nspine.Bone.yDown = true;\nPIXI.AnimCache = {};\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * Spine animation data needs to be loaded using the PIXI.AssetLoader or PIXI.SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * @class Spine\n * @extends DisplayObjectContainer\n * @constructor\n * @param url {String} The url of the spine anim file to be used\n */\nPIXI.Spine = function (url) {\n    PIXI.DisplayObjectContainer.call(this);\n\n    this.spineData = PIXI.AnimCache[url];\n\n    if (!this.spineData) {\n        throw new Error(\"Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: \" + url);\n    }\n\n    this.skeleton = new spine.Skeleton(this.spineData);\n    this.skeleton.updateWorldTransform();\n\n    this.stateData = new spine.AnimationStateData(this.spineData);\n    this.state = new spine.AnimationState(this.stateData);\n\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.drawOrder.length; i < n; i++) {\n        var slot = this.skeleton.drawOrder[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.DisplayObjectContainer();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n        if (!(attachment instanceof spine.RegionAttachment)) {\n            continue;\n        }\n        var spriteName = attachment.rendererObject.name;\n        var sprite = this.createSprite(slot, attachment.rendererObject);\n        slot.currentSprite = sprite;\n        slot.currentSpriteName = spriteName;\n        slotContainer.addChild(sprite);\n    }\n};\n\nPIXI.Spine.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.Spine.prototype.constructor = PIXI.Spine;\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.Spine.prototype.updateTransform = function () {\n    this.lastTime = this.lastTime || Date.now();\n    var timeDelta = (Date.now() - this.lastTime) * 0.001;\n    this.lastTime = Date.now();\n    this.state.update(timeDelta);\n    this.state.apply(this.skeleton);\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    for (var i = 0, n = drawOrder.length; i < n; i++) {\n        var slot = drawOrder[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n        if (!(attachment instanceof spine.RegionAttachment)) {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        if (attachment.rendererObject) {\n            if (!slot.currentSpriteName || slot.currentSpriteName != attachment.name) {\n                var spriteName = attachment.rendererObject.name;\n                if (slot.currentSprite !== undefined) {\n                    slot.currentSprite.visible = false;\n                }\n                slot.sprites = slot.sprites || {};\n                if (slot.sprites[spriteName] !== undefined) {\n                    slot.sprites[spriteName].visible = true;\n                } else {\n                    var sprite = this.createSprite(slot, attachment.rendererObject);\n                    slotContainer.addChild(sprite);\n                }\n                slot.currentSprite = slot.sprites[spriteName];\n                slot.currentSpriteName = spriteName;\n            }\n        }\n        slotContainer.visible = true;\n\n        var bone = slot.bone;\n\n        slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;\n        slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;\n        slotContainer.scale.x = bone.worldScaleX;\n        slotContainer.scale.y = bone.worldScaleY;\n\n        slotContainer.rotation = -(slot.bone.worldRotation * Math.PI / 180);\n    }\n\n    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);\n};\n\n\nPIXI.Spine.prototype.createSprite = function (slot, descriptor) {\n    var name = PIXI.TextureCache[descriptor.name] ? descriptor.name : descriptor.name + \".png\";\n    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(name));\n    sprite.scale = descriptor.scale;\n    sprite.rotation = descriptor.rotation;\n    sprite.anchor.x = sprite.anchor.y = 0.5;\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.BaseTextureCache = {};\nPIXI.texturesToUpdate = [];\nPIXI.texturesToDestroy = [];\n\nPIXI.BaseTextureCacheIdGenerator = 0;\n\n/**\n * A texture stores the information that represents an image. All textures have a base texture\n *\n * @class BaseTexture\n * @uses EventTarget\n * @constructor\n * @param source {String} the source object (image or canvas)\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n */\nPIXI.BaseTexture = function(source, scaleMode)\n{\n    PIXI.EventTarget.call( this );\n\n    /**\n     * [read-only] The width of the base texture set when the image has loaded\n     *\n     * @property width\n     * @type Number\n     * @readOnly\n     */\n    this.width = 100;\n\n    /**\n     * [read-only] The height of the base texture set when the image has loaded\n     *\n     * @property height\n     * @type Number\n     * @readOnly\n     */\n    this.height = 100;\n\n    /**\n     * The scale mode to apply when scaling this texture\n     * @property scaleMode\n     * @type PIXI.scaleModes\n     * @default PIXI.scaleModes.LINEAR\n     */\n    this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    /**\n     * [read-only] Describes if the base texture has loaded or not\n     *\n     * @property hasLoaded\n     * @type Boolean\n     * @readOnly\n     */\n    this.hasLoaded = false;\n\n    /**\n     * The source that is loaded to create the texture\n     *\n     * @property source\n     * @type Image\n     */\n    this.source = source;\n\n    if(!source)return;\n\n    if(this.source.complete || this.source.getContext)\n    {\n        this.hasLoaded = true;\n        this.width = this.source.width;\n        this.height = this.source.height;\n\n        PIXI.texturesToUpdate.push(this);\n    }\n    else\n    {\n\n        var scope = this;\n        this.source.onload = function() {\n\n            scope.hasLoaded = true;\n            scope.width = scope.source.width;\n            scope.height = scope.source.height;\n\n            // add it to somewhere...\n            PIXI.texturesToUpdate.push(scope);\n            scope.dispatchEvent( { type: 'loaded', content: scope } );\n        };\n    }\n\n    this.imageUrl = null;\n    this._powerOf2 = false;\n\n    //TODO will be used for futer pixi 1.5...\n    this.id = PIXI.BaseTextureCacheIdGenerator++;\n\n    // used for webGL\n    this._glTextures = [];\n\n};\n\nPIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;\n\n/**\n * Destroys this base texture\n *\n * @method destroy\n */\nPIXI.BaseTexture.prototype.destroy = function()\n{\n    if(this.imageUrl)\n    {\n        delete PIXI.BaseTextureCache[this.imageUrl];\n        this.imageUrl = null;\n        this.source.src = null;\n    }\n    this.source = null;\n    PIXI.texturesToDestroy.push(this);\n};\n\n/**\n * Changes the source image of the texture\n *\n * @method updateSourceImage\n * @param newSrc {String} the path of the image\n */\nPIXI.BaseTexture.prototype.updateSourceImage = function(newSrc)\n{\n    this.hasLoaded = false;\n    this.source.src = null;\n    this.source.src = newSrc;\n};\n\n/**\n * Helper function that returns a base texture based on an image url\n * If the image is not in the base texture cache it will be created and loaded\n *\n * @static\n * @method fromImage\n * @param imageUrl {String} The image url of the texture\n * @param crossorigin {Boolean} \n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n * @return BaseTexture\n */\nPIXI.BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode)\n{\n    var baseTexture = PIXI.BaseTextureCache[imageUrl];\n    crossorigin = !crossorigin;\n\n    if(!baseTexture)\n    {\n        // new Image() breaks tex loading in some versions of Chrome.\n        // See https://code.google.com/p/chromium/issues/detail?id=238071\n        var image = new Image();//document.createElement('img');\n        if (crossorigin)\n        {\n            image.crossOrigin = '';\n        }\n        image.src = imageUrl;\n        baseTexture = new PIXI.BaseTexture(image, scaleMode);\n        baseTexture.imageUrl = imageUrl;\n        PIXI.BaseTextureCache[imageUrl] = baseTexture;\n    }\n\n    return baseTexture;\n};\n\nPIXI.BaseTexture.fromCanvas = function(canvas, scaleMode)\n{\n    if(!canvas._pixiId)\n    {\n        canvas._pixiId = 'canvas_' + PIXI.TextureCacheIdGenerator++;\n    }\n\n    var baseTexture = PIXI.BaseTextureCache[canvas._pixiId];\n\n    if(!baseTexture)\n    {\n        baseTexture = new PIXI.BaseTexture(canvas, scaleMode);\n        PIXI.BaseTextureCache[canvas._pixiId] = baseTexture;\n    }\n\n    return baseTexture;\n};\n\n\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.TextureCache = {};\nPIXI.FrameCache = {};\n\nPIXI.TextureCacheIdGenerator = 0;\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. To do this use PIXI.Sprite. If no frame is provided then the whole image is used\n *\n * @class Texture\n * @uses EventTarget\n * @constructor\n * @param baseTexture {BaseTexture} The base texture source to create the texture from\n * @param frame {Rectangle} The rectangle frame of the texture to show\n */\nPIXI.Texture = function(baseTexture, frame)\n{\n    PIXI.EventTarget.call( this );\n\n    if(!frame)\n    {\n        this.noFrame = true;\n        frame = new PIXI.Rectangle(0,0,1,1);\n    }\n\n    if(baseTexture instanceof PIXI.Texture)\n        baseTexture = baseTexture.baseTexture;\n\n    /**\n     * The base texture of that this texture uses\n     *\n     * @property baseTexture\n     * @type BaseTexture\n     */\n    this.baseTexture = baseTexture;\n\n    /**\n     * The frame specifies the region of the base texture that this texture uses\n     *\n     * @property frame\n     * @type Rectangle\n     */\n    this.frame = frame;\n\n    /**\n     * The trim point\n     *\n     * @property trim\n     * @type Rectangle\n     */\n    this.trim = null;\n  \n    this.scope = this;\n\n    if(baseTexture.hasLoaded)\n    {\n        if(this.noFrame)frame = new PIXI.Rectangle(0,0, baseTexture.width, baseTexture.height);\n      \n        this.setFrame(frame);\n    }\n    else\n    {\n        var scope = this;\n        baseTexture.addEventListener('loaded', function(){ scope.onBaseTextureLoaded(); });\n    }\n};\n\nPIXI.Texture.prototype.constructor = PIXI.Texture;\n\n/**\n * Called when the base texture is loaded\n *\n * @method onBaseTextureLoaded\n * @param event\n * @private\n */\nPIXI.Texture.prototype.onBaseTextureLoaded = function()\n{\n    var baseTexture = this.baseTexture;\n    baseTexture.removeEventListener( 'loaded', this.onLoaded );\n\n    if(this.noFrame)this.frame = new PIXI.Rectangle(0,0, baseTexture.width, baseTexture.height);\n    \n    this.setFrame(this.frame);\n\n    this.scope.dispatchEvent( { type: 'update', content: this } );\n};\n\n/**\n * Destroys this texture\n *\n * @method destroy\n * @param destroyBase {Boolean} Whether to destroy the base texture as well\n */\nPIXI.Texture.prototype.destroy = function(destroyBase)\n{\n    if(destroyBase) this.baseTexture.destroy();\n};\n\n/**\n * Specifies the rectangle region of the baseTexture\n *\n * @method setFrame\n * @param frame {Rectangle} The frame of the texture to set it to\n */\nPIXI.Texture.prototype.setFrame = function(frame)\n{\n    this.frame = frame;\n    this.width = frame.width;\n    this.height = frame.height;\n\n    if(frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)\n    {\n        throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);\n    }\n\n    this.updateFrame = true;\n\n    PIXI.Texture.frameUpdates.push(this);\n\n\n    //this.dispatchEvent( { type: 'update', content: this } );\n};\n\nPIXI.Texture.prototype._updateWebGLuvs = function()\n{\n    if(!this._uvs)this._uvs = new PIXI.TextureUvs();\n\n    var frame = this.frame;\n    var tw = this.baseTexture.width;\n    var th = this.baseTexture.height;\n\n    this._uvs.x0 = frame.x / tw;\n    this._uvs.y0 = frame.y / th;\n\n    this._uvs.x1 = (frame.x + frame.width) / tw;\n    this._uvs.y1 = frame.y / th;\n\n    this._uvs.x2 = (frame.x + frame.width) / tw;\n    this._uvs.y2 = (frame.y + frame.height) / th;\n\n    this._uvs.x3 = frame.x / tw;\n    this._uvs.y3 = (frame.y + frame.height) / th;\n};\n\n/**\n * Helper function that returns a texture based on an image url\n * If the image is not in the texture cache it will be  created and loaded\n *\n * @static\n * @method fromImage\n * @param imageUrl {String} The image url of the texture\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n * @return Texture\n */\nPIXI.Texture.fromImage = function(imageUrl, crossorigin, scaleMode)\n{\n    var texture = PIXI.TextureCache[imageUrl];\n\n    if(!texture)\n    {\n        texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));\n        PIXI.TextureCache[imageUrl] = texture;\n    }\n\n    return texture;\n};\n\n/**\n * Helper function that returns a texture based on a frame id\n * If the frame id is not in the texture cache an error will be thrown\n *\n * @static\n * @method fromFrame\n * @param frameId {String} The frame id of the texture\n * @return Texture\n */\nPIXI.Texture.fromFrame = function(frameId)\n{\n    var texture = PIXI.TextureCache[frameId];\n    if(!texture) throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache ');\n    return texture;\n};\n\n/**\n * Helper function that returns a texture based on a canvas element\n * If the canvas is not in the texture cache it will be  created and loaded\n *\n * @static\n * @method fromCanvas\n * @param canvas {Canvas} The canvas element source of the texture\n * @return Texture\n */\nPIXI.Texture.fromCanvas = function(canvas, scaleMode)\n{\n    var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);\n\n    return new PIXI.Texture( baseTexture );\n\n};\n\n\n/**\n * Adds a texture to the textureCache.\n *\n * @static\n * @method addTextureToCache\n * @param texture {Texture}\n * @param id {String} the id that the texture will be stored against.\n */\nPIXI.Texture.addTextureToCache = function(texture, id)\n{\n    PIXI.TextureCache[id] = texture;\n};\n\n/**\n * Remove a texture from the textureCache.\n *\n * @static\n * @method removeTextureFromCache\n * @param id {String} the id of the texture to be removed\n * @return {Texture} the texture that was removed\n */\nPIXI.Texture.removeTextureFromCache = function(id)\n{\n    var texture = PIXI.TextureCache[id];\n    PIXI.TextureCache[id] = null;\n    return texture;\n};\n\n// this is more for webGL.. it contains updated frames..\nPIXI.Texture.frameUpdates = [];\n\nPIXI.TextureUvs = function()\n{\n    this.x0 = 0;\n    this.y0 = 0;\n\n    this.x1 = 0;\n    this.y1 = 0;\n\n    this.x2 = 0;\n    this.y2 = 0;\n\n    this.x3 = 0;\n    this.y4 = 0;\n\n\n};\n\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n A RenderTexture is a special texture that allows any pixi displayObject to be rendered to it.\n\n __Hint__: All DisplayObjects (exmpl. Sprites) that render on RenderTexture should be preloaded.\n Otherwise black rectangles will be drawn instead.\n\n RenderTexture takes snapshot of DisplayObject passed to render method. If DisplayObject is passed to render method, position and rotation of it will be ignored. For example:\n\n    var renderTexture = new PIXI.RenderTexture(800, 600);\n    var sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n    sprite.position.x = 800/2;\n    sprite.position.y = 600/2;\n    sprite.anchor.x = 0.5;\n    sprite.anchor.y = 0.5;\n    renderTexture.render(sprite);\n\n Sprite in this case will be rendered to 0,0 position. To render this sprite at center DisplayObjectContainer should be used:\n\n    var doc = new PIXI.DisplayObjectContainer();\n    doc.addChild(sprite);\n    renderTexture.render(doc);  // Renders to center of renderTexture\n\n * @class RenderTexture\n * @extends Texture\n * @constructor\n * @param width {Number} The width of the render texture\n * @param height {Number} The height of the render texture\n */\nPIXI.RenderTexture = function(width, height, renderer)\n{\n    PIXI.EventTarget.call( this );\n\n    /**\n     * The with of the render texture\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = width || 100;\n    /**\n     * The height of the render texture\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = height || 100;\n\n    /**\n     * The framing rectangle of the render texture\n     *\n     * @property frame\n     * @type Rectangle\n     */\n    this.frame = new PIXI.Rectangle(0, 0, this.width, this.height);\n\n    /**\n     * The base texture object that this texture uses\n     *\n     * @property baseTexture\n     * @type BaseTexture\n     */\n    this.baseTexture = new PIXI.BaseTexture();\n    this.baseTexture.width = this.width;\n    this.baseTexture.height = this.height;\n    this.baseTexture._glTextures = [];\n\n    this.baseTexture.hasLoaded = true;\n\n    // each render texture can only belong to one renderer at the moment if its webGL\n    this.renderer = renderer || PIXI.defaultRenderer;\n\n    if(this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        var gl = this.renderer.gl;\n\n        this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height);\n        this.baseTexture._glTextures[gl.id] =  this.textureBuffer.texture;\n\n        this.render = this.renderWebGL;\n        this.projection = new PIXI.Point(this.width/2 , -this.height/2);\n    }\n    else\n    {\n        this.render = this.renderCanvas;\n        this.textureBuffer = new PIXI.CanvasBuffer(this.width, this.height);\n        this.baseTexture.source = this.textureBuffer.canvas;\n    }\n\n    PIXI.Texture.frameUpdates.push(this);\n\n\n};\n\nPIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);\nPIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;\n\nPIXI.RenderTexture.prototype.resize = function(width, height)\n{\n    this.width = width;\n    this.height = height;\n\n    this.frame.width = this.width;\n    this.frame.height = this.height;\n\n    if(this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        this.projection.x = this.width / 2;\n        this.projection.y = -this.height / 2;\n\n        var gl = this.renderer.gl;\n        gl.bindTexture(gl.TEXTURE_2D, this.baseTexture._glTextures[gl.id]);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width,  this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    else\n    {\n        this.textureBuffer.resize(this.width, this.height);\n    }\n\n    PIXI.Texture.frameUpdates.push(this);\n};\n\n/**\n * This function will draw the display object to the texture.\n *\n * @method renderWebGL\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn\n * @private\n */\nPIXI.RenderTexture.prototype.renderWebGL = function(displayObject, position, clear)\n{\n    //TOOD replace position with matrix..\n    var gl = this.renderer.gl;\n\n    gl.colorMask(true, true, true, true);\n\n    gl.viewport(0, 0, this.width, this.height);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer );\n\n    if(clear)this.textureBuffer.clear();\n\n    // THIS WILL MESS WITH HIT TESTING!\n    var children = displayObject.children;\n\n    //TODO -? create a new one??? dont think so!\n    var originalWorldTransform = displayObject.worldTransform;\n    displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;\n    // modify to flip...\n    displayObject.worldTransform.d = -1;\n    displayObject.worldTransform.ty = this.projection.y * -2;\n\n    if(position)\n    {\n        displayObject.worldTransform.tx = position.x;\n        displayObject.worldTransform.ty -= position.y;\n    }\n\n    for(var i=0,j=children.length; i<j; i++)\n    {\n        children[i].updateTransform();\n    }\n\n    // update the textures!\n    PIXI.WebGLRenderer.updateTextures();\n\n    // \n    this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer);\n\n    displayObject.worldTransform = originalWorldTransform;\n};\n\n\n/**\n * This function will draw the display object to the texture.\n *\n * @method renderCanvas\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn\n * @private\n */\nPIXI.RenderTexture.prototype.renderCanvas = function(displayObject, position, clear)\n{\n    var children = displayObject.children;\n\n    displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;\n\n    if(position)\n    {\n        displayObject.worldTransform.tx = position.x;\n        displayObject.worldTransform.ty = position.y;\n    }\n\n    for(var i = 0, j = children.length; i < j; i++)\n    {\n        children[i].updateTransform();\n    }\n\n    if(clear)this.textureBuffer.clear();\n\n    var context = this.textureBuffer.context;\n\n    this.renderer.renderDisplayObject(displayObject, context);\n\n    context.setTransform(1,0,0,1,0,0);\n};\n\nPIXI.RenderTexture.tempMatrix = new PIXI.Matrix();\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Class that loads a bunch of images / sprite sheet / bitmap font files. Once the\n * assets have been loaded they are added to the PIXI Texture cache and can be accessed\n * easily through PIXI.Texture.fromImage() and PIXI.Sprite.fromImage()\n * When all items have been loaded this class will dispatch a 'onLoaded' event\n * As each individual item is loaded this class will dispatch a 'onProgress' event\n *\n * @class AssetLoader\n * @constructor\n * @uses EventTarget\n * @param {Array<String>} assetURLs an array of image/sprite sheet urls that you would like loaded\n *      supported. Supported image formats include 'jpeg', 'jpg', 'png', 'gif'. Supported\n *      sprite sheet data formats only include 'JSON' at this time. Supported bitmap font\n *      data formats include 'xml' and 'fnt'.\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.AssetLoader = function(assetURLs, crossorigin)\n{\n    PIXI.EventTarget.call(this);\n\n    /**\n     * The array of asset URLs that are going to be loaded\n     *\n     * @property assetURLs\n     * @type Array<String>\n     */\n    this.assetURLs = assetURLs;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * Maps file extension to loader types\n     *\n     * @property loadersByType\n     * @type Object\n     */\n    this.loadersByType = {\n        'jpg':  PIXI.ImageLoader,\n        'jpeg': PIXI.ImageLoader,\n        'png':  PIXI.ImageLoader,\n        'gif':  PIXI.ImageLoader,\n        'json': PIXI.JsonLoader,\n        'atlas': PIXI.AtlasLoader,\n        'anim': PIXI.SpineLoader,\n        'xml':  PIXI.BitmapFontLoader,\n        'fnt':  PIXI.BitmapFontLoader\n    };\n};\n\n/**\n * Fired when an item has loaded\n * @event onProgress\n */\n\n/**\n * Fired when all the assets have loaded\n * @event onComplete\n */\n\n// constructor\nPIXI.AssetLoader.prototype.constructor = PIXI.AssetLoader;\n\n/**\n * Given a filename, returns its extension, wil\n *\n * @method _getDataType\n * @param str {String} the name of the asset\n */\nPIXI.AssetLoader.prototype._getDataType = function(str)\n{\n    var test = 'data:';\n    //starts with 'data:'\n    var start = str.slice(0, test.length).toLowerCase();\n    if (start === test) {\n        var data = str.slice(test.length);\n\n        var sepIdx = data.indexOf(',');\n        if (sepIdx === -1) //malformed data URI scheme\n            return null;\n\n        //e.g. 'image/gif;base64' => 'image/gif'\n        var info = data.slice(0, sepIdx).split(';')[0];\n\n        //We might need to handle some special cases here...\n        //standardize text/plain to 'txt' file extension\n        if (!info || info.toLowerCase() === 'text/plain')\n            return 'txt';\n\n        //User specified mime type, try splitting it by '/'\n        return info.split('/').pop().toLowerCase();\n    }\n\n    return null;\n};\n\n/**\n * Starts loading the assets sequentially\n *\n * @method load\n */\nPIXI.AssetLoader.prototype.load = function()\n{\n    var scope = this;\n\n    function onLoad(evt) {\n        scope.onAssetLoaded(evt.loader);\n    }\n\n    this.loadCount = this.assetURLs.length;\n\n    for (var i=0; i < this.assetURLs.length; i++)\n    {\n        var fileName = this.assetURLs[i];\n        //first see if we have a data URI scheme..\n        var fileType = this._getDataType(fileName);\n\n        //if not, assume it's a file URI\n        if (!fileType)\n            fileType = fileName.split('?').shift().split('.').pop().toLowerCase();\n\n        var Constructor = this.loadersByType[fileType];\n        if(!Constructor)\n            throw new Error(fileType + ' is an unsupported file type');\n\n        var loader = new Constructor(fileName, this.crossorigin);\n\n        loader.addEventListener('loaded', onLoad);\n        loader.load();\n    }\n};\n\n/**\n * Invoked after each file is loaded\n *\n * @method onAssetLoaded\n * @private\n */\nPIXI.AssetLoader.prototype.onAssetLoaded = function(loader)\n{\n    this.loadCount--;\n    this.dispatchEvent({ type: 'onProgress', content: this, loader: loader });\n    if (this.onProgress) this.onProgress(loader);\n\n    if (!this.loadCount)\n    {\n        this.dispatchEvent({type: 'onComplete', content: this});\n        if(this.onComplete) this.onComplete();\n    }\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The json file loader is used to load in JSON data and parse it\n * When loaded this class will dispatch a 'loaded' event\n * If loading fails this class will dispatch an 'error' event\n *\n * @class JsonLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.JsonLoader = function (url, crossorigin) {\n    PIXI.EventTarget.call(this);\n\n    /**\n     * The url of the bitmap font data\n     *\n     * @property url\n     * @type String\n     */\n    this.url = url;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * [read-only] The base url of the bitmap font data\n     *\n     * @property baseUrl\n     * @type String\n     * @readOnly\n     */\n    this.baseUrl = url.replace(/[^\\/]*$/, '');\n\n    /**\n     * [read-only] Whether the data has loaded yet\n     *\n     * @property loaded\n     * @type Boolean\n     * @readOnly\n     */\n    this.loaded = false;\n\n};\n\n// constructor\nPIXI.JsonLoader.prototype.constructor = PIXI.JsonLoader;\n\n/**\n * Loads the JSON data\n *\n * @method load\n */\nPIXI.JsonLoader.prototype.load = function () {\n    this.ajaxRequest = new PIXI.AjaxRequest(this.crossorigin);\n    var scope = this;\n    this.ajaxRequest.onreadystatechange = function () {\n        scope.onJSONLoaded();\n    };\n\n    this.ajaxRequest.open('GET', this.url, true);\n    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/json');\n    this.ajaxRequest.send(null);\n};\n\n/**\n * Invoke when JSON file is loaded\n *\n * @method onJSONLoaded\n * @private\n */\nPIXI.JsonLoader.prototype.onJSONLoaded = function () {\n    if (this.ajaxRequest.readyState === 4) {\n        if (this.ajaxRequest.status === 200 || window.location.protocol.indexOf('http') === -1) {\n            this.json = JSON.parse(this.ajaxRequest.responseText);\n\n            if(this.json.frames)\n            {\n                // sprite sheet\n                var scope = this;\n                var textureUrl = this.baseUrl + this.json.meta.image;\n                var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);\n                var frameData = this.json.frames;\n\n                this.texture = image.texture.baseTexture;\n                image.addEventListener('loaded', function() {\n                    scope.onLoaded();\n                });\n\n                for (var i in frameData) {\n                    var rect = frameData[i].frame;\n                    if (rect) {\n                        PIXI.TextureCache[i] = new PIXI.Texture(this.texture, {\n                            x: rect.x,\n                            y: rect.y,\n                            width: rect.w,\n                            height: rect.h\n                        });\n\n                        // check to see ifthe sprite ha been trimmed..\n                        if (frameData[i].trimmed) {\n\n                            var texture =  PIXI.TextureCache[i];\n                            \n                            var actualSize = frameData[i].sourceSize;\n                            var realSize = frameData[i].spriteSourceSize;\n\n                            texture.trim = new PIXI.Rectangle(realSize.x, realSize.y, actualSize.w, actualSize.h);\n                        }\n                    }\n                }\n\n                image.load();\n\n            }\n            else if(this.json.bones)\n            {\n                // spine animation\n                var spineJsonParser = new spine.SkeletonJson();\n                var skeletonData = spineJsonParser.readSkeletonData(this.json);\n                PIXI.AnimCache[this.url] = skeletonData;\n                this.onLoaded();\n            }\n            else\n            {\n                this.onLoaded();\n            }\n        }\n        else\n        {\n            this.onError();\n        }\n    }\n};\n\n/**\n * Invoke when json file loaded\n *\n * @method onLoaded\n * @private\n */\nPIXI.JsonLoader.prototype.onLoaded = function () {\n    this.loaded = true;\n    this.dispatchEvent({\n        type: 'loaded',\n        content: this\n    });\n};\n\n/**\n * Invoke when error occured\n *\n * @method onError\n * @private\n */\nPIXI.JsonLoader.prototype.onError = function () {\n    this.dispatchEvent({\n        type: 'error',\n        content: this\n    });\n};\r\n/**\n * @author Martin Kelm http://mkelm.github.com\n */\n\n/**\n * The atlas file loader is used to load in Atlas data and parse it\n * When loaded this class will dispatch a 'loaded' event\n * If loading fails this class will dispatch an 'error' event\n * @class AtlasLoader\n * @extends EventTarget\n * @constructor\n * @param {String} url the url of the JSON file\n * @param {Boolean} crossorigin\n */\n\nPIXI.AtlasLoader = function (url, crossorigin) {\n    PIXI.EventTarget.call(this);\n    this.url = url;\n    this.baseUrl = url.replace(/[^\\/]*$/, '');\n    this.crossorigin = crossorigin;\n    this.loaded = false;\n\n};\n\n// constructor\nPIXI.AtlasLoader.constructor = PIXI.AtlasLoader;\n\n\n /**\n * Starts loading the JSON file\n *\n * @method load\n */\nPIXI.AtlasLoader.prototype.load = function () {\n    this.ajaxRequest = new PIXI.AjaxRequest();\n    this.ajaxRequest.onreadystatechange = this.onAtlasLoaded.bind(this);\n\n    this.ajaxRequest.open('GET', this.url, true);\n    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/json');\n    this.ajaxRequest.send(null);\n};\n\n/**\n * Invoke when JSON file is loaded\n * @method onAtlasLoaded\n * @private\n */\nPIXI.AtlasLoader.prototype.onAtlasLoaded = function () {\n    if (this.ajaxRequest.readyState === 4) {\n        if (this.ajaxRequest.status === 200 || window.location.href.indexOf('http') === -1) {\n            this.atlas = {\n                meta : {\n                    image : []\n                },\n                frames : []\n            };\n            var result = this.ajaxRequest.responseText.split(/\\r?\\n/);\n            var lineCount = -3;\n\n            var currentImageId = 0;\n            var currentFrame = null;\n            var nameInNextLine = false;\n\n            var i = 0,\n                j = 0,\n                selfOnLoaded = this.onLoaded.bind(this);\n\n            // parser without rotation support yet!\n            for (i = 0; i < result.length; i++) {\n                result[i] = result[i].replace(/^\\s+|\\s+$/g, '');\n                if (result[i] === '') {\n                    nameInNextLine = i+1;\n                }\n                if (result[i].length > 0) {\n                    if (nameInNextLine === i) {\n                        this.atlas.meta.image.push(result[i]);\n                        currentImageId = this.atlas.meta.image.length - 1;\n                        this.atlas.frames.push({});\n                        lineCount = -3;\n                    } else if (lineCount > 0) {\n                        if (lineCount % 7 === 1) { // frame name\n                            if (currentFrame != null) { //jshint ignore:line\n                                this.atlas.frames[currentImageId][currentFrame.name] = currentFrame;\n                            }\n                            currentFrame = { name: result[i], frame : {} };\n                        } else {\n                            var text = result[i].split(' ');\n                            if (lineCount % 7 === 3) { // position\n                                currentFrame.frame.x = Number(text[1].replace(',', ''));\n                                currentFrame.frame.y = Number(text[2]);\n                            } else if (lineCount % 7 === 4) { // size\n                                currentFrame.frame.w = Number(text[1].replace(',', ''));\n                                currentFrame.frame.h = Number(text[2]);\n                            } else if (lineCount % 7 === 5) { // real size\n                                var realSize = {\n                                    x : 0,\n                                    y : 0,\n                                    w : Number(text[1].replace(',', '')),\n                                    h : Number(text[2])\n                                };\n\n                                if (realSize.w > currentFrame.frame.w || realSize.h > currentFrame.frame.h) {\n                                    currentFrame.trimmed = true;\n                                    currentFrame.realSize = realSize;\n                                } else {\n                                    currentFrame.trimmed = false;\n                                }\n                            }\n                        }\n                    }\n                    lineCount++;\n                }\n            }\n\n            if (currentFrame != null) { //jshint ignore:line\n                this.atlas.frames[currentImageId][currentFrame.name] = currentFrame;\n            }\n\n            if (this.atlas.meta.image.length > 0) {\n                this.images = [];\n                for (j = 0; j < this.atlas.meta.image.length; j++) {\n                    // sprite sheet\n                    var textureUrl = this.baseUrl + this.atlas.meta.image[j];\n                    var frameData = this.atlas.frames[j];\n                    this.images.push(new PIXI.ImageLoader(textureUrl, this.crossorigin));\n\n                    for (i in frameData) {\n                        var rect = frameData[i].frame;\n                        if (rect) {\n                            PIXI.TextureCache[i] = new PIXI.Texture(this.images[j].texture.baseTexture, {\n                                x: rect.x,\n                                y: rect.y,\n                                width: rect.w,\n                                height: rect.h\n                            });\n                            if (frameData[i].trimmed) {\n                                PIXI.TextureCache[i].realSize = frameData[i].realSize;\n                                // trim in pixi not supported yet, todo update trim properties if it is done ...\n                                PIXI.TextureCache[i].trim.x = 0;\n                                PIXI.TextureCache[i].trim.y = 0;\n                            }\n                        }\n                    }\n                }\n\n                this.currentImageId = 0;\n                for (j = 0; j < this.images.length; j++) {\n                    this.images[j].addEventListener('loaded', selfOnLoaded);\n                }\n                this.images[this.currentImageId].load();\n\n            } else {\n                this.onLoaded();\n            }\n\n        } else {\n            this.onError();\n        }\n    }\n};\n\n/**\n * Invoke when json file has loaded\n * @method onLoaded\n * @private\n */\nPIXI.AtlasLoader.prototype.onLoaded = function () {\n    if (this.images.length - 1 > this.currentImageId) {\n        this.currentImageId++;\n        this.images[this.currentImageId].load();\n    } else {\n        this.loaded = true;\n        this.dispatchEvent({\n            type: 'loaded',\n            content: this\n        });\n    }\n};\n\n/**\n * Invoke when error occured\n * @method onError\n * @private\n */\nPIXI.AtlasLoader.prototype.onError = function () {\n    this.dispatchEvent({\n        type: 'error',\n        content: this\n    });\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The sprite sheet loader is used to load in JSON sprite sheet data\n * To generate the data you can use http://www.codeandweb.com/texturepacker and publish in the 'JSON' format\n * There is a free version so thats nice, although the paid version is great value for money.\n * It is highly recommended to use Sprite sheets (also know as a 'texture atlas') as it means sprites can be batched and drawn together for highly increased rendering speed.\n * Once the data has been loaded the frames are stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFrameId()\n * This loader will load the image file that the Spritesheet points to as well as the data.\n * When loaded this class will dispatch a 'loaded' event\n *\n * @class SpriteSheetLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the sprite sheet JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.SpriteSheetLoader = function (url, crossorigin) {\n    /*\n     * i use texture packer to load the assets..\n     * http://www.codeandweb.com/texturepacker\n     * make sure to set the format as 'JSON'\n     */\n    PIXI.EventTarget.call(this);\n\n    /**\n     * The url of the bitmap font data\n     *\n     * @property url\n     * @type String\n     */\n    this.url = url;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * [read-only] The base url of the bitmap font data\n     *\n     * @property baseUrl\n     * @type String\n     * @readOnly\n     */\n    this.baseUrl = url.replace(/[^\\/]*$/, '');\n\n    /**\n     * The texture being loaded\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = null;\n\n    /**\n     * The frames of the sprite sheet\n     *\n     * @property frames\n     * @type Object\n     */\n    this.frames = {};\n};\n\n// constructor\nPIXI.SpriteSheetLoader.prototype.constructor = PIXI.SpriteSheetLoader;\n\n/**\n * This will begin loading the JSON file\n *\n * @method load\n */\nPIXI.SpriteSheetLoader.prototype.load = function () {\n    var scope = this;\n    var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);\n    jsonLoader.addEventListener('loaded', function (event) {\n        scope.json = event.content.json;\n        scope.onLoaded();\n    });\n    jsonLoader.load();\n};\n\n/**\n * Invoke when all files are loaded (json and texture)\n *\n * @method onLoaded\n * @private\n */\nPIXI.SpriteSheetLoader.prototype.onLoaded = function () {\n    this.dispatchEvent({\n        type: 'loaded',\n        content: this\n    });\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The image loader class is responsible for loading images file formats ('jpeg', 'jpg', 'png' and 'gif')\n * Once the image has been loaded it is stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFrameId()\n * When loaded this class will dispatch a 'loaded' event\n *\n * @class ImageLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the image\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.ImageLoader = function(url, crossorigin)\n{\n    PIXI.EventTarget.call(this);\n\n    /**\n     * The texture being loaded\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = PIXI.Texture.fromImage(url, crossorigin);\n\n    /**\n     * if the image is loaded with loadFramedSpriteSheet\n     * frames will contain the sprite sheet frames\n     *\n     */\n    this.frames = [];\n};\n\n// constructor\nPIXI.ImageLoader.prototype.constructor = PIXI.ImageLoader;\n\n/**\n * Loads image or takes it from cache\n *\n * @method load\n */\nPIXI.ImageLoader.prototype.load = function()\n{\n    if(!this.texture.baseTexture.hasLoaded)\n    {\n        var scope = this;\n        this.texture.baseTexture.addEventListener('loaded', function()\n        {\n            scope.onLoaded();\n        });\n    }\n    else\n    {\n        this.onLoaded();\n    }\n};\n\n/**\n * Invoked when image file is loaded or it is already cached and ready to use\n *\n * @method onLoaded\n * @private\n */\nPIXI.ImageLoader.prototype.onLoaded = function()\n{\n    this.dispatchEvent({type: 'loaded', content: this});\n};\n\n/**\n * Loads image and split it to uniform sized frames\n *\n *\n * @method loadFramedSpriteSheet\n * @param frameWidth {Number} width of each frame\n * @param frameHeight {Number} height of each frame\n * @param textureName {String} if given, the frames will be cached in <textureName>-<ord> format\n */\nPIXI.ImageLoader.prototype.loadFramedSpriteSheet = function(frameWidth, frameHeight, textureName)\n{\n    this.frames = [];\n    var cols = Math.floor(this.texture.width / frameWidth);\n    var rows = Math.floor(this.texture.height / frameHeight);\n\n    var i=0;\n    for (var y=0; y<rows; y++)\n    {\n        for (var x=0; x<cols; x++,i++)\n        {\n            var texture = new PIXI.Texture(this.texture, {\n                x: x*frameWidth,\n                y: y*frameHeight,\n                width: frameWidth,\n                height: frameHeight\n            });\n\n            this.frames.push(texture);\n            if (textureName) PIXI.TextureCache[textureName + '-' + i] = texture;\n        }\n    }\n\n    if(!this.texture.baseTexture.hasLoaded)\n    {\n        var scope = this;\n        this.texture.baseTexture.addEventListener('loaded', function() {\n            scope.onLoaded();\n        });\n    }\n    else\n    {\n        this.onLoaded();\n    }\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The xml loader is used to load in XML bitmap font data ('xml' or 'fnt')\n * To generate the data you can use http://www.angelcode.com/products/bmfont/\n * This loader will also load the image file as the data.\n * When loaded this class will dispatch a 'loaded' event\n *\n * @class BitmapFontLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the sprite sheet JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.BitmapFontLoader = function(url, crossorigin)\n{\n    /*\n     * I use texture packer to load the assets..\n     * http://www.codeandweb.com/texturepacker\n     * make sure to set the format as 'JSON'\n     */\n    PIXI.EventTarget.call(this);\n\n    /**\n     * The url of the bitmap font data\n     *\n     * @property url\n     * @type String\n     */\n    this.url = url;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * [read-only] The base url of the bitmap font data\n     *\n     * @property baseUrl\n     * @type String\n     * @readOnly\n     */\n    this.baseUrl = url.replace(/[^\\/]*$/, '');\n\n    /**\n     * [read-only] The texture of the bitmap font\n     *\n     * @property baseUrl\n     * @type String\n     */\n    this.texture = null;\n};\n\n// constructor\nPIXI.BitmapFontLoader.prototype.constructor = PIXI.BitmapFontLoader;\n\n/**\n * Loads the XML font data\n *\n * @method load\n */\nPIXI.BitmapFontLoader.prototype.load = function()\n{\n    this.ajaxRequest = new PIXI.AjaxRequest();\n    var scope = this;\n    this.ajaxRequest.onreadystatechange = function()\n    {\n        scope.onXMLLoaded();\n    };\n\n    this.ajaxRequest.open('GET', this.url, true);\n    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/xml');\n    this.ajaxRequest.send(null);\n};\n\n/**\n * Invoked when the XML file is loaded, parses the data\n *\n * @method onXMLLoaded\n * @private\n */\nPIXI.BitmapFontLoader.prototype.onXMLLoaded = function()\n{\n    if (this.ajaxRequest.readyState === 4)\n    {\n        if (this.ajaxRequest.status === 200 || window.location.protocol.indexOf('http') === -1)\n        {\n            var responseXML = this.ajaxRequest.responseXML;\n            if(!responseXML || /MSIE 9/i.test(navigator.userAgent) || navigator.isCocoonJS) {\n                if(typeof(window.DOMParser) === 'function') {\n                    var domparser = new DOMParser();\n                    responseXML = domparser.parseFromString(this.ajaxRequest.responseText, 'text/xml');\n                } else {\n                    var div = document.createElement('div');\n                    div.innerHTML = this.ajaxRequest.responseText;\n                    responseXML = div;\n                }\n            }\n\n            var textureUrl = this.baseUrl + responseXML.getElementsByTagName('page')[0].getAttribute('file');\n            var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);\n            this.texture = image.texture.baseTexture;\n\n            var data = {};\n            var info = responseXML.getElementsByTagName('info')[0];\n            var common = responseXML.getElementsByTagName('common')[0];\n            data.font = info.getAttribute('face');\n            data.size = parseInt(info.getAttribute('size'), 10);\n            data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n            data.chars = {};\n\n            //parse letters\n            var letters = responseXML.getElementsByTagName('char');\n\n            for (var i = 0; i < letters.length; i++)\n            {\n                var charCode = parseInt(letters[i].getAttribute('id'), 10);\n\n                var textureRect = new PIXI.Rectangle(\n                    parseInt(letters[i].getAttribute('x'), 10),\n                    parseInt(letters[i].getAttribute('y'), 10),\n                    parseInt(letters[i].getAttribute('width'), 10),\n                    parseInt(letters[i].getAttribute('height'), 10)\n                );\n\n                data.chars[charCode] = {\n                    xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),\n                    yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),\n                    xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),\n                    kerning: {},\n                    texture: PIXI.TextureCache[charCode] = new PIXI.Texture(this.texture, textureRect)\n\n                };\n            }\n\n            //parse kernings\n            var kernings = responseXML.getElementsByTagName('kerning');\n            for (i = 0; i < kernings.length; i++)\n            {\n                var first = parseInt(kernings[i].getAttribute('first'), 10);\n                var second = parseInt(kernings[i].getAttribute('second'), 10);\n                var amount = parseInt(kernings[i].getAttribute('amount'), 10);\n\n                data.chars[second].kerning[first] = amount;\n\n            }\n\n            PIXI.BitmapText.fonts[data.font] = data;\n\n            var scope = this;\n            image.addEventListener('loaded', function() {\n                scope.onLoaded();\n            });\n            image.load();\n        }\n    }\n};\n\n/**\n * Invoked when all files are loaded (xml/fnt and texture)\n *\n * @method onLoaded\n * @private\n */\nPIXI.BitmapFontLoader.prototype.onLoaded = function()\n{\n    this.dispatchEvent({type: 'loaded', content: this});\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi\n *\n * Awesome JS run time provided by EsotericSoftware\n * https://github.com/EsotericSoftware/spine-runtimes\n *\n */\n\n/**\n * The Spine loader is used to load in JSON spine data\n * To generate the data you need to use http://esotericsoftware.com/ and export in the \"JSON\" format\n * Due to a clash of names  You will need to change the extension of the spine file from *.json to *.anim for it to load\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n * You will need to generate a sprite sheet to accompany the spine data\n * When loaded this class will dispatch a \"loaded\" event\n *\n * @class Spine\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.SpineLoader = function(url, crossorigin)\n{\n    PIXI.EventTarget.call(this);\n\n    /**\n     * The url of the bitmap font data\n     *\n     * @property url\n     * @type String\n     */\n    this.url = url;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * [read-only] Whether the data has loaded yet\n     *\n     * @property loaded\n     * @type Boolean\n     * @readOnly\n     */\n    this.loaded = false;\n};\n\nPIXI.SpineLoader.prototype.constructor = PIXI.SpineLoader;\n\n/**\n * Loads the JSON data\n *\n * @method load\n */\nPIXI.SpineLoader.prototype.load = function () {\n\n    var scope = this;\n    var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);\n    jsonLoader.addEventListener(\"loaded\", function (event) {\n        scope.json = event.content.json;\n        scope.onLoaded();\n    });\n    jsonLoader.load();\n};\n\n/**\n * Invoke when JSON file is loaded\n *\n * @method onLoaded\n * @private\n */\nPIXI.SpineLoader.prototype.onLoaded = function () {\n    this.loaded = true;\n    this.dispatchEvent({type: \"loaded\", content: this});\n};\n\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This is the base class for creating a pixi.js filter. Currently only webGL supports filters.\n * If you want to make a custom filter this should be your base class.\n * @class AbstractFilter\n * @constructor\n * @param fragmentSrc\n * @param uniforms\n */\nPIXI.AbstractFilter = function(fragmentSrc, uniforms)\n{\n    /**\n    * An array of passes - some filters contain a few steps this array simply stores the steps in a liniear fashion.\n    * For example the blur filter has two passes blurX and blurY.\n    * @property passes\n    * @type Array an array of filter objects\n    * @private\n    */\n    this.passes = [this];\n\n    /**\n    * @property shaders\n    * @type Array an array of shaders\n    * @private\n    */\n    this.shaders = [];\n    \n    this.dirty = true;\n    this.padding = 0;\n\n    /**\n    * @property uniforms\n    * @type object\n    * @private\n    */\n    this.uniforms = uniforms || {};\n    /**\n    * @property fragmentSrc\n    * @type Array\n    * @private\n    */\n    this.fragmentSrc = fragmentSrc || [];\n};\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n *\n * The AlphaMaskFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.\n * You can use this filter to apply all manor of crazy warping effects\n * Currently the r property of the texture is used to offset the x and the g propery of the texture is used to offset the y.\n * @class AlphaMaskFilter\n * @contructor\n * @param texture {Texture} The texture used for the displacemtent map * must be power of 2 texture at the moment\n */\nPIXI.AlphaMaskFilter = function(texture)\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n    texture.baseTexture._powerOf2 = true;\n\n    // set the uniforms\n    this.uniforms = {\n        mask: {type: 'sampler2D', value:texture},\n        mapDimensions:   {type: '2f', value:{x:1, y:5112}},\n        dimensions:   {type: '4fv', value:[0,0,0,0]}\n    };\n\n    if(texture.baseTexture.hasLoaded)\n    {\n        this.uniforms.mask.value.x = texture.width;\n        this.uniforms.mask.value.y = texture.height;\n    }\n    else\n    {\n        this.boundLoadedFunction = this.onTextureLoaded.bind(this);\n\n        texture.baseTexture.on('loaded', this.boundLoadedFunction);\n    }\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D mask;',\n        'uniform sampler2D uSampler;',\n        'uniform vec2 offset;',\n        'uniform vec4 dimensions;',\n        'uniform vec2 mapDimensions;',\n\n        'void main(void) {',\n        '   vec2 mapCords = vTextureCoord.xy;',\n        '   mapCords += (dimensions.zw + offset)/ dimensions.xy ;',\n        '   mapCords.y *= -1.0;',\n        '   mapCords.y += 1.0;',\n        '   mapCords *= dimensions.xy / mapDimensions;',\n\n        '   vec4 original =  texture2D(uSampler, vTextureCoord);',\n        '   float maskAlpha =  texture2D(mask, mapCords).r;',\n        '   original *= maskAlpha;',\n        //'   original.rgb *= maskAlpha;',\n        '   gl_FragColor =  original;',\n        //'   gl_FragColor = gl_FragColor;',\n        '}'\n    ];\n};\n\nPIXI.AlphaMaskFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.AlphaMaskFilter.prototype.constructor = PIXI.AlphaMaskFilter;\n\nPIXI.AlphaMaskFilter.prototype.onTextureLoaded = function()\n{\n    this.uniforms.mapDimensions.value.x = this.uniforms.mask.value.width;\n    this.uniforms.mapDimensions.value.y = this.uniforms.mask.value.height;\n\n    this.uniforms.mask.value.baseTexture.off('loaded', this.boundLoadedFunction);\n};\n\n/**\n * The texture used for the displacemtent map * must be power of 2 texture at the moment\n *\n * @property map\n * @type Texture\n */\nObject.defineProperty(PIXI.AlphaMaskFilter.prototype, 'map', {\n    get: function() {\n        return this.uniforms.mask.value;\n    },\n    set: function(value) {\n        this.uniforms.mask.value = value;\n    }\n});\n\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n *\n * The ColorMatrixFilter class lets you apply a 4x4 matrix transformation on the RGBA\n * color and alpha values of every pixel on your displayObject to produce a result\n * with a new set of RGBA color and alpha values. Its pretty powerful!\n * @class ColorMatrixFilter\n * @contructor\n */\nPIXI.ColorMatrixFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        matrix: {type: 'mat4', value: [1,0,0,0,\n                                       0,1,0,0,\n                                       0,0,1,0,\n                                       0,0,0,1]},\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float invert;',\n        'uniform mat4 matrix;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * matrix;',\n      //  '   gl_FragColor = gl_FragColor;',\n        '}'\n    ];\n};\n\nPIXI.ColorMatrixFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.ColorMatrixFilter.prototype.constructor = PIXI.ColorMatrixFilter;\n\n/**\n * Sets the matrix of the color matrix filter\n *\n * @property matrix\n * @type Array and array of 26 numbers\n * @default [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]\n */\nObject.defineProperty(PIXI.ColorMatrixFilter.prototype, 'matrix', {\n    get: function() {\n        return this.uniforms.matrix.value;\n    },\n    set: function(value) {\n        this.uniforms.matrix.value = value;\n    }\n});\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n *\n * This turns your displayObjects to black and white.\n * @class GrayFilter\n * @contructor\n */\nPIXI.GrayFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        gray: {type: '1f', value: 1},\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D uSampler;',\n        'uniform float gray;',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',\n        '   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);',\n     //   '   gl_FragColor = gl_FragColor;',\n        '}'\n    ];\n};\n\nPIXI.GrayFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.GrayFilter.prototype.constructor = PIXI.GrayFilter;\n\n/**\nThe strength of the gray. 1 will make the object black and white, 0 will make the object its normal color\n@property gray\n*/\nObject.defineProperty(PIXI.GrayFilter.prototype, 'gray', {\n    get: function() {\n        return this.uniforms.gray.value;\n    },\n    set: function(value) {\n        this.uniforms.gray.value = value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n *\n * The DisplacementFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.\n * You can use this filter to apply all manor of crazy warping effects\n * Currently the r property of the texture is used offset the x and the g propery of the texture is used to offset the y.\n * @class DisplacementFilter\n * @contructor\n * @param texture {Texture} The texture used for the displacemtent map * must be power of 2 texture at the moment\n */\nPIXI.DisplacementFilter = function(texture)\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n    texture.baseTexture._powerOf2 = true;\n\n    // set the uniforms\n    this.uniforms = {\n        displacementMap: {type: 'sampler2D', value:texture},\n        scale:           {type: '2f', value:{x:30, y:30}},\n        offset:          {type: '2f', value:{x:0, y:0}},\n        mapDimensions:   {type: '2f', value:{x:1, y:5112}},\n        dimensions:   {type: '4fv', value:[0,0,0,0]}\n    };\n\n    if(texture.baseTexture.hasLoaded)\n    {\n        this.uniforms.mapDimensions.value.x = texture.width;\n        this.uniforms.mapDimensions.value.y = texture.height;\n    }\n    else\n    {\n        this.boundLoadedFunction = this.onTextureLoaded.bind(this);\n\n        texture.baseTexture.on('loaded', this.boundLoadedFunction);\n    }\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D displacementMap;',\n        'uniform sampler2D uSampler;',\n        'uniform vec2 scale;',\n        'uniform vec2 offset;',\n        'uniform vec4 dimensions;',\n        'uniform vec2 mapDimensions;',// = vec2(256.0, 256.0);',\n        // 'const vec2 textureDimensions = vec2(750.0, 750.0);',\n\n        'void main(void) {',\n        '   vec2 mapCords = vTextureCoord.xy;',\n        //'   mapCords -= ;',\n        '   mapCords += (dimensions.zw + offset)/ dimensions.xy ;',\n        '   mapCords.y *= -1.0;',\n        '   mapCords.y += 1.0;',\n        '   vec2 matSample = texture2D(displacementMap, mapCords).xy;',\n        '   matSample -= 0.5;',\n        '   matSample *= scale;',\n        '   matSample /= mapDimensions;',\n        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + matSample.x, vTextureCoord.y + matSample.y));',\n        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb, 1.0);',\n        '   vec2 cord = vTextureCoord;',\n\n        //'   gl_FragColor =  texture2D(displacementMap, cord);',\n     //   '   gl_FragColor = gl_FragColor;',\n        '}'\n    ];\n};\n\nPIXI.DisplacementFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.DisplacementFilter.prototype.constructor = PIXI.DisplacementFilter;\n\nPIXI.DisplacementFilter.prototype.onTextureLoaded = function()\n{\n    this.uniforms.mapDimensions.value.x = this.uniforms.displacementMap.value.width;\n    this.uniforms.mapDimensions.value.y = this.uniforms.displacementMap.value.height;\n\n    this.uniforms.displacementMap.value.baseTexture.off('loaded', this.boundLoadedFunction);\n};\n\n/**\n * The texture used for the displacemtent map * must be power of 2 texture at the moment\n *\n * @property map\n * @type Texture\n */\nObject.defineProperty(PIXI.DisplacementFilter.prototype, 'map', {\n    get: function() {\n        return this.uniforms.displacementMap.value;\n    },\n    set: function(value) {\n        this.uniforms.displacementMap.value = value;\n    }\n});\n\n/**\n * The multiplier used to scale the displacement result from the map calculation.\n *\n * @property scale\n * @type Point\n */\nObject.defineProperty(PIXI.DisplacementFilter.prototype, 'scale', {\n    get: function() {\n        return this.uniforms.scale.value;\n    },\n    set: function(value) {\n        this.uniforms.scale.value = value;\n    }\n});\n\n/**\n * The offset used to move the displacement map.\n *\n * @property offset\n * @type Point\n */\nObject.defineProperty(PIXI.DisplacementFilter.prototype, 'offset', {\n    get: function() {\n        return this.uniforms.offset.value;\n    },\n    set: function(value) {\n        this.uniforms.offset.value = value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n *\n * This filter applies a pixelate effect making display objects appear 'blocky'\n * @class PixelateFilter\n * @contructor\n */\nPIXI.PixelateFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        invert: {type: '1f', value: 0},\n        dimensions: {type: '4fv', value:new Float32Array([10000, 100, 10, 10])},\n        pixelSize: {type: '2f', value:{x:10, y:10}},\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform vec2 testDim;',\n        'uniform vec4 dimensions;',\n        'uniform vec2 pixelSize;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   vec2 coord = vTextureCoord;',\n\n        '   vec2 size = dimensions.xy/pixelSize;',\n\n        '   vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;',\n        '   gl_FragColor = texture2D(uSampler, color);',\n        '}'\n    ];\n};\n\nPIXI.PixelateFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.PixelateFilter.prototype.constructor = PIXI.PixelateFilter;\n\n/**\n *\n * This a point that describes the size of the blocs. x is the width of the block and y is the the height\n * @property size\n * @type Point\n */\nObject.defineProperty(PIXI.PixelateFilter.prototype, 'size', {\n    get: function() {\n        return this.uniforms.pixelSize.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.pixelSize.value = value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.BlurXFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        blur: {type: '1f', value: 1/512},\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float blur;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   vec4 sum = vec4(0.0);',\n\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;',\n\n        '   gl_FragColor = sum;',\n        '}'\n    ];\n};\n\nPIXI.BlurXFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.BlurXFilter.prototype.constructor = PIXI.BlurXFilter;\n\nObject.defineProperty(PIXI.BlurXFilter.prototype, 'blur', {\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n    set: function(value) {\n\n        this.dirty = true;\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.BlurYFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        blur: {type: '1f', value: 1/512},\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float blur;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   vec4 sum = vec4(0.0);',\n\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;',\n\n        '   gl_FragColor = sum;',\n        '}'\n    ];\n};\n\nPIXI.BlurYFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.BlurYFilter.prototype.constructor = PIXI.BlurYFilter;\n\nObject.defineProperty(PIXI.BlurYFilter.prototype, 'blur', {\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n    set: function(value) {\n        //this.padding = value;\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n *\n * The BlurFilter applies a Gaussian blur to an object.\n * The strength of the blur can be set for x- and y-axis separately (always relative to the stage).\n *\n * @class BlurFilter\n * @contructor\n */\nPIXI.BlurFilter = function()\n{\n    this.blurXFilter = new PIXI.BlurXFilter();\n    this.blurYFilter = new PIXI.BlurYFilter();\n\n    this.passes =[this.blurXFilter, this.blurYFilter];\n};\n\n/**\n * Sets the strength of both the blurX and blurY properties simultaneously\n *\n * @property blur\n * @type Number the strength of the blur\n * @default 2\n */\nObject.defineProperty(PIXI.BlurFilter.prototype, 'blur', {\n    get: function() {\n        return this.blurXFilter.blur;\n    },\n    set: function(value) {\n        this.blurXFilter.blur = this.blurYFilter.blur = value;\n    }\n});\n\n/**\n * Sets the strength of the blurX property\n *\n * @property blurX\n * @type Number the strength of the blurX\n * @default 2\n */\nObject.defineProperty(PIXI.BlurFilter.prototype, 'blurX', {\n    get: function() {\n        return this.blurXFilter.blur;\n    },\n    set: function(value) {\n        this.blurXFilter.blur = value;\n    }\n});\n\n/**\n * Sets the strength of the blurX property\n *\n * @property blurY\n * @type Number the strength of the blurY\n * @default 2\n */\nObject.defineProperty(PIXI.BlurFilter.prototype, 'blurY', {\n    get: function() {\n        return this.blurYFilter.blur;\n    },\n    set: function(value) {\n        this.blurYFilter.blur = value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n *\n * This inverts your displayObjects colors.\n * @class InvertFilter\n * @contructor\n */\nPIXI.InvertFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        invert: {type: '1f', value: 1},\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float invert;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',\n        '   gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);',\n        //'   gl_FragColor.rgb = gl_FragColor.rgb  * gl_FragColor.a;',\n      //  '   gl_FragColor = gl_FragColor * vColor;',\n        '}'\n    ];\n};\n\nPIXI.InvertFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.InvertFilter.prototype.constructor = PIXI.InvertFilter;\n\n/**\nThe strength of the invert. 1 will fully invert the colors, 0 will make the object its normal color\n@property invert\n*/\nObject.defineProperty(PIXI.InvertFilter.prototype, 'invert', {\n    get: function() {\n        return this.uniforms.invert.value;\n    },\n    set: function(value) {\n        this.uniforms.invert.value = value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n *\n * This applies a sepia effect to your displayObjects.\n * @class SepiaFilter\n * @contructor\n */\nPIXI.SepiaFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        sepia: {type: '1f', value: 1},\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float sepia;',\n        'uniform sampler2D uSampler;',\n\n        'const mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',\n        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);',\n       // '   gl_FragColor = gl_FragColor * vColor;',\n        '}'\n    ];\n};\n\nPIXI.SepiaFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.SepiaFilter.prototype.constructor = PIXI.SepiaFilter;\n\n/**\nThe strength of the sepia. 1 will apply the full sepia effect, 0 will make the object its normal color\n@property sepia\n*/\nObject.defineProperty(PIXI.SepiaFilter.prototype, 'sepia', {\n    get: function() {\n        return this.uniforms.sepia.value;\n    },\n    set: function(value) {\n        this.uniforms.sepia.value = value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n *\n * This filter applies a twist effect making display objects appear twisted in the given direction\n * @class TwistFilter\n * @contructor\n */\nPIXI.TwistFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        radius: {type: '1f', value:0.5},\n        angle: {type: '1f', value:5},\n        offset: {type: '2f', value:{x:0.5, y:0.5}},\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform vec4 dimensions;',\n        'uniform sampler2D uSampler;',\n\n        'uniform float radius;',\n        'uniform float angle;',\n        'uniform vec2 offset;',\n\n        'void main(void) {',\n        '   vec2 coord = vTextureCoord - offset;',\n        '   float distance = length(coord);',\n\n        '   if (distance < radius) {',\n        '       float ratio = (radius - distance) / radius;',\n        '       float angleMod = ratio * ratio * angle;',\n        '       float s = sin(angleMod);',\n        '       float c = cos(angleMod);',\n        '       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);',\n        '   }',\n\n        '   gl_FragColor = texture2D(uSampler, coord+offset);',\n        '}'\n    ];\n};\n\nPIXI.TwistFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.TwistFilter.prototype.constructor = PIXI.TwistFilter;\n\n/**\n *\n * This point describes the the offset of the twist\n * @property size\n * @type Point\n */\nObject.defineProperty(PIXI.TwistFilter.prototype, 'offset', {\n    get: function() {\n        return this.uniforms.offset.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.offset.value = value;\n    }\n});\n\n/**\n *\n * This radius describes size of the twist\n * @property size\n * @type Number\n */\nObject.defineProperty(PIXI.TwistFilter.prototype, 'radius', {\n    get: function() {\n        return this.uniforms.radius.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.radius.value = value;\n    }\n});\n\n/**\n *\n * This radius describes angle of the twist\n * @property angle\n * @type Number\n */\nObject.defineProperty(PIXI.TwistFilter.prototype, 'angle', {\n    get: function() {\n        return this.uniforms.angle.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.angle.value = value;\n    }\n});\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n *\n * This lowers the color depth of your image by the given amount, producing an image with a smaller palette.\n * @class ColorStepFilter\n * @contructor\n */\nPIXI.ColorStepFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        step: {type: '1f', value: 5},\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D uSampler;',\n        'uniform float step;',\n\n        'void main(void) {',\n        '   vec4 color = texture2D(uSampler, vTextureCoord);',\n        '   color = floor(color * step) / step;',\n        '   gl_FragColor = color;',\n        '}'\n    ];\n};\n\nPIXI.ColorStepFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.ColorStepFilter.prototype.constructor = PIXI.ColorStepFilter;\n\n/**\nThe number of steps.\n@property step\n*/\nObject.defineProperty(PIXI.ColorStepFilter.prototype, 'step', {\n    get: function() {\n        return this.uniforms.step.value;\n    },\n    set: function(value) {\n        this.uniforms.step.value = value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js\n */\n\n/**\n *\n * This filter applies a dotscreen effect making display objects appear to be made out of black and white halftone dots like an old printer\n * @class DotScreenFilter\n * @contructor\n */\nPIXI.DotScreenFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        scale: {type: '1f', value:1},\n        angle: {type: '1f', value:5},\n        dimensions:   {type: '4fv', value:[0,0,0,0]}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform vec4 dimensions;',\n        'uniform sampler2D uSampler;',\n\n        'uniform float angle;',\n        'uniform float scale;',\n\n        'float pattern() {',\n        '   float s = sin(angle), c = cos(angle);',\n        '   vec2 tex = vTextureCoord * dimensions.xy;',\n        '   vec2 point = vec2(',\n        '       c * tex.x - s * tex.y,',\n        '       s * tex.x + c * tex.y',\n        '   ) * scale;',\n        '   return (sin(point.x) * sin(point.y)) * 4.0;',\n        '}',\n\n        'void main() {',\n        '   vec4 color = texture2D(uSampler, vTextureCoord);',\n        '   float average = (color.r + color.g + color.b) / 3.0;',\n        '   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);',\n        '}'\n    ];\n};\n\nPIXI.DotScreenFilter.prototype = Object.create( PIXI.DotScreenFilter.prototype );\nPIXI.DotScreenFilter.prototype.constructor = PIXI.DotScreenFilter;\n\n/**\n *\n * This describes the the scale\n * @property scale\n * @type Number\n */\nObject.defineProperty(PIXI.DotScreenFilter.prototype, 'scale', {\n    get: function() {\n        return this.uniforms.scale.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.scale.value = value;\n    }\n});\n\n/**\n *\n * This radius describes angle\n * @property angle\n * @type Number\n */\nObject.defineProperty(PIXI.DotScreenFilter.prototype, 'angle', {\n    get: function() {\n        return this.uniforms.angle.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.angle.value = value;\n    }\n});\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.CrossHatchFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        blur: {type: '1f', value: 1 / 512},\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float blur;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);',\n\n        '    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);',\n\n        '    if (lum < 1.00) {',\n        '        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {',\n        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',\n        '        }',\n        '    }',\n\n        '    if (lum < 0.75) {',\n        '        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {',\n        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',\n        '        }',\n        '    }',\n\n        '    if (lum < 0.50) {',\n        '        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {',\n        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',\n        '        }',\n        '    }',\n\n        '    if (lum < 0.3) {',\n        '        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {',\n        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',\n        '        }',\n        '    }',\n        '}'\n    ];\n};\n\nPIXI.CrossHatchFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.CrossHatchFilter.prototype.constructor = PIXI.BlurYFilter;\n\nObject.defineProperty(PIXI.CrossHatchFilter.prototype, 'blur', {\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n    set: function(value) {\n        //this.padding = value;\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.RGBSplitFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        red: {type: '2f', value: {x:20, y:20}},\n        green: {type: '2f', value: {x:-20, y:20}},\n        blue: {type: '2f', value: {x:20, y:-20}},\n        dimensions:   {type: '4fv', value:[0,0,0,0]}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform vec2 red;',\n        'uniform vec2 green;',\n        'uniform vec2 blue;',\n        'uniform vec4 dimensions;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;',\n        '   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;',\n        '   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;',\n        '   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;',\n        '}'\n    ];\n};\n\nPIXI.RGBSplitFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.RGBSplitFilter.prototype.constructor = PIXI.RGBSplitFilter;\n\nObject.defineProperty(PIXI.RGBSplitFilter.prototype, 'angle', {\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n    set: function(value) {\n        //this.padding = value;\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n});\n\r\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = PIXI;\n        }\n        exports.PIXI = PIXI;\n    } else if (typeof define !== 'undefined' && define.amd) {\n        define(PIXI);\n    } else {\n        root.PIXI = PIXI;\n    }\n}).call(this);",
    "//     Underscore.js 1.6.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.6.0';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return obj;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, length = obj.length; i < length; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results.push(iterator.call(context, value, index, list));\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);\n    each(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !predicate.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    var result = -Infinity, lastComputed = -Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed > lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    var result = Infinity, lastComputed = Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed < lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Shuffle an array, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return value;\n    return _.property(value);\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iterator, context) {\n      var result = {};\n      iterator = lookupIterator(iterator);\n      each(obj, function(value, index) {\n        var key = iterator.call(context, value, index, obj);\n        behavior(result, key, value);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, key, value) {\n    _.has(result, key) ? result[key].push(value) : result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, key, value) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, key) {\n    _.has(result, key) ? result[key]++ : result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    each(input, function(value) {\n      if (_.isArray(value) || _.isArguments(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Split an array into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(array, predicate) {\n    var pass = [], fail = [];\n    each(array, function(elem) {\n      (predicate(elem) ? pass : fail).push(elem);\n    });\n    return [pass, fail];\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.contains(other, item);\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var length = _.max(_.pluck(arguments, 'length').concat(0));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, '' + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(length);\n\n    while(idx < length) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) throw new Error('bindAll must be passed function names');\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n      if (last < wait) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = new Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] === void 0) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))\n                        && ('constructor' in a && 'constructor' in b)) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function () {\n      return value;\n    };\n  };\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    return function(obj) {\n      if (obj === attrs) return true; //avoid comparing an object to itself.\n      for (var key in attrs) {\n        if (attrs[key] !== obj[key])\n          return false;\n      }\n      return true;\n    }\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(Math.max(0, n));\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() { return new Date().getTime(); };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}).call(this);\n",
    "this[\"JST\"] = this[\"JST\"] || {};\n\nthis[\"JST\"][\"app/templates/hello.us\"] = function(obj) {\nobj || (obj = {});\nvar __t, __p = '', __e = _.escape;\nwith (obj) {\n__p += '<div class=\"hello\">\\n  ' +\n((__t = ( text )) == null ? '' : __t) +\n'\\n</div>';\n\n}\nreturn __p\n};",
    "function Agent(type, radius, color) {\n\n  var body = Matter.Bodies.circle(0, 0, radius, {density: 1, friction:0, restitution:0.5, mass:10});\n\n  var sprite = new PIXI.Graphics();\n\n  sprite.beginFill(color);\n  sprite.drawCircle(0,0, radius);\n  sprite.endFill();\n\n  function setBody(value) {\n    body = value;\n  }\n\n  function getBody() {\n    return body;\n  }\n\n  function setPosition(position) {\n      Matter.Body.setPosition(getBody(), position);\n  }\n\n  function getPosition() {\n    return getBody().position;\n  }\n\n  function update (timestamp) {\n    sprite.x = getBody().position.x;\n    sprite.y = getBody().position.y;\n  }\n\n  function handleCollision(collided, physics) {\n  }\n\n  return extend(null, {\n    type:   type,\n    sprite: sprite,\n\n    setBody: setBody,\n    getBody: getBody,\n\n    setPosition: setPosition,\n    getPosition: getPosition,\n\n    handleCollision: handleCollision,\n\n    update: update,\n  });\n}\n",
    "function Equipe1() {\n  var BOT_RADIUS = 4;\n  var BOT_COLOR = 0x357AB7;\n  \n  var agent = new Agent(\"Equipe1\", BOT_RADIUS, BOT_COLOR);\n\n  function setRandomVelocity(){\n  \tMatter.Body.setVelocity(agent.getBody(), {x: -2.5 + Math.random() *5, y: -2.5 + Math.random()*5}\n  )}\n\n  var delay = 0;\n  function update(timestamp) {\n    agent.update(timestamp);\n    delay -= timestamp;\n    if(delay <=0){\n    \tsetRandomVelocity();\n    \tdelay = 500 + Math.random() * 100;\n    }\n  }\n\n  var attached = [];\n  var isTired = false;\n  function handleCollision(collided, physics){\n    if(collided.type === \"Resource\" && !isTired) {\n      if(!_.contains(attached, collided)) {\n        var constraint = physics.attachAgents(agent, collided, 1);\n        attached.push(collided);\n        Matter.Body.setVelocity(agent.getBody(), {x: -20, y: 0});\n        isTired = true;\n        _.delay(function(){\n        \tisTired = false;\n          attached.pop();\n        \tphysics.detachAgents(constraint);\n        }, 1000);\n        \n      }\n    }\n  }\n\n  return extend(agent, {\n    update: update,\n    handleCollision:handleCollision\n });\n}\n",
    "function Equipe2() {\n  var BOT_RADIUS = 4;\n  var BOT_COLOR = 0x22780F;\n  \n  var agent = new Agent(\"Equipe2\", BOT_RADIUS, BOT_COLOR);\n\n  function setRandomVelocity(){\n  \tMatter.Body.setVelocity(agent.getBody(), {x: -2.5 + Math.random() *5, y: -2.5 + Math.random()*5}\n  )}\n\n  var delay = 0;\n  function update(timestamp) {\n    agent.update(timestamp);\n\n    delay -= timestamp;\n    if(delay <=0){\n    \tsetRandomVelocity();\n    \tdelay = 500 + Math.random() * 100;\n    }\n  }\n  var attached = [];\n  var isTired = false;\n  function handleCollision(collided, physics){\n    if(collided.type === \"Resource\" && !isTired) {\n      if(!_.contains(attached, collided)) {\n        var constraint = physics.attachAgents(agent, collided, 1);\n        attached.push(collided);\n        isTired = true;\n        Matter.Body.setVelocity(agent.getBody(), {x: 20, y: 0});\n        _.delay(function(){\n          isTired = false;\n          attached.pop();\n          physics.detachAgents(constraint);\n        }, 1000);\n        \n      }\n    }\n  }\n  return extend(agent, {\n    update: update,\n    handleCollision: handleCollision\n\n });\n}\n",
    "function extend(parent, child) {\n  if(parent) {\n    return Object.freeze(_.extend({}, parent, child));\n    \n  } else {\n\n    return Object.freeze(child);\n  }\n}\n",
    "function init () {\n  var canvasElement = document.querySelector(\"#canvas\");\n\n  var stage = new PIXI.Stage(0xAFAFAF);\n  var renderer = new PIXI.autoDetectRenderer(800,600, canvasElement);\n\n  var world = new World();\n//team 1\n  _.times(40, function(){\n    _.tap(new Equipe1(), function(equipe1){\n      world.add(equipe1);\n      world.setRightPosition(equipe1);\n    });\n  });\n//team 2\n  _.times(40, function(){\n    _.tap(new Equipe2(), function(equipe2){\n      world.add(equipe2);\n      world.setLeftPosition(equipe2);\n    });\n  });\n//Ressource\n    _.times(10, function(){\n    _.tap(new Resource(), function(resource){\n      world.add(resource);\n      world.setRandomPosition(resource);\n    });\n  });\n\n  stage.addChild(world.sprite);\n\n  var prevTimestamp = 0;\n  function animate(timestamp) {\n\n    var deltaTime = timestamp - prevTimestamp;\n    prevTimestamp += deltaTime;\n\n    world.render(deltaTime);\n    renderer.render(stage);\n\n    requestAnimFrame(animate);\n  }\n\n  requestAnimFrame(animate);\n}\n",
    "function Physics(width, height, wallThickness) {\n\n  var bodies = [];\n\n  var engine = Matter.Engine.create({\n    renderer: Matter.RenderPixi,\n    world: {gravity: {x:0, y:0}}\n  });\n\n  function addBody(body) {\n    Matter.World.add(engine.world, [body]);\n    bodies.push(body);\n  }\n\n  function removeBody(body) {\n    Matter.World.remove(engine.world, [body]);\n  }\n\n  function addConstraint(constraint) {\n    Matter.World.addConstraint(engine.world, constraint);\n  }\n\n  function removeConstraint(constraint) {\n    Matter.World.removeConstraint(engine.world, constraint);\n  }\n\n  function collisions() {\n  \treturn Matter.Detector.bruteForce(bodies, engine);\n  }\n\n  function patchPositions() {\n    _.each(bodies, function(body) {\n      patchBodyPosition(body);\n    });\t\n  }\n\n  function patchBodyPosition(body) {\n        Matter.Body.translate(body, {\n          x: body.position.x < wallThickness  ? wallThickness - body.position.x\n                                              : body.position.x > width - wallThickness ? width - wallThickness - body.position.x\n                                                                                        : 0,\n          y: body.position.y < wallThickness  ? wallThickness - body.position.y\n                                              : body.position.y > height - wallThickness ? height - wallThickness - body.position.y\n                                                                                        : 0\n        });\n  }\n\n\n  function update(deltaTime) {\n    Matter.Engine.update(engine, deltaTime);\n  }\n\n  return extend(null, {\n      addBody: addBody,\n      removeBody: removeBody,\n      addConstraint: addConstraint,\n      removeConstraint: removeConstraint,\n\n      update: update,\n      collisions: collisions,\n      patchPositions:  patchPositions\n  });\n}\n",
    "function Resource(){\n\tvar RESOURCE_RADIUS = 4;\n\tvar RESOURCE_COLOR = 0xFFFFFF;\n\n\tvar agent = new Agent(\"Resource\", RESOURCE_RADIUS, RESOURCE_COLOR);\n\n\tvar attached = [];\n\n\tfunction handleCollision(collided, physics){\n\t\tif(collided.type === \"Resource\") {\n\t\t\tif(!_.contains(attached, collided)) {\n\t\t\t\tphysics.attachAgents(agent, collided, 1);\n\t\t\t\tattached.push(collided);\n\t\t\t}\n\t\t}\n\t}\n\treturn extend(agent, {\n\t\thandleCollision: handleCollision\n\t});\n}",
    "function World() {\n\n  var WIDTH = 800;\n  var HEIGHT = 600;\n  var WALL_THICKNESS = 50;\n\n  var agents = [];\n\n  var botsContainer = new PIXI.DisplayObjectContainer();\n\n\n  var ground    = Matter.Bodies.rectangle(WIDTH/2,\n                                          HEIGHT-WALL_THICKNESS/2,\n                                          WIDTH,\n                                          WALL_THICKNESS,\n                                          { isStatic: true });\n\n  var leftWall  = Matter.Bodies.rectangle(WALL_THICKNESS/2,\n                                          HEIGHT/2,\n                                          WALL_THICKNESS,\n                                          HEIGHT,\n                                          { isStatic: true });\n\n  var rightWall = Matter.Bodies.rectangle(WIDTH - WALL_THICKNESS/2,\n                                          HEIGHT/2,\n                                          WALL_THICKNESS,\n                                          HEIGHT,\n                                          { isStatic: true });\n\n  var topWall   = Matter.Bodies.rectangle(WIDTH/2,\n                                          WALL_THICKNESS/2,\n                                          WIDTH,\n                                          WALL_THICKNESS,\n                                          {isStatic: true, render: { visible: true } });\n\n\n  var physics = new Physics(WIDTH, HEIGHT, WALL_THICKNESS);\n  physics.addBody(ground);\n  physics.addBody(leftWall);\n  physics.addBody(rightWall);\n  physics.addBody(topWall);\n\n\n  function add (agent) {\n    agents.push(agent);\n    botsContainer.addChild(agent.sprite);\n    physics.addBody(agent.getBody());\n    agent.getBody().agent = agent;\n  }\n\n  function setRandomPosition(agent) {\n    agent.setPosition({x:WALL_THICKNESS + Math.random() * WIDTH - WALL_THICKNESS*2,\n                       y:WALL_THICKNESS + Math.random() * HEIGHT - WALL_THICKNESS*2});\n  }\n\n  function setLeftPosition(agent) {\n    agent.setPosition({x:WALL_THICKNESS + 10 ,\n                       y:WALL_THICKNESS + Math.random() * HEIGHT - WALL_THICKNESS*2});\n  }\n  function setRightPosition(agent) {\n    agent.setPosition({x:WALL_THICKNESS + WIDTH - WALL_THICKNESS*2,\n                       y:WALL_THICKNESS + Math.random() * HEIGHT - WALL_THICKNESS*2});\n  }\n  function setCenterPosition(agent) {\n    agent.setPosition({x: WIDTH / 2,\n                       y:HEIGHT / 2});\n  }\n\n  var physicsHelper = {\n    attachAgents: function (agentA, agentB, stiffness) {\n      var constraint = Matter.Constraint.create({bodyA:agentA.getBody(), bodyB:agentB.getBody(), stiffness:stiffness});\n      physics.addConstraint(constraint);\n\n      return constraint;\n    },\n    detachAgents: function (constraint) {\n      physics.removeConstraint(constraint);\n    }\n  };\n\n\n  function processCollisions() {\n    var collisions = physics.collisions();\n    _.each(collisions, function(collision) {\n      if(collision.bodyA.agent && collision.bodyB.agent) {\n        collision.bodyA.agent.handleCollision(collision.bodyB.agent, physicsHelper);\n        collision.bodyB.agent.handleCollision(collision.bodyA.agent, physicsHelper);\n      }\n    });\n  }\n\n  function render (deltaTime) {\n    agents.forEach(function(agent) {\n      agent.update(deltaTime);\n    });\n\n    physics.update(deltaTime);\n    //physics.patchPositions();\n    processCollisions();\n  }\n\n  return extend(null, {\n    add: add,\n    render: render,\n    sprite: botsContainer,\n    agents: agents,\n\n    setRandomPosition: setRandomPosition,\n    setLeftPosition: setLeftPosition,\n    setRightPosition: setRightPosition,\n    setCenterPosition: setCenterPosition\n  });\n}\n"
  ]
}